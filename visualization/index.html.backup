<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trait Interp Visualization</title>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            },
            startup: {
                ready: () => {
                    MathJax.startup.defaultReady();
                    console.log('MathJax loaded');
                }
            }
        };
    </script>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        :root {
            --bg-primary: #f8f9fa;
            --bg-secondary: #ffffff;
            --bg-tertiary: #f8f9fa;
            --text-primary: #333;
            --text-secondary: #666;
            --text-tertiary: #888;
            --border-color: #ddd;
            --shadow: rgba(0,0,0,0.1);
            --primary-color: #007bff;
            --primary-hover: #0056b3;
            --success: #28a745;
            --danger: #dc3545;
            --info-bg: #d1ecf1;
            --info-border: #17a2b8;
            --info-text: #0c5460;
        }

        [data-theme="dark"] {
            --bg-primary: #1a1a1a;
            --bg-secondary: #2d2d2d;
            --bg-tertiary: #3a3a3a;
            --text-primary: #e0e0e0;
            --text-secondary: #b0b0b0;
            --text-tertiary: #888;
            --border-color: #444;
            --shadow: rgba(0,0,0,0.3);
            --primary-color: #4a9eff;
            --primary-hover: #6bb0ff;
            --success: #4caf50;
            --danger: #f44336;
            --info-bg: #1e3a4a;
            --info-border: #2196f3;
            --info-text: #90caf9;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--bg-primary);
            padding: 16px;
            transition: background 0.15s ease;
            font-size: 12px;
            line-height: 1.3;
        }

        .container {
            display: flex;
            gap: 16px;
            max-width: 100%;
            height: 100vh;
            overflow: hidden;
        }

        .transformer-sidebar {
            width: 550px;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            transition: all 0.15s ease;
            position: relative;
        }

        .transformer-sidebar.hidden {
            width: 0;
            overflow: hidden;
        }

        .transformer-header {
            padding: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            background: var(--bg-primary);
            z-index: 10;
            margin-bottom: 8px;
        }

        .transformer-title {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .transformer-toggle {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 14px;
            padding: 4px;
            line-height: 1;
            transition: color 0.15s ease;
        }

        .transformer-toggle:hover {
            color: var(--primary-color);
        }

        .transformer-content {
            padding: 0 8px;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .layer-box {
            padding: 6px 8px;
            border-radius: 4px;
            transition: color 0.15s ease;
            cursor: pointer;
        }

        .layer-box.highlighted {
            color: var(--primary-color);
        }

        .layer-number {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 2px;
        }

        .sublayer {
            font-size: 10px;
            color: var(--text-secondary);
            padding: 2px 4px;
            border-radius: 3px;
            margin-bottom: 2px;
        }

        .sublayer:last-child {
            margin-bottom: 0;
        }

        .layer-ellipsis {
            text-align: center;
            padding: 8px;
            color: var(--text-tertiary);
            font-size: 11px;
            font-weight: 600;
        }

        .arch-diagram {
            margin-top: 20px;
            padding: 20px 15px;
            border-top: 2px solid var(--border-color);
        }

        .arch-diagram-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 20px;
            text-align: center;
        }

        .arch-layout {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .arch-column {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0;
            position: relative;
            width: 100%;
            max-width: 400px;
        }

        .flow-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
        }

        .component-layer {
            position: relative;
            z-index: 1;
            width: 100%;
        }

        .arch-column-title {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .token-display {
            background: var(--bg-tertiary);
            border: 2px dashed var(--border-color);
            border-radius: 8px;
            padding: 12px 20px;
            font-size: 20px;
            font-weight: 700;
            color: var(--text-primary);
            font-family: 'Monaco', 'Menlo', monospace;
        }

        .decoder-block {
            display: flex;
            flex-direction: column-reverse;
            align-items: center;
            gap: 0;
            width: 100%;
            position: relative;
        }

        .block-container {
            background: transparent;
            border: none;
            border-radius: 10px;
            padding: 20px;
            width: 100%;
            position: relative;
            margin: 12px 0;
        }

        .block-container.mlp-block {
            background: rgba(186, 104, 200, 0.08);
        }

        [data-theme="dark"] .block-container.mlp-block {
            background: rgba(171, 71, 188, 0.12);
        }

        .block-container.attn-block {
            background: rgba(102, 187, 106, 0.08);
        }

        [data-theme="dark"] .block-container.attn-block {
            background: rgba(76, 175, 80, 0.12);
        }

        .block-title {
            font-size: 12px;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 10px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .arch-box {
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 10px;
            font-weight: 600;
            color: var(--text-primary);
            text-align: center;
            width: 100%;
            transition: all 0.2s ease;
        }

        .arch-box:hover {
            border-color: var(--primary-color);
            transform: scale(1.02);
        }

        .arch-box.norm {
            background: #e3f2fd;
            border-color: #90caf9;
        }

        [data-theme="dark"] .arch-box.norm {
            background: #1e3a4a;
            border-color: #2196f3;
        }

        .arch-arrow {
            display: none;
        }

        .flow-path {
            fill: none;
            stroke: var(--primary-color);
            stroke-width: 3;
            opacity: 0.6;
        }

        .flow-arrow {
            fill: var(--primary-color);
            opacity: 0.8;
        }

        .skip-path {
            fill: none;
            stroke: var(--primary-color);
            stroke-width: 4;
            opacity: 0.7;
            stroke-dasharray: 8, 4;
        }

        .skip-arrow {
            position: absolute;
            right: -40px;
            top: -10px;
            bottom: -10px;
            width: 35px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            color: var(--primary-color);
        }

        .skip-line {
            width: 5px;
            flex-grow: 1;
            background: var(--primary-color);
            margin: 0;
            border-radius: 3px;
        }

        .skip-arrow-up {
            font-size: 28px;
            line-height: 1;
            font-weight: bold;
            margin-bottom: -8px;
        }

        .neuron-layer {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            margin: 10px 0;
        }

        .neuron {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--primary-color);
        }

        .neuron.large-layer {
            background: #ba68c8;
        }

        .neuron-connections {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .connection-lines {
            width: 100%;
            height: 40px;
            position: relative;
        }

        .stream-split {
            display: flex;
            gap: 15px;
            align-items: flex-start;
            width: 100%;
            margin: 10px 0;
        }

        .stream-box {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .stream-label {
            font-size: 8px;
            color: var(--text-secondary);
            text-transform: uppercase;
            font-weight: 600;
            letter-spacing: 0.5px;
        }

        .attention-heads {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 5px;
            width: 100%;
            margin: 10px 0;
        }

        .attention-head {
            background: var(--primary-color);
            color: white;
            border-radius: 4px;
            padding: 8px 4px;
            font-size: 9px;
            font-weight: 600;
            text-align: center;
        }

        .qkv-container {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 6px;
            width: 100%;
            margin: 10px 0;
        }

        .qkv-box {
            background: var(--primary-color);
            color: white;
            border-radius: 5px;
            padding: 10px;
            font-size: 11px;
            font-weight: 600;
            text-align: center;
        }

        .gqa-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
            width: 100%;
            margin-top: 10px;
        }

        .gqa-query-heads {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 3px;
        }

        .gqa-kv-heads {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 5px;
        }

        .gqa-query {
            background: var(--primary-color);
            color: white;
            border-radius: 3px;
            padding: 6px 2px;
            font-size: 8px;
            font-weight: 600;
            text-align: center;
        }

        .gqa-kv {
            background: var(--success);
            color: white;
            border-radius: 4px;
            padding: 8px 4px;
            font-size: 9px;
            font-weight: 600;
            text-align: center;
        }

        .gqa-label {
            font-size: 10px;
            color: var(--text-secondary);
            text-align: center;
            font-weight: 600;
        }

        .inner-content {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .input-output-box {
            padding: 6px;
            text-align: center;
            font-size: 10px;
            font-weight: 600;
            color: var(--text-tertiary);
            opacity: 0.6;
        }

        .sidebar {
            width: 240px;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            transition: background 0.15s ease;
        }

        .sidebar-header {
            padding: 12px;
            position: sticky;
            top: 0;
            background: var(--bg-primary);
            z-index: 10;
            margin-bottom: 16px;
        }

        .sidebar-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 2px;
            transition: color 0.15s ease;
        }

        .sidebar-subtitle {
            font-size: 11px;
            color: var(--text-secondary);
            transition: color 0.15s ease;
        }

        .sidebar-section {
            padding: 0 12px;
            margin-bottom: 32px;
        }

        .section-title {
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            color: var(--text-tertiary);
            margin-bottom: 8px;
            letter-spacing: 0.5px;
        }

        .nav-item {
            padding: 6px 8px;
            margin-bottom: 2px;
            border-radius: 4px;
            cursor: pointer;
            transition: color 0.15s ease;
            color: var(--text-secondary);
            font-size: 12px;
            font-weight: 400;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .nav-item:hover {
            color: var(--text-primary);
        }

        .nav-item.active {
            color: var(--primary-color);
        }

        .nav-item .icon {
            font-size: 14px;
        }

        .trait-checkbox {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            margin-bottom: 2px;
            border-radius: 4px;
            cursor: pointer;
            transition: color 0.15s ease;
            font-size: 11px;
            color: var(--text-secondary);
        }

        .trait-checkbox:hover {
            color: var(--text-primary);
        }

        .trait-checkbox input[type="checkbox"] {
            cursor: pointer;
        }

        .trait-checkbox label {
            cursor: pointer;
            margin: 0;
            flex: 1;
            color: inherit;
        }

        .select-all-btn {
            padding: 4px 8px;
            font-size: 10px;
            margin-bottom: 8px;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        header {
            padding: 8px 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .header-left {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .header-right {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .info-btn, .theme-toggle {
            background: transparent;
            border: none;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 14px;
            color: var(--text-secondary);
            transition: color 0.15s ease;
        }

        .info-btn:hover, .theme-toggle:hover {
            color: var(--primary-color);
        }

        .info-tooltip {
            position: fixed;
            top: 50px;
            left: 16px;
            background: var(--bg-primary);
            border-radius: 4px;
            padding: 12px;
            max-width: 400px;
            z-index: 1000;
            display: none;
            max-height: calc(100vh - 80px);
            overflow-y: auto;
        }

        .info-tooltip.show {
            display: block;
        }

        .info-tooltip h3 {
            color: var(--text-primary);
            margin-bottom: 12px;
            font-size: 13px;
        }

        .info-tooltip h4 {
            color: var(--text-secondary);
            margin-top: 12px;
            margin-bottom: 6px;
            font-size: 11px;
        }

        .info-tooltip ul {
            margin-left: 16px;
            color: var(--text-secondary);
            font-size: 11px;
            line-height: 1.3;
        }

        .info-tooltip strong {
            color: var(--text-secondary);
        }

        .info-tooltip .trait-list {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4px;
            margin-top: 6px;
            list-style: none;
            margin-left: 0;
        }

        .info-tooltip .trait-list li {
            color: var(--text-secondary);
        }

        .page-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            transition: color 0.15s ease;
        }

        .experiment-badge {
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 10px;
            color: var(--text-tertiary);
            font-weight: 400;
        }

        .content-wrapper {
            flex: 1;
            overflow-y: auto;
            padding: 0 12px 12px 12px;
        }

        label {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 4px;
            transition: color 0.15s ease;
        }

        select, button {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            background: transparent;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.15s ease;
        }

        button {
            color: var(--text-secondary);
            border: none;
            font-weight: 400;
            transition: color 0.15s ease;
        }

        button:hover {
            color: var(--primary-color);
        }

        button:disabled {
            color: var(--text-tertiary);
            cursor: not-allowed;
            opacity: 0.5;
        }

        .tabs {
            padding: 0;
            margin-bottom: 32px;
            overflow: hidden;
        }

        .tab-buttons {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
        }

        .tab-button {
            padding: 6px 12px;
            background: transparent;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 400;
            font-size: 11px;
            color: var(--text-secondary);
            transition: color 0.15s ease;
        }

        .tab-button:hover {
            color: var(--text-primary);
        }

        .tab-button.active {
            color: var(--primary-color);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .card {
            margin-bottom: 32px;
        }

        .card-title {
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 12px;
            color: var(--text-primary);
            transition: color 0.15s ease;
        }

        .stats-grid {
            display: flex;
            gap: 16px;
            margin-bottom: 16px;
        }

        .stat-card {
            display: inline-block;
        }

        .stat-label {
            font-size: 10px;
            color: var(--text-tertiary);
            transition: color 0.15s ease;
        }

        .stat-value {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            transition: color 0.15s ease;
            margin-left: 4px;
        }

        .stat-detail {
            display: none;
        }

        .trait-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 15px;
        }

        .trait-card {
            background: var(--bg-secondary);
            padding: 15px;
            border-radius: 6px;
            border: 2px solid var(--border-color);
            cursor: pointer;
            transition: all 0.2s;
        }

        .trait-card:hover {
            border-color: var(--primary-color);
            box-shadow: 0 4px 8px var(--shadow);
            transform: translateY(-2px);
        }

        .trait-card.selected {
            border-color: var(--primary-color);
            background: var(--bg-tertiary);
        }

        .trait-name {
            font-weight: 600;
            font-size: 16px;
            margin-bottom: 8px;
            color: var(--text-primary);
            transition: color 0.3s ease;
        }

        .trait-info {
            font-size: 12px;
            color: var(--text-secondary);
            transition: color 0.3s ease;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: var(--text-secondary);
            transition: color 0.3s ease;
        }

        .error {
            background: #fff3cd;
            border: 1px solid #ffc107;
            padding: 15px;
            border-radius: 6px;
            margin: 20px 0;
            color: #856404;
        }

        .info {
            background: var(--info-bg);
            border: 1px solid var(--info-border);
            padding: 15px;
            border-radius: 6px;
            margin: 20px 0;
            color: var(--info-text);
            transition: all 0.3s ease;
        }

        .explanation {
            background: var(--bg-secondary);
            padding: 15px 20px;
            margin: 20px 0;
            border-left: 3px solid var(--text-tertiary);
            color: var(--text-secondary);
            font-size: 14px;
            line-height: 1.8;
            transition: all 0.3s ease;
        }

        .explanation-summary {
            color: var(--text-primary);
            font-size: 14px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            padding: 5px 0;
        }

        .explanation-summary:hover {
            color: var(--primary-color);
        }

        .explanation-summary::after {
            content: '‚Üí';
            font-size: 12px;
            color: var(--text-tertiary);
            transition: transform 0.3s ease;
        }

        .explanation-summary:hover::after {
            transform: translateX(4px);
            color: var(--primary-color);
        }

        .explanation-details {
            display: none;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid var(--border-color);
        }

        .explanation.expanded {
            border-left-color: var(--primary-color);
            background: var(--bg-tertiary);
        }

        .explanation.expanded .explanation-details {
            display: block;
        }

        .explanation.expanded .explanation-summary::after {
            content: '‚Üì';
        }

        .explanation-details h4 {
            color: var(--text-primary);
            font-size: 15px;
            font-weight: 600;
            margin: 15px 0 10px 0;
        }

        .explanation-details h4:first-child {
            margin-top: 0;
        }

        .explanation-details ul {
            margin: 10px 0 10px 20px;
        }

        .explanation-details code {
            background: var(--bg-tertiary);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
        }

        .response-preview {
            background: var(--bg-tertiary);
            padding: 12px;
            border-radius: 4px;
            font-size: 13px;
            line-height: 1.6;
            margin: 8px 0;
            border-left: 3px solid var(--primary-color);
            color: var(--text-primary);
            transition: all 0.3s ease;
        }

        .score-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            margin-left: 8px;
        }

        .score-high {
            background: #d4edda;
            color: #155724;
        }

        .score-low {
            background: #f8d7da;
            color: #721c24;
        }

        #token-slider {
            width: 100%;
            margin: 15px 0;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            color: #666;
            margin-bottom: 8px;
        }

        .token-highlight {
            background: #ffeb3b;
            padding: 2px 4px;
            border-radius: 3px;
            font-weight: 600;
        }

        .response-text {
            line-height: 1.8;
            font-size: 14px;
            color: var(--text-primary);
            transition: color 0.3s ease;
        }

        pre {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            transition: all 0.3s ease;
        }

        code {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            padding: 2px 6px;
            border-radius: 3px;
            transition: all 0.3s ease;
        }

        /* Data Explorer Styles */
        .explorer-trait-card {
            margin-bottom: 0;
            overflow: hidden;
            transition: all 0.15s ease;
        }

        .explorer-trait-header {
            padding: 2px 0;
            cursor: pointer;
            color: var(--text-primary);
            transition: color 0.15s ease;
            font-size: 12px;
            font-family: 'Courier New', monospace;
        }

        .explorer-trait-header::before {
            content: '‚ñ∏ ';
            color: var(--text-tertiary);
        }

        .explorer-trait-header.expanded::before {
            content: '‚ñæ ';
            color: var(--primary-color);
        }

        .explorer-trait-header:hover {
            color: var(--primary-color);
        }

        .explorer-trait-header.expanded {
            color: var(--primary-color);
        }

        .explorer-trait-header strong,
        .explorer-trait-header span {
            color: inherit;
        }

        .explorer-trait-body {
            padding: 0 0 0 12px;
            display: none;
        }

        .explorer-trait-body.show {
            display: block;
        }

        .file-tree {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.2;
        }

        .file-item {
            padding: 1px 0;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .file-item.clickable {
            cursor: pointer;
            transition: color 0.15s ease;
        }

        .file-item.clickable:hover {
            color: var(--primary-color);
        }

        .file-item strong,
        .file-item span {
            color: inherit;
        }

        .file-icon {
            font-size: 11px;
        }

        .preview-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.85);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            padding: 16px;
        }

        .preview-modal.show {
            display: flex;
        }

        .preview-content {
            background: var(--bg-primary);
            border-radius: 4px;
            max-width: 900px;
            max-height: 80vh;
            width: 100%;
            display: flex;
            flex-direction: column;
        }

        .preview-header {
            padding: 8px 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
        }

        .preview-body {
            padding: 12px;
            overflow-y: auto;
            flex: 1;
        }

        .close-btn {
            background: transparent;
            color: var(--text-secondary);
            border: none;
            cursor: pointer;
            font-size: 16px;
            padding: 4px;
            transition: color 0.15s ease;
        }

        .close-btn:hover {
            color: var(--danger);
        }

        .json-viewer {
            padding: 8px;
            border-radius: 4px;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            line-height: 1.3;
        }

        .json-viewer pre {
            margin: 0;
            color: var(--text-secondary);
        }

        .json-key {
            color: #61afef;
        }

        .json-string {
            color: #98c379;
        }

        .json-number {
            color: #d19a66;
        }

        .json-boolean {
            color: #c678dd;
        }

        .json-null {
            color: #e06c75;
        }

        .csv-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
        }

        .csv-table th,
        .csv-table td {
            padding: 4px 8px;
            text-align: left;
        }

        .csv-table th {
            font-weight: 600;
            color: var(--text-primary);
        }

        .csv-table td {
            color: var(--text-secondary);
        }

        .indent-1 { padding-left: 12px; }
        .indent-2 { padding-left: 24px; }
        .indent-3 { padding-left: 36px; }

        .quadrant-score:hover {
            color: var(--primary-color) !important;
            text-decoration-style: solid !important;
        }
    </style>
</head>
<body>
    <!-- Preview modal (global) -->
    <div class="preview-modal" id="preview-modal">
        <div class="preview-content">
            <div class="preview-header">
                <h3 id="preview-title" style="margin: 0; color: var(--text-primary);"></h3>
                <button class="close-btn" onclick="closePreview()">√ó</button>
            </div>
            <div class="preview-body" id="preview-body"></div>
        </div>
    </div>

    <!-- Info tooltip (global) -->
    <div class="info-tooltip" id="info-tooltip">
        <h3>üìä Trait Interpretation Visualization</h3>

        <h4>üîß Tools:</h4>
        <ul>
            <li><strong>Data Explorer</strong> - Inspect file structure, sizes, and preview data</li>
            <li><strong>Overview</strong> - Browse all extracted traits with metadata and example counts</li>
            <li><strong>Vector Analysis</strong> - Compare extraction methods across 27 layers with heatmaps</li>
            <li><strong>All Layers</strong> - View trait evolution across all 27 layers (Tier 2 data)</li>
            <li><strong>Layer Deep Dive</strong> - Analyze attention heads and top neurons for one layer (Tier 3 data)</li>
        </ul>

        <h4>üß† Available Traits (16 cognitive primitives):</h4>
        <div class="trait-list">
            <li>refusal</li>
            <li>uncertainty_calibration</li>
            <li>sycophancy</li>
            <li>retrieval_construction</li>
            <li>commitment_strength</li>
            <li>abstract_concrete</li>
            <li>cognitive_load</li>
            <li>context_adherence</li>
            <li>convergent_divergent</li>
            <li>emotional_valence</li>
            <li>instruction_boundary</li>
            <li>local_global</li>
            <li>paranoia_trust</li>
            <li>power_dynamics</li>
            <li>serial_parallel</li>
            <li>temporal_focus</li>
        </div>

        <h4>üí° Quick Tips:</h4>
        <ul>
            <li>Select traits in the sidebar to filter data</li>
            <li>Use the theme toggle (üåô/‚òÄÔ∏è) for dark mode</li>
            <li>Separation scores >40 indicate excellent quality</li>
        </ul>
    </div>

    <div class="container">
        <!-- Transformer Architecture Visualization -->
        <div class="transformer-sidebar" id="transformer-sidebar">
            <div class="transformer-header">
                <div class="transformer-title">Architecture</div>
                <button class="transformer-toggle" id="transformer-toggle" title="Hide architecture">‚óÄ</button>
            </div>
            <div class="transformer-content">
                <!-- Output at top -->
                <div class="input-output-box">Output</div>

                <!-- Last layer (top of stack) -->
                <div class="layer-box" data-layer="25">
                    <div class="layer-number">Layer 25</div>
                    <div class="sublayer">Add & Norm</div>
                    <div class="sublayer">Feed Forward</div>
                    <div class="sublayer">Add & Norm</div>
                    <div class="sublayer">Multi-Head Attention</div>
                </div>

                <!-- Ellipsis -->
                <div class="layer-ellipsis">‚Üë<br>[24 more layers]<br>‚Üë</div>

                <!-- First layer (bottom of stack) -->
                <div class="layer-box" data-layer="0">
                    <div class="layer-number">Layer 0</div>
                    <div class="sublayer">Add & Norm</div>
                    <div class="sublayer">Feed Forward</div>
                    <div class="sublayer">Add & Norm</div>
                    <div class="sublayer">Multi-Head Attention</div>
                </div>

                <!-- Input at bottom -->
                <div class="input-output-box">Input Embedding</div>

                <!-- Detailed Architecture Diagram -->
                <div class="arch-diagram">
                    <div class="arch-diagram-title">Transformer Decoder Layer Flow</div>

                    <div class="arch-layout">
                        <div class="arch-column">
                            <!-- SVG for continuous flow lines -->
                            <svg class="flow-svg" viewBox="0 0 500 1400" preserveAspectRatio="xMidYMid meet">
                                <!-- Main residual stream (center line) -->
                                <path class="flow-path" d="M 250 50 L 250 1350" stroke-width="4" />

                                <!-- Arrows pointing DOWN -->
                                <polygon class="flow-arrow" points="250,1340 245,1330 255,1330" />
                                <polygon class="flow-arrow" points="250,1100 245,1090 255,1090" />
                                <polygon class="flow-arrow" points="250,800 245,790 255,790" />
                                <polygon class="flow-arrow" points="250,300 245,290 255,290" />

                                <!-- ATTENTION skip connection (residual) -->
                                <!-- Copy goes around the attention block -->
                                <path class="skip-path" d="M 380 900 L 380 1200" stroke-width="5" />
                                <polygon class="flow-arrow" points="380,1190 375,1180 385,1180" />

                                <!-- MLP skip connection (residual) -->
                                <!-- Copy goes around the MLP block -->
                                <path class="skip-path" d="M 380 400 L 380 700" stroke-width="5" />
                                <polygon class="flow-arrow" points="380,690 375,680 385,680" />
                            </svg>

                            <div class="decoder-block">
                                <!-- OUTPUT token at TOP -->
                                <div class="component-layer">
                                    <div class="token-display">"!"</div>
                                    <div style="font-size: 9px; color: var(--text-tertiary); margin-top: 5px;">‚Üê sampled output</div>
                                </div>

                                <!-- Final output (after MLP + residual) -->
                                <div class="component-layer" style="margin: 20px 0;">
                                    <div class="arch-box norm">Add & Norm (final)</div>
                                </div>

                                <!-- MLP Block -->
                                <div class="component-layer">
                                    <div class="block-container mlp-block">
                                        <div class="block-title">MLP (Feed Forward)</div>
                                        <div class="neuron-connections">
                                            <!-- Output: back to d_model -->
                                            <div class="neuron-layer">
                                                <div class="neuron"></div>
                                                <div class="neuron"></div>
                                                <div class="neuron"></div>
                                                <div class="neuron"></div>
                                                <div class="neuron"></div>
                                            </div>
                                            <div style="font-size: 8px; color: var(--text-tertiary); margin: 5px 0;">‚Üë d=2304</div>

                                            <div class="arch-box" style="font-size: 9px; padding: 4px; margin: 8px 0;">Linear Down</div>

                                            <!-- Hidden layer: 4x expansion -->
                                            <div class="neuron-layer">
                                                <div class="neuron large-layer"></div>
                                                <div class="neuron large-layer"></div>
                                                <div class="neuron large-layer"></div>
                                                <div class="neuron large-layer"></div>
                                                <div class="neuron large-layer"></div>
                                                <div class="neuron large-layer"></div>
                                                <div class="neuron large-layer"></div>
                                                <div class="neuron large-layer"></div>
                                                <div class="neuron large-layer"></div>
                                                <div class="neuron large-layer"></div>
                                            </div>
                                            <div style="font-size: 8px; color: var(--text-tertiary); margin: 5px 0;">‚Üë d=9216 (4x)</div>

                                            <div class="arch-box" style="font-size: 9px; padding: 4px; margin: 8px 0;">GELU</div>

                                            <!-- Input to MLP -->
                                            <div class="neuron-layer">
                                                <div class="neuron"></div>
                                                <div class="neuron"></div>
                                                <div class="neuron"></div>
                                                <div class="neuron"></div>
                                                <div class="neuron"></div>
                                            </div>
                                            <div style="font-size: 8px; color: var(--text-tertiary); margin: 5px 0;">‚Üë d=2304</div>

                                            <div class="arch-box" style="font-size: 9px; padding: 4px; margin: 8px 0;">Linear Up</div>
                                        </div>
                                    </div>
                                </div>

                                <!-- After attention, before MLP -->
                                <div class="component-layer" style="margin: 20px 0;">
                                    <div class="arch-box norm">Add & Norm</div>
                                    <div style="font-size: 8px; color: var(--text-tertiary); margin-top: 5px;">‚Üê residual + attention output</div>
                                </div>

                                <!-- Attention Block -->
                                <div class="component-layer">
                                    <div class="block-container attn-block">
                                        <div class="block-title">Self-Attention</div>
                                        <div class="inner-content">
                                            <!-- Attention output -->
                                            <div class="arch-box">Attention Output</div>
                                            <div style="font-size: 8px; color: var(--text-tertiary); margin: 8px 0;">‚Üë</div>

                                            <!-- Attention computation -->
                                            <div class="arch-box" style="margin: 8px 0;">softmax(QK'/‚àöd) √ó V</div>
                                            <div style="font-size: 8px; color: var(--text-tertiary); margin: 8px 0;">‚Üë</div>

                                            <!-- Q, K, V projections from same normalized input -->
                                            <div class="stream-split" style="margin: 10px 0;">
                                                <div class="stream-box">
                                                    <div class="qkv-box">Q</div>
                                                    <div class="stream-label">Query</div>
                                                </div>
                                                <div class="stream-box">
                                                    <div class="qkv-box">K</div>
                                                    <div class="stream-label">Key</div>
                                                </div>
                                                <div class="stream-box">
                                                    <div class="qkv-box">V</div>
                                                    <div class="stream-label">Value</div>
                                                </div>
                                            </div>
                                            <div style="font-size: 8px; color: var(--text-tertiary); margin: 8px 0;">‚Üë (3 linear projections)</div>
                                        </div>
                                    </div>
                                </div>

                                <!-- First layer norm (before attention) -->
                                <div class="component-layer" style="margin: 20px 0;">
                                    <div class="arch-box norm">Layer Norm</div>
                                    <div style="font-size: 8px; color: var(--text-tertiary); margin-top: 5px;">‚Üê normalizes residual stream</div>
                                </div>

                                <!-- INPUT token at BOTTOM -->
                                <div class="component-layer" style="margin-top: 20px;">
                                    <div class="token-display">"Spread "</div>
                                    <div style="font-size: 9px; color: var(--text-tertiary); margin-top: 5px;">‚Üê input embedding</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Sidebar -->
        <div class="sidebar">
            <div class="sidebar-header">
                <div class="sidebar-title">Trait Interp</div>
                <div class="sidebar-subtitle">Vector Visualization</div>
            </div>

            <div class="sidebar-section">
                <div class="section-title">Experiments</div>
                <div id="experiment-list">
                    <div class="nav-item" style="opacity: 0.5; cursor: default;">Loading...</div>
                </div>
            </div>

            <div class="sidebar-section">
                <div class="section-title">Extraction</div>
                <div id="nav-items-extraction">
                    <div class="nav-item active" data-view="data-explorer">
                        <span class="icon">üóÇÔ∏è</span>
                        <span>Data Explorer</span>
                    </div>
                    <div class="nav-item" data-view="vectors">
                        <span class="icon">üî¨</span>
                        <span>Vector Analysis</span>
                    </div>
                    <div class="nav-item" data-view="cross-distribution">
                        <span class="icon">üîÄ</span>
                        <span>Cross-Distribution</span>
                    </div>
                </div>
            </div>

            <div class="sidebar-section">
                <div class="section-title">Inference</div>
                <div id="nav-items-inference">
                    <div class="nav-item" data-view="monitoring">
                        <span class="icon">‚ö°</span>
                        <span>All Layers</span>
                    </div>
                    <div class="nav-item" data-view="prompt-activation">
                        <span class="icon">üìç</span>
                        <span>Per-Token Activation</span>
                    </div>
                    <div class="nav-item" data-view="layer-dive">
                        <span class="icon">üîç</span>
                        <span>Layer Deep Dive</span>
                    </div>
                </div>
            </div>

            <div class="sidebar-section">
                <div class="section-title">
                    Selected Traits (<span id="selected-count">0</span>)
                </div>
                <button class="select-all-btn" id="select-all-btn">Select All</button>
                <div id="trait-checkboxes"></div>
            </div>
        </div>

        <!-- Main Content -->
        <div class="main-content">
            <header>
                <div class="header-left">
                    <button class="info-btn" id="info-btn" title="Information">‚ÑπÔ∏è</button>
                    <div class="page-title" id="page-title">Overview</div>
                    <div class="experiment-badge" id="experiment-badge">-</div>
                </div>
                <div class="header-right">
                    <button class="theme-toggle" id="theme-toggle" title="Toggle dark mode">üåô</button>
                </div>
            </header>

            <div class="content-wrapper" id="content-area">
                <div class="loading">Loading experiment data...</div>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let experiments = [];
        let currentExperiment = null;
        let experimentData = null;
        let currentView = 'data-explorer';
        let selectedTraits = new Set();

        // Display names for better interpretability
        const DISPLAY_NAMES = {
            'uncertainty_calibration': 'Confidence',
            'instruction_boundary': 'Literalness',
            'commitment_strength': 'Assertiveness',
            'retrieval_construction': 'Retrieval',
            'convergent_divergent': 'Thinking Style',
            'abstract_concrete': 'Abstraction Level',
            'temporal_focus': 'Temporal Orientation',
            'cognitive_load': 'Complexity',
            'context_adherence': 'Context Following',
            'emotional_valence': 'Emotional Tone',
            'paranoia_trust': 'Trust Level',
            'power_dynamics': 'Authority Tone',
            'serial_parallel': 'Processing Style',
            'local_global': 'Focus Scope'
            // 'refusal' and 'sycophancy' are clear as-is
        };

        function getDisplayName(traitName) {
            // Parse trait name: "refusal" or "refusal_natural"
            let baseName = traitName;
            let method = '';

            if (traitName.endsWith('_natural')) {
                baseName = traitName.replace('_natural', '');
                method = ' (Natural)';
            }

            // Get display name for base trait
            let displayBase = DISPLAY_NAMES[baseName] || baseName.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());

            return displayBase + method;
        }

        // Transformer sidebar toggle
        function toggleTransformerSidebar() {
            const sidebar = document.getElementById('transformer-sidebar');
            const toggle = document.getElementById('transformer-toggle');

            if (sidebar.classList.contains('hidden')) {
                sidebar.classList.remove('hidden');
                toggle.textContent = '‚óÄ';
                toggle.title = 'Hide architecture';
                localStorage.setItem('transformerSidebarVisible', 'true');
            } else {
                sidebar.classList.add('hidden');
                toggle.textContent = '‚ñ∂';
                toggle.title = 'Show architecture';
                localStorage.setItem('transformerSidebarVisible', 'false');
            }
        }

        function initTransformerSidebar() {
            const visible = localStorage.getItem('transformerSidebarVisible');
            if (visible === 'false') {
                toggleTransformerSidebar();
            }

            document.getElementById('transformer-toggle').addEventListener('click', toggleTransformerSidebar);
        }

        // Theme management
        function initTheme() {
            const savedTheme = localStorage.getItem('theme') || 'light';
            document.documentElement.setAttribute('data-theme', savedTheme);
            updateThemeIcon(savedTheme);
        }

        function toggleTheme() {
            const currentTheme = document.documentElement.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            document.documentElement.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
            updateThemeIcon(newTheme);
        }

        function updateThemeIcon(theme) {
            const themeToggle = document.getElementById('theme-toggle');
            themeToggle.textContent = theme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
            themeToggle.title = theme === 'dark' ? 'Switch to light mode' : 'Switch to dark mode';
        }

        // Info tooltip
        function toggleInfo() {
            const tooltip = document.getElementById('info-tooltip');
            tooltip.classList.toggle('show');
        }

        // Toggle explanation details
        function setupExplanationToggles() {
            document.querySelectorAll('.explanation-summary').forEach(summary => {
                summary.addEventListener('click', function() {
                    const explanation = this.closest('.explanation');
                    explanation.classList.toggle('expanded');
                });
            });
        }

        // Get Plotly layout with theme support
        function getPlotlyLayout(baseLayout) {
            const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
            return {
                ...baseLayout,
                paper_bgcolor: isDark ? '#2d2d2d' : '#ffffff',
                plot_bgcolor: isDark ? '#2d2d2d' : '#ffffff',
                font: {
                    color: isDark ? '#e0e0e0' : '#333'
                },
                xaxis: {
                    ...baseLayout.xaxis,
                    color: isDark ? '#e0e0e0' : '#333',
                    gridcolor: isDark ? '#444' : '#ddd'
                },
                yaxis: {
                    ...baseLayout.yaxis,
                    color: isDark ? '#e0e0e0' : '#333',
                    gridcolor: isDark ? '#444' : '#ddd'
                }
            };
        }

        // Close info tooltip when clicking outside
        document.addEventListener('click', (e) => {
            const tooltip = document.getElementById('info-tooltip');
            const infoBtn = document.getElementById('info-btn');
            if (tooltip && !tooltip.contains(e.target) && e.target !== infoBtn) {
                tooltip.classList.remove('show');
            }
        });

        // Populate trait checkboxes
        function populateTraitCheckboxes() {
            const container = document.getElementById('trait-checkboxes');
            container.innerHTML = '';

            if (!experimentData || !experimentData.traits) return;

            experimentData.traits.forEach(trait => {
                const checkbox = document.createElement('div');
                checkbox.className = 'trait-checkbox';
                checkbox.innerHTML = `
                    <input type="checkbox" id="trait-${trait.name}" value="${trait.name}" checked>
                    <label for="trait-${trait.name}">${getDisplayName(trait.name)}</label>
                `;
                container.appendChild(checkbox);

                const input = checkbox.querySelector('input');
                input.addEventListener('change', (e) => {
                    if (e.target.checked) {
                        selectedTraits.add(trait.name);
                    } else {
                        selectedTraits.delete(trait.name);
                    }
                    updateSelectedCount();
                    renderView();
                });

                selectedTraits.add(trait.name);
            });

            updateSelectedCount();
        }

        // Update selected trait count
        function updateSelectedCount() {
            document.getElementById('selected-count').textContent = selectedTraits.size;
        }

        // Select/deselect all traits
        function toggleAllTraits() {
            const checkboxes = document.querySelectorAll('#trait-checkboxes input[type="checkbox"]');
            const allSelected = selectedTraits.size === checkboxes.length;

            checkboxes.forEach(cb => {
                cb.checked = !allSelected;
                if (!allSelected) {
                    selectedTraits.add(cb.value);
                } else {
                    selectedTraits.delete(cb.value);
                }
            });

            const btn = document.getElementById('select-all-btn');
            btn.textContent = allSelected ? 'Select All' : 'Deselect All';
            updateSelectedCount();
            renderView();
        }

        // Handle navigation
        function setupNavigation() {
            const navItems = document.querySelectorAll('.nav-item');
            navItems.forEach(item => {
                item.addEventListener('click', () => {
                    navItems.forEach(n => n.classList.remove('active'));
                    item.classList.add('active');
                    currentView = item.dataset.view;
                    updatePageTitle();
                    renderView();
                });
            });
        }

        // Update page title
        function updatePageTitle() {
            const titles = {
                'data-explorer': 'Data Explorer',
                'overview': 'Overview',
                'vectors': 'Vector Analysis',
                'cross-distribution': 'Cross-Distribution Analysis',
                'monitoring': 'All Layers',
                'prompt-activation': 'Per-Token Activation',
                'layer-dive': 'Layer Deep Dive'
            };
            document.getElementById('page-title').textContent = titles[currentView] || 'Data Explorer';
        }

        // Get filtered traits
        function getFilteredTraits() {
            if (!experimentData || !experimentData.traits) return [];
            return experimentData.traits.filter(trait => selectedTraits.has(trait.name));
        }

        // Render math with MathJax
        function renderMath() {
            if (window.MathJax) {
                MathJax.typesetPromise().catch((err) => console.log('MathJax rendering error:', err));
            }
            // Setup explanation toggles after content is rendered
            setupExplanationToggles();
        }

        // Initialize
        async function init() {
            initTheme();
            initTransformerSidebar();
            setupNavigation();
            await loadExperiments();
            setupEventListeners();
        }

        // Load available experiments
        async function loadExperiments() {
            try {
                // Fetch experiments from API
                const response = await fetch('/api/experiments');
                const data = await response.json();
                experiments = data.experiments || [];

                const list = document.getElementById('experiment-list');
                list.innerHTML = experiments.map((exp, idx) => {
                    const displayName = exp.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    const isActive = idx === 0 ? 'active' : '';
                    return `
                        <div class="nav-item ${isActive}" data-experiment="${exp}">
                            <span class="icon">üî¨</span>
                            <span>${displayName}</span>
                        </div>
                    `;
                }).join('');

                // Add click handlers
                list.querySelectorAll('.nav-item').forEach(item => {
                    item.addEventListener('click', () => {
                        list.querySelectorAll('.nav-item').forEach(i => i.classList.remove('active'));
                        item.classList.add('active');
                        currentExperiment = item.dataset.experiment;
                        loadExperimentData(currentExperiment);
                    });
                });

                if (experiments.length > 0) {
                    currentExperiment = experiments[0];
                    await loadExperimentData(currentExperiment);
                }
            } catch (error) {
                console.error('Error loading experiments:', error);
                showError('Failed to load experiments');
            }
        }

        // Load experiment data
        async function loadExperimentData(experimentName) {
            const contentArea = document.getElementById('content-area');
            contentArea.innerHTML = '<div class="loading">Loading experiment data...</div>';

            try {
                experimentData = {
                    name: experimentName,
                    traits: [],
                    readme: null
                };

                // Try to load README
                try {
                    const readmeResponse = await fetch(`../experiments/${experimentName}/README.md`);
                    if (readmeResponse.ok) {
                        experimentData.readme = await readmeResponse.text();
                    }
                } catch (e) {
                    console.log('No README found');
                }

                // Fetch traits from API
                const traitsResponse = await fetch(`/api/experiments/${experimentName}/traits`);
                const traitsData = await traitsResponse.json();
                const traitNames = traitsData.traits || [];

                // Load each trait with metadata
                for (const traitName of traitNames) {
                    // Detect response file format
                    let responseFormat = null;
                    try {
                        const csvCheck = await fetch(
                            `../experiments/${experimentName}/${traitName}/extraction/responses/pos.csv`
                        );
                        if (csvCheck.ok) {
                            responseFormat = 'csv';
                        } else {
                            const jsonCheck = await fetch(
                                `../experiments/${experimentName}/${traitName}/extraction/responses/pos.json`
                            );
                            if (jsonCheck.ok) {
                                responseFormat = 'json';
                            }
                        }
                    } catch (e) {
                        console.warn(`No responses for ${traitName}`);
                        continue;
                    }

                    if (responseFormat) {
                        // Try to load metadata
                        let metadata = null;
                        try {
                            const metadataRes = await fetch(
                                `../experiments/${experimentName}/${traitName}/extraction/activations/metadata.json`
                            );
                            if (metadataRes.ok) {
                                metadata = await metadataRes.json();
                            }
                        } catch (e) {
                            console.warn(`No metadata for ${traitName}`);
                        }

                        // Detect method (natural vs instruction)
                        const method = traitName.endsWith('_natural') ? 'natural' : 'instruction';
                        const baseName = traitName.replace('_natural', '');

                        experimentData.traits.push({
                            name: traitName,
                            baseName: baseName,
                            method: method,
                            responseFormat: responseFormat,
                            hasResponses: true,
                            hasVectors: false,  // Will check later
                            metadata: metadata
                        });
                    }
                }

                // Update experiment badge
                const badge = document.getElementById('experiment-badge');
                badge.textContent = experimentName.replace(/_/g, ' ');

                console.log(`Loaded ${experimentData.traits.length} traits for ${experimentName}:`, experimentData.traits.map(t => t.name));

                // Populate trait checkboxes
                populateTraitCheckboxes();

                // Render view
                renderView();
            } catch (error) {
                console.error('Error loading experiment data:', error);
                showError(`Failed to load experiment: ${experimentName}`);
            }
        }

        // Render current view
        function renderView() {
            const contentArea = document.getElementById('content-area');

            switch (currentView) {
                case 'data-explorer':
                    renderDataExplorer();
                    break;
                case 'vectors':
                    renderVectors();
                    break;
                case 'cross-distribution':
                    renderCrossDistribution();
                    break;
                case 'monitoring':
                    renderMonitoring();
                    break;
                case 'prompt-activation':
                    renderPromptActivation();
                    break;
                case 'layer-dive':
                    renderLayerDeepDive();
                    break;
            }
        }

        // Render Data Explorer
        async function renderDataExplorer() {
            const contentArea = document.getElementById('content-area');
            const filteredTraits = getFilteredTraits();

            // Calculate totals
            const totalTraits = experimentData.traits.length;
            const selectedCount = filteredTraits.length;
            const estimatedSize = (totalTraits * 47).toFixed(0); // ~47 MB per trait

            let html = `
                <div class="explanation">
                    <div class="explanation-summary">We can inspect all the raw data files created during trait extraction‚Äîfrom the model's generated responses to the vectors extracted from them.</div>
                    <div class="explanation-details">
                    <p><strong>Responses:</strong> What the model said when showing the trait vs. not showing it</p>

                    <p><strong>Activations:</strong> Internal neuron values captured while generating those responses</p>

                    <p><strong>Vectors:</strong> Mathematical directions extracted from the activations that represent the trait</p>
                    </div>
                <div class="card">
                    <div class="stats-grid">
                        <div class="stat-card">
                            <span class="stat-label">Traits:</span>
                            <span class="stat-value">${totalTraits}</span>
                        </div>
                        <div class="stat-card">
                            <span class="stat-label">Storage:</span>
                            <span class="stat-value">~${estimatedSize}MB</span>
                        </div>
                        <div class="stat-card">
                            <span class="stat-label">Files:</span>
                            <span class="stat-value">${totalTraits * 223}</span>
                        </div>
                    </div>
                <div class="card">
                    <div class="card-title">File Explorer</div>
            `;

            // Render each trait
            filteredTraits.forEach(trait => {
                const displayName = getDisplayName(trait.name);
                const metadata = trait.metadata || {};

                html += `
                    <div class="explorer-trait-card">
                        <div class="explorer-trait-header" onclick="toggleTraitBody('${trait.name}')">
                            <strong>${displayName}</strong>
                            <span style="margin-left: 8px; font-size: 10px; color: var(--text-tertiary);">
                                ${metadata.n_examples || 0} examples | 223 files
                            </span>
                        </div>
                        <div class="explorer-trait-body" id="trait-body-${trait.name}">
                            <div class="file-tree">
                                <div class="file-item">
                                    <span class="file-icon">üìÅ</span>
                                    <strong>${trait.name}/</strong>
                                </div>

                                <div class="file-item indent-1 clickable" onclick="previewJSON('${trait.name}', 'trait_definition')">
                                    <span class="file-icon">‚úì</span>
                                    <span>trait_definition.json</span>
                                    <span style="opacity: 0.6; font-size: 11px;">(~15 KB) [preview ‚Üí]</span>
                                </div>

                                <div class="file-item indent-1">
                                    <span class="file-icon">üìÅ</span>
                                    <strong>responses/</strong>
                                </div>
                                <div class="file-item indent-2 clickable" onclick="previewCSV('${trait.name}', 'pos')">
                                    <span class="file-icon">‚úì</span>
                                    <span>pos.csv</span>
                                    <span style="opacity: 0.6; font-size: 11px;">(${metadata.n_examples_pos || '?'} rows) [preview ‚Üí]</span>
                                </div>
                                <div class="file-item indent-2 clickable" onclick="previewCSV('${trait.name}', 'neg')">
                                    <span class="file-icon">‚úì</span>
                                    <span>neg.csv</span>
                                    <span style="opacity: 0.6; font-size: 11px;">(${metadata.n_examples_neg || '?'} rows) [preview ‚Üí]</span>
                                </div>

                                <div class="file-item indent-1">
                                    <span class="file-icon">üìÅ</span>
                                    <strong>activations/</strong>
                                </div>
                                <div class="file-item indent-2 clickable" onclick="previewJSON('${trait.name}', 'activations_metadata')">
                                    <span class="file-icon">‚úì</span>
                                    <span>metadata.json</span>
                                    <span style="opacity: 0.6; font-size: 11px;">(~400 B) [preview ‚Üí]</span>
                                </div>
                                <div class="file-item indent-2">
                                    <span class="file-icon">‚úì</span>
                                    <span>all_layers.pt</span>
                                    <span style="opacity: 0.6; font-size: 11px;">(~19 MB, shape: [${metadata.n_examples}, 27, 2304])</span>
                                </div>
                                <div class="file-item indent-2">
                                    <span class="file-icon">‚úì</span>
                                    <span>pos_acts.pt</span>
                                    <span style="opacity: 0.6; font-size: 11px;">(~12 MB, shape: [${metadata.n_examples_pos}, 27, 2304])</span>
                                </div>
                                <div class="file-item indent-2">
                                    <span class="file-icon">‚úì</span>
                                    <span>neg_acts.pt</span>
                                    <span style="opacity: 0.6; font-size: 11px;">(~11 MB, shape: [${metadata.n_examples_neg}, 27, 2304])</span>
                                </div>

                                <div class="file-item indent-1">
                                    <span class="file-icon">üìÅ</span>
                                    <strong>vectors/</strong>
                                    <span style="opacity: 0.6; font-size: 11px;">(216 files: 108 tensors + 108 metadata)</span>
                                </div>
                                <div class="file-item indent-2">
                                    <span class="file-icon">üìä</span>
                                    <span>4 methods √ó 27 layers:</span>
                                </div>
                                <div class="file-item indent-3">
                                    <span class="file-icon">‚úì</span>
                                    <span>mean_diff_layer[0-26].pt + metadata</span>
                                    <span style="opacity: 0.6; font-size: 11px;">(~9 KB each)</span>
                                </div>
                                <div class="file-item indent-3">
                                    <span class="file-icon">‚úì</span>
                                    <span>probe_layer[0-26].pt + metadata</span>
                                    <span style="opacity: 0.6; font-size: 11px;">(~20 KB each)</span>
                                </div>
                                <div class="file-item indent-3">
                                    <span class="file-icon">‚úì</span>
                                    <span>ica_layer[0-26].pt + metadata</span>
                                    <span style="opacity: 0.6; font-size: 11px;">(~186 KB each)</span>
                                </div>
                                <div class="file-item indent-3">
                                    <span class="file-icon">‚úì</span>
                                    <span>gradient_layer[0-26].pt + metadata</span>
                                    <span style="opacity: 0.6; font-size: 11px;">(~9 KB each, some NaN)</span>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            });

            html += `
                    </div>
                </div>
            `;

            contentArea.innerHTML = html;
            renderMath();
        }

        // Toggle trait body visibility
        function toggleTraitBody(traitName) {
            const body = document.getElementById(`trait-body-${traitName}`);
            const header = body.previousElementSibling;

            if (body.classList.contains('show')) {
                body.classList.remove('show');
                header.classList.remove('expanded');
            } else {
                body.classList.add('show');
                header.classList.add('expanded');
            }
        }

        // Syntax highlight JSON
        function syntaxHighlightJSON(json) {
            if (typeof json !== 'string') {
                json = JSON.stringify(json, null, 2);
            }

            json = json.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

            return json.replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, function (match) {
                let cls = 'json-number';
                if (/^"/.test(match)) {
                    if (/:$/.test(match)) {
                        cls = 'json-key';
                    } else {
                        cls = 'json-string';
                    }
                } else if (/true|false/.test(match)) {
                    cls = 'json-boolean';
                } else if (/null/.test(match)) {
                    cls = 'json-null';
                }
                return '<span class="' + cls + '">' + match + '</span>';
            });
        }

        // Preview JSON file
        async function previewJSON(traitName, type) {
            const modal = document.getElementById('preview-modal');
            const title = document.getElementById('preview-title');
            const body = document.getElementById('preview-body');

            let url, displayName;
            if (type === 'trait_definition') {
                url = `../experiments/${experimentData.name}/${traitName}/extraction/trait_definition.json`;
                displayName = 'Trait Definition';
            } else if (type === 'activations_metadata') {
                url = `../experiments/${experimentData.name}/${traitName}/extraction/activations/metadata.json`;
                displayName = 'Activations Metadata';
            }

            title.textContent = `${traitName} - ${displayName}`;
            body.innerHTML = '<div class="loading">Loading...</div>';
            modal.classList.add('show');

            try {
                const response = await fetch(url);
                const data = await response.json();
                const highlighted = syntaxHighlightJSON(data);
                body.innerHTML = `<div class="json-viewer"><pre>${highlighted}</pre></div>`;
            } catch (error) {
                body.innerHTML = '<div class="error">Failed to load JSON file</div>';
            }
        }

        // Preview CSV file
        async function previewCSV(traitName, category) {
            const modal = document.getElementById('preview-modal');
            const title = document.getElementById('preview-title');
            const body = document.getElementById('preview-body');

            const url = `../experiments/${experimentData.name}/${traitName}/extraction/responses/${category}.csv`;
            const displayName = category === 'pos' ? 'Positive Examples' : 'Negative Examples';

            title.textContent = `${traitName} - ${displayName}`;
            body.innerHTML = '<div class="loading">Loading first 10 rows...</div>';
            modal.classList.add('show');

            try {
                const response = await fetch(url);
                const text = await response.text();
                const parsed = Papa.parse(text, { header: true });
                const rows = parsed.data.slice(0, 10);

                if (rows.length === 0) {
                    body.innerHTML = '<div class="error">No data found</div>';
                    return;
                }

                let tableHTML = '<table class="csv-table"><thead><tr>';
                const headers = Object.keys(rows[0]);
                headers.forEach(h => {
                    tableHTML += `<th>${h}</th>`;
                });
                tableHTML += '</tr></thead><tbody>';

                rows.forEach(row => {
                    tableHTML += '<tr>';
                    headers.forEach(h => {
                        let value = row[h] || '';
                        // Truncate long values
                        if (value.length > 100) {
                            value = value.substring(0, 100) + '...';
                        }
                        tableHTML += `<td>${value}</td>`;
                    });
                    tableHTML += '</tr>';
                });

                tableHTML += '</tbody></table>';
                tableHTML += `<div style="margin-top: 10px; color: var(--text-secondary); font-size: 12px;">Showing first 10 rows of ${parsed.data.length} total</div>`;

                body.innerHTML = tableHTML;
            } catch (error) {
                body.innerHTML = '<div class="error">Failed to load CSV file</div>';
            }
        }

        // Close preview modal
        function closePreview() {
            const modal = document.getElementById('preview-modal');
            modal.classList.remove('show');
        }

        // Close modal when clicking outside
        document.addEventListener('click', (e) => {
            const modal = document.getElementById('preview-modal');
            if (e.target === modal) {
                closePreview();
            }
        });

        // Render vector analysis view
        async function renderVectors() {
            const contentArea = document.getElementById('content-area');
            const filteredTraits = getFilteredTraits();

            if (filteredTraits.length === 0) {
                contentArea.innerHTML = `
                    <div class="card">
                        <div class="card-title">Vector Analysis</div>
                        <div class="info">No traits selected. Select traits in the sidebar to view them.</div>
                    </div>
                `;
                return;
            }

            // Show loading state
            contentArea.innerHTML = '<div class="loading">Loading vector analysis overview...</div>';

            // Filter to only traits with vector extraction (check if vectors directory exists)
            // We'll do this by attempting to fetch one probe vector and seeing if it succeeds
            const traitsWithVectors = [];
            for (const trait of filteredTraits) {
                try {
                    const testUrl = `../experiments/${experimentData.name}/${trait.name}/extraction/vectors/probe_layer16_metadata.json`;
                    const testResponse = await fetch(testUrl);
                    if (testResponse.ok) {
                        traitsWithVectors.push(trait);
                    } else {
                        console.log(`Skipping ${trait.name} - no vectors directory`);
                    }
                } catch (e) {
                    console.log(`Skipping ${trait.name} - vector fetch failed`);
                }
            }

            if (traitsWithVectors.length === 0) {
                contentArea.innerHTML = `
                    <div class="card">
                        <div class="card-title">No Vector Extractions Found</div>
                        <div class="info">
                            No traits in this experiment have completed vector extraction.
                            Only traits with <code>extraction/vectors/</code> directories are shown here.
                        </div>
                    </div>
                `;
                return;
            }

            console.log(`Found ${traitsWithVectors.length} traits with vectors (out of ${filteredTraits.length} total)`);

            // Detect number of layers from experiment metadata
            const firstTrait = traitsWithVectors[0];
            const nLayers = firstTrait.metadata?.n_layers || 26;  // Default to 26 for Gemma 2B
            console.log(`Detected ${nLayers} layers from metadata`);

            // Load all vector metadata (parallel fetching for speed)
            const vectorMetrics = {};
            const methods = ['mean_diff', 'probe', 'ica', 'gradient'];
            const layers = Array.from({ length: nLayers }, (_, i) => i);

            // Fetch all metadata AND prompt examples in parallel
            const fetchPromises = traitsWithVectors.flatMap(trait => [
                // Vector metadata
                ...methods.flatMap(method =>
                    layers.map(layer => {
                        const url = `../experiments/${experimentData.name}/${trait.name}/extraction/vectors/${method}_layer${layer}_metadata.json`;
                        return fetch(url)
                            .then(r => {
                                if (!r.ok) console.warn(`Failed to fetch: ${url}`);
                                return r.ok ? r.json() : null;
                            })
                            .then(data => ({ type: 'vector', trait: trait.name, method, layer, data }))
                            .catch(e => {
                                console.error(`Error fetching ${url}:`, e);
                                return { type: 'vector', trait: trait.name, method, layer, data: null };
                            });
                    })
                ),
                // Prompt examples (first row of pos.csv and neg.csv)
                fetch(`../experiments/${experimentData.name}/${trait.name}/extraction/responses/pos.csv`)
                    .then(r => r.ok ? r.text() : null)
                    .then(text => {
                        if (!text) return null;
                        const lines = text.split('\n');
                        if (lines.length < 2) return null;
                        const headers = lines[0].split(',');
                        const values = lines[1].split(',');
                        const row = {};
                        headers.forEach((h, i) => row[h] = values[i]);
                        return { type: 'prompt', trait: trait.name, polarity: 'pos', data: row };
                    })
                    .catch(() => ({ type: 'prompt', trait: trait.name, polarity: 'pos', data: null })),
                fetch(`../experiments/${experimentData.name}/${trait.name}/extraction/responses/neg.csv`)
                    .then(r => r.ok ? r.text() : null)
                    .then(text => {
                        if (!text) return null;
                        const lines = text.split('\n');
                        if (lines.length < 2) return null;
                        const headers = lines[0].split(',');
                        const values = lines[1].split(',');
                        const row = {};
                        headers.forEach((h, i) => row[h] = values[i]);
                        return { type: 'prompt', trait: trait.name, polarity: 'neg', data: row };
                    })
                    .catch(() => ({ type: 'prompt', trait: trait.name, polarity: 'neg', data: null }))
            ]);

            const allResults = await Promise.all(fetchPromises);
            console.log(`Loaded ${allResults.length} results`);

            // Count successful loads
            const successfulVectors = allResults.filter(r => r.type === 'vector' && r.data !== null).length;
            console.log(`Successfully loaded ${successfulVectors} vector metadata files`);

            // Organize results by trait
            for (const trait of traitsWithVectors) {
                try {
                    const vectorData = {};
                    for (const method of methods) {
                        vectorData[method] = {};
                    }

                    // Fill in vector data from parallel fetch results
                    allResults
                        .filter(r => r.type === 'vector' && r.trait === trait.name && r.data !== null)
                        .forEach(r => {
                            vectorData[r.method][r.layer] = r.data;
                        });

                    // Extract prompt examples
                    const prompts = {};
                    allResults
                        .filter(r => r.type === 'prompt' && r.trait === trait.name && r.data !== null)
                        .forEach(r => {
                            prompts[r.polarity] = r.data;
                        });

                    // Calculate best layer for each method
                    const best = {};
                    methods.forEach(method => {
                        let bestLayer = -1;
                        let bestValue = -Infinity;
                        layers.forEach(layer => {
                            if (vectorData[method][layer]) {
                                const metadata = vectorData[method][layer];
                                let value;
                                if (method === 'probe') {
                                    // Invert: smaller norm = stronger
                                    value = metadata.vector_norm ? (1.0 / metadata.vector_norm) : 0;
                                } else if (method === 'gradient') {
                                    // Use separation (unit normalized)
                                    value = metadata.final_separation || metadata.vector_norm;
                                } else {
                                    // Use magnitude
                                    value = metadata.vector_norm;
                                }
                                if (!isNaN(value) && value > bestValue) {
                                    bestValue = value;
                                    bestLayer = layer;
                                }
                            }
                        });
                        best[method] = { layer: bestLayer, norm: bestValue };
                    });

                    vectorMetrics[trait.name] = { vectorData, best, prompts };
                } catch (e) {
                    console.error(`Failed to load ${trait.name}:`, e);
                }
            }

            // Render overview with mini heatmaps
            let html = `
                <div class="explanation">
                    <div class="explanation-summary">We can approximate what a model is "thinking" for a given trait by comparing how it activates when showing that trait versus when it doesn't.</div>
                    <div class="explanation-details">
                        <h4>Layer Architecture Intuition</h4>
                        <ul>
                            <li><strong>Early layers (0-5):</strong> Syntax, local patterns, token-level features</li>
                            <li><strong>Middle layers (6-15):</strong> Semantic understanding, entity recognition, basic reasoning</li>
                            <li><strong>Late layers (16-24):</strong> Abstract concepts, complex reasoning, behavioral traits (refusal, uncertainty)</li>
                            <li><strong>Final layer (25):</strong> Projection towards output vocabulary (often degrades semantic quality)</li>
                        </ul>

                        <h4>Extraction Methods</h4>
                        <p>Four approaches to extract trait direction vectors from activations \\(\\mathbf{A}_{\\text{pos}} \\in \\mathbb{R}^{n \\times d}\\) and \\(\\mathbf{A}_{\\text{neg}} \\in \\mathbb{R}^{m \\times d}\\):</p>

                        <p><strong>1. Mean Difference</strong></p>
                        <p>$$\\mathbf{v}_{\\text{mean}} = \\frac{1}{n}\\sum_{i=1}^n \\mathbf{a}_i^{\\text{pos}} - \\frac{1}{m}\\sum_{j=1}^m \\mathbf{a}_j^{\\text{neg}}$$</p>
                        <ul>
                            <li>Simple cluster center separation</li>
                            <li>Unnormalized (typical norm ‚âà 50-100)</li>
                            <li>Fast, no training required</li>
                        </ul>

                        <p><strong>2. Probe (Linear Classifier)</strong></p>
                        <p>$$\\mathbf{v}_{\\text{probe}} = \\arg\\min_{\\mathbf{w}} \\sum_i \\log(1 + e^{-y_i \\mathbf{w}^T \\mathbf{a}_i}) + \\lambda \\|\\mathbf{w}\\|_2^2$$</p>
                        <ul>
                            <li>Logistic regression weights (L2-regularized)</li>
                            <li>Normalized during training (norm ‚âà 1-5)</li>
                            <li>Maximizes linear separability</li>
                        </ul>

                        <p><strong>3. ICA (Independent Components)</strong></p>
                        <p>$$\\mathbf{v}_{\\text{ica}} = \\text{FastICA}([\\mathbf{A}_{\\text{pos}}; \\mathbf{A}_{\\text{neg}}])[k]$$</p>
                        <ul>
                            <li>Extracts statistically independent components</li>
                            <li>Disentangles mixed trait signals via negentropy maximization</li>
                            <li>Variable norm depending on component strength</li>
                        </ul>

                        <p><strong>4. Gradient (Optimization)</strong></p>
                        <p>$$\\mathbf{v}_{\\text{grad}} = \\arg\\min_{\\mathbf{v}} \\mathcal{L}(\\mathbf{v}) \\text{ where } \\mathcal{L} = \\|\\mathbf{v}^T \\mathbf{A}_{\\text{pos}} - \\alpha\\|^2 + \\|\\mathbf{v}^T \\mathbf{A}_{\\text{neg}}\\|^2$$</p>
                        <ul>
                            <li>Custom objective via gradient descent</li>
                            <li>Unit normalized (norm = 1.0)</li>
                            <li>Can fail (NaN) if gradients vanish</li>
                        </ul>

                        <h4>Visualization Details</h4>
                        <p>Each method is normalized independently (0-100% of that method's max across layers) to show within-method layer strength. Darker = stronger for that method at that layer.</p>
                        <ul>
                            <li><strong>Probe:</strong> Inverted vector norm (smaller norm = stronger classifier due to L2 regularization)</li>
                            <li><strong>Gradient:</strong> Separation strength (vectors are unit normalized, norm = 1.0)</li>
                            <li><strong>Mean Diff & ICA:</strong> Vector magnitude (direction strength in activation space)</li>
                        </ul>

                        <p><strong>Note:</strong> All vectors extracted from token-averaged activations: \\(\\bar{\\mathbf{a}}_i = \\frac{1}{T} \\sum_{t=1}^T \\mathbf{h}_t^{(i)}\\)</p>
                    </div>
                <div class="card">
                    <div class="card-title">Vector Analysis Overview</div>
                    <div class="info">
                        Vector norms across ${nLayers} layers and 4 extraction methods. Click a row for detailed view.
                    </div>
                    <div style="margin-top: 15px;">
            `;

            traitsWithVectors.forEach(trait => {
                const displayName = getDisplayName(trait.name);
                const metrics = vectorMetrics[trait.name];
                if (!metrics) {
                    console.warn(`No metrics for ${trait.name}`);
                    return;
                }

                const best = metrics.best;

                // Check if we have any valid data
                const hasData = Object.values(best).some(b => b.layer !== -1 && b.norm !== -Infinity);
                if (!hasData) {
                    console.warn(`No valid vector data for ${trait.name}`);
                    return;
                }

                const bestMethod = Object.keys(best).reduce((a, b) =>
                    best[a].norm > best[b].norm ? a : b
                );

                // Build compact prompt examples
                let examplesHtml = '<div style="font-size: 11px; color: var(--text-secondary);">No examples</div>';
                if (metrics.prompts && metrics.prompts.pos && metrics.prompts.neg) {
                    const posInstruction = (metrics.prompts.pos.instruction || '').substring(0, 60);
                    const negInstruction = (metrics.prompts.neg.instruction || '').substring(0, 60);
                    examplesHtml = `
                        <div style="font-size: 11px; color: var(--text-secondary); line-height: 1.4;">
                            <div style="margin-bottom: 3px;"><strong style="color: var(--primary-color);">+</strong> ${posInstruction}...</div>
                            <div><strong style="color: var(--accent-color);">‚àí</strong> ${negInstruction}...</div>
                        </div>
                    `;
                }

                html += `
                    <div style="display: grid; grid-template-columns: 180px 1fr 320px; gap: 15px; padding: 12px; border-bottom: 1px solid var(--border-color); cursor: pointer; transition: background 0.2s;"
                         onclick="loadVectorAnalysis('${trait.name}')"
                         onmouseover="this.style.background='var(--bg-secondary)'"
                         onmouseout="this.style.background='transparent'">

                        <div style="display: flex; flex-direction: column; justify-content: center;">
                            <div style="font-weight: 600; color: var(--text-primary); margin-bottom: 4px;">${displayName}</div>
                            <div style="font-size: 11px; color: var(--text-secondary);">
                                Best: ${bestMethod.replace(/_/g, ' ')} L${best[bestMethod].layer}
                            </div>
                        </div>

                        <div id="mini-heatmap-${trait.name}" style="height: 100px;"></div>

                        <div style="display: flex; align-items: center;">
                            ${examplesHtml}
                        </div>
                    </div>
                `;
            });

            html += `
                    </div>
                    <div id="vector-details"></div>
                </div>
            `;

            contentArea.innerHTML = html;
            renderMath();
            renderMath();

            // Render mini heatmaps (normalized per method)
            traitsWithVectors.forEach(trait => {
                const metrics = vectorMetrics[trait.name];
                if (!metrics) {
                    console.warn(`No metrics for trait: ${trait.name}`);
                    return;
                }

                console.log(`Rendering heatmap for ${trait.name}:`, metrics);
                const methods = Object.keys(metrics.vectorData);
                if (methods.length === 0) {
                    console.warn(`No methods found for trait: ${trait.name}`);
                    return;
                }
                // Use detected number of layers
                const layers = Array.from({ length: nLayers }, (_, i) => i);

                // Normalize each method independently (0-100% of that method's max)
                // Probe: invert norm (smaller = stronger due to L2 regularization)
                // Gradient: use final_separation (unit normalized, so norm is always 1.0)
                // Mean_diff & ICA: use vector_norm
                const normalizedData = layers.map(layer => {
                    return methods.map(method => {
                        const metadata = metrics.vectorData[method][layer];
                        if (!metadata) return null;

                        if (method === 'probe') {
                            // Invert: smaller norm = stronger classifier
                            return metadata.vector_norm ? (1.0 / metadata.vector_norm) : null;
                        } else if (method === 'gradient') {
                            // Use separation (vectors are unit normalized)
                            return metadata.final_separation || metadata.vector_norm;
                        } else {
                            // Use vector magnitude
                            return metadata.vector_norm;
                        }
                    });
                });

                // Find max for each method
                const maxPerMethod = methods.map((method, methodIdx) => {
                    const values = normalizedData.map(row => row[methodIdx]).filter(v => v !== null);
                    return values.length > 0 ? Math.max(...values) : 1;
                });

                // Normalize each column by its max
                const heatmapData = normalizedData.map(row => {
                    return row.map((value, methodIdx) => {
                        if (value === null) return null;
                        return (value / maxPerMethod[methodIdx]) * 100; // Percentage of method's max
                    });
                });

                // Transpose for horizontal layout: methods become rows (y), layers become columns (x)
                const trace = {
                    z: heatmapData[0].map((_, methodIdx) =>
                        heatmapData.map(row => row[methodIdx])
                    ),
                    x: layers,
                    y: methods.map(m => m.replace(/_/g, ' ')),
                    type: 'heatmap',
                    colorscale: 'Viridis',
                    showscale: false,
                    hovertemplate: '%{y}<br>Layer %{x}<br>%{z:.1f}%<extra></extra>',
                    zmin: 0,
                    zmax: 100
                };

                Plotly.newPlot(`mini-heatmap-${trait.name}`, [trace], getPlotlyLayout({
                    margin: { l: 50, r: 5, t: 5, b: 20 },
                    xaxis: {
                        title: '',
                        showticklabels: true,
                        tickmode: 'linear',
                        dtick: 5,  // Show every 5th layer
                        tickfont: { size: 8 }
                    },
                    yaxis: { title: '', side: 'left', tickfont: { size: 8 } },
                    height: 80
                }), { displayModeBar: false });
            });
        }

        // Load vector analysis
        async function loadVectorAnalysis(traitName) {
            const detailsDiv = document.getElementById('vector-details');
            detailsDiv.innerHTML = '<div class="loading">Loading vector metadata...</div>';

            try {
                // Get trait metadata to determine number of layers
                const trait = experimentData.traits.find(t => t.name === traitName);
                const nLayers = trait?.metadata?.n_layers || 26;
                console.log(`Loading vector analysis for ${traitName} (${nLayers} layers)`);

                const methods = ['mean_diff', 'probe', 'ica', 'gradient'];
                const layers = Array.from({ length: nLayers }, (_, i) => i);

                const vectorData = {};

                for (const method of methods) {
                    vectorData[method] = {};
                    for (const layer of layers) {
                        try {
                            const response = await fetch(
                                `../experiments/${experimentData.name}/${traitName}/extraction/vectors/${method}_layer${layer}_metadata.json`
                            );
                            if (response.ok) {
                                vectorData[method][layer] = await response.json();
                            }
                        } catch (e) {
                            // Vector doesn't exist
                        }
                    }
                }

                renderVectorHeatmap(traitName, vectorData);
            } catch (error) {
                console.error('Error loading vectors:', error);
                detailsDiv.innerHTML = '<div class="error">Failed to load vector data</div>';
            }
        }

        // Render vector heatmap (normalized per method)
        function renderVectorHeatmap(traitName, vectorData) {
            const detailsDiv = document.getElementById('vector-details');
            const displayName = getDisplayName(traitName);

            const methods = Object.keys(vectorData);
            // Detect number of layers from actual data
            const nLayers = Object.keys(vectorData[methods[0]] || {}).length;
            const layers = Array.from({ length: nLayers }, (_, i) => i);

            // Collect raw metrics
            // Probe: invert norm (smaller = stronger due to L2 regularization)
            // Gradient: use final_separation (unit normalized, norm always 1.0)
            // Mean_diff & ICA: use vector_norm
            const rawData = layers.map(layer => {
                return methods.map(method => {
                    const metadata = vectorData[method][layer];
                    if (!metadata) return null;

                    if (method === 'probe') {
                        return metadata.vector_norm ? (1.0 / metadata.vector_norm) : null;
                    } else if (method === 'gradient') {
                        return metadata.final_separation || metadata.vector_norm;
                    } else {
                        return metadata.vector_norm;
                    }
                });
            });

            // Find max for each method
            const maxPerMethod = methods.map((method, methodIdx) => {
                const values = rawData.map(row => row[methodIdx]).filter(v => v !== null);
                return values.length > 0 ? Math.max(...values) : 1;
            });

            // Normalize each column by its max (0-100%)
            const normalizedData = rawData.map(row => {
                return row.map((value, methodIdx) => {
                    if (value === null) return null;
                    return (value / maxPerMethod[methodIdx]) * 100;
                });
            });

            // Also store raw values for hover
            const customData = rawData.map((row, layerIdx) => {
                return row.map((value, methodIdx) => {
                    return {
                        raw: value,
                        max: maxPerMethod[methodIdx],
                        layer: layers[layerIdx],
                        method: methods[methodIdx]
                    };
                });
            });

            const trace = {
                z: normalizedData,
                x: methods.map(m => m.replace(/_/g, ' ').toUpperCase()),
                y: layers,
                type: 'heatmap',
                colorscale: 'Viridis',
                hovertemplate: 'Method: %{x}<br>Layer %{y}<br>Strength: %{z:.1f}% of max<br>Raw norm: %{customdata.raw:.2f}<br>Max for method: %{customdata.max:.2f}<extra></extra>',
                customdata: customData,
                zmin: 0,
                zmax: 100,
                colorbar: {
                    title: '% of Max',
                    titleside: 'right'
                }
            };

            let html = `
                <div style="margin-top: 30px;">
                    <div class="card-title">${displayName} - Vector Strength by Method & Layer</div>
                    <div class="info" style="margin-top: 10px; font-size: 13px;">
                        Each method normalized independently (0-100% of that method's max across layers).
                        This shows which layers are strongest for each method, not cross-method comparisons.
                    </div>
                    <div id="vector-heatmap" style="margin-top: 20px;"></div>
                </div>
            `;

            detailsDiv.innerHTML = html;

            Plotly.newPlot('vector-heatmap', [trace], getPlotlyLayout({
                title: 'Normalized Vector Strength (% of Method Max)',
                xaxis: { title: 'Extraction Method' },
                yaxis: { title: 'Layer' },  // Layer 0 at bottom, layer N at top
                height: 600
            }), { displayModeBar: false });
        }

        // Render Cross-Distribution Analysis
        async function renderCrossDistribution() {
            const contentArea = document.getElementById('content-area');

            contentArea.innerHTML = `
                <div class="info-box">
                    <h3>Cross-Distribution Analysis</h3>
                    <p>View cross-distribution generalization testing data. This shows which traits have been tested across different data distributions (instruction-based vs natural elicitation).</p>
                </div>

                <div id="cross-dist-loading" style="padding: 20px; text-align: center;">
                    Loading cross-distribution data...
                </div>

                <div id="cross-dist-content" style="display: none;"></div>
            `;

            try {
                // Fetch cross-distribution index
                const response = await fetch('/api/cross-distribution/index');
                const data = await response.json();

                document.getElementById('cross-dist-loading').style.display = 'none';
                document.getElementById('cross-dist-content').style.display = 'block';

                const contentDiv = document.getElementById('cross-dist-content');

                if (data.error) {
                    contentDiv.innerHTML = `
                        <div class="card" style="margin: 20px 0;">
                            <div class="card-title" style="color: var(--danger);">‚ö†Ô∏è Error</div>
                            <p>${data.error}</p>
                            <p style="margin-top: 10px; color: var(--text-secondary);">
                                Run <code>python3 analysis/cross_distribution_scanner.py</code> to generate the index.
                            </p>
                        </div>
                    `;
                    return;
                }

                // Find current experiment
                const currentExp = data.experiments.find(exp => exp.experiment === currentExperiment);
                if (!currentExp) {
                    contentDiv.innerHTML = '<p>No data for current experiment.</p>';
                    return;
                }

                const stats = currentExp.statistics;
                const traits = currentExp.traits;

                // Summary statistics
                contentDiv.innerHTML = `
                    <div class="stats-grid">
                        <div class="stat-card">
                            <span class="stat-label">Traits:</span>
                            <span class="stat-value">${stats.total_traits}</span>
                        </div>
                        <div class="stat-card">
                            <span class="stat-label">Complete:</span>
                            <span class="stat-value">${stats.complete_4x4}</span>
                        </div>
                        <div class="stat-card">
                            <span class="stat-label">Partial:</span>
                            <span class="stat-value">${stats.partial}</span>
                        </div>
                    </div>

                    <div id="trait-table-container"></div>
                `;

                // Create trait table
                renderTraitTable(traits);

            } catch (error) {
                console.error('Error loading cross-distribution data:', error);
                document.getElementById('cross-dist-loading').innerHTML = `
                    <div style="color: var(--danger);">
                        Error loading data: ${error.message}
                    </div>
                `;
            }
        }

        function renderTraitTable(traits) {
            const container = document.getElementById('trait-table-container');

            // Helper function to get best score across all methods for a quadrant
            function getBestScore(trait, quadrantKey) {
                if (!trait.best_accuracies || !trait.best_accuracies[quadrantKey]) {
                    return null;
                }

                const quadScores = trait.best_accuracies[quadrantKey];
                let bestAcc = 0;
                let bestLayer = 0;
                let bestMethod = '';

                for (const [method, data] of Object.entries(quadScores)) {
                    if (data.accuracy > bestAcc) {
                        bestAcc = data.accuracy;
                        bestLayer = data.layer;
                        bestMethod = method;
                    }
                }

                return { acc: bestAcc, layer: bestLayer, method: bestMethod };
            }

            // Sort traits by completeness
            const sortedTraits = traits.sort((a, b) => {
                if (a.is_complete_4x4 && !b.is_complete_4x4) return -1;
                if (!a.is_complete_4x4 && b.is_complete_4x4) return 1;
                return b.available_quadrants - a.available_quadrants;
            });

            const tableHTML = `
                <div class="card" style="margin: 20px 0;">
                    <div class="card-title">Trait Data Availability</div>
                    <table style="width: 100%; border-collapse: collapse; margin-top: 15px; color: var(--text-secondary);">
                        <thead>
                            <tr style="border-bottom: 2px solid var(--border-color);">
                                <th style="text-align: left; padding: 12px; color: var(--text-primary);">Trait</th>
                                <th style="text-align: center; padding: 12px; color: var(--text-primary);">Separability</th>
                                <th style="text-align: center; padding: 12px; color: var(--text-primary);">Inst‚ÜíInst</th>
                                <th style="text-align: center; padding: 12px; color: var(--text-primary);">Inst‚ÜíNat</th>
                                <th style="text-align: center; padding: 12px; color: var(--text-primary);">Nat‚ÜíInst</th>
                                <th style="text-align: center; padding: 12px; color: var(--text-primary);">Nat‚ÜíNat</th>
                                <th style="text-align: center; padding: 12px; color: var(--text-primary);">Status</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${sortedTraits.map(trait => {
                                const cd = trait.cross_distribution;
                                const sepBadge = trait.separability ?
                                    `<span style="padding: 3px 8px; border-radius: 3px; font-size: 11px; background: ${
                                        trait.separability === 'high' ? 'var(--success)' :
                                        trait.separability === 'moderate' ? 'var(--info-border)' :
                                        'var(--danger)'
                                    }; color: var(--bg-primary);">${trait.separability.toUpperCase()}</span>` :
                                    '<span style="color: var(--text-tertiary);">-</span>';

                                const statusBadge = trait.is_complete_4x4 ?
                                    '<span style="padding: 3px 8px; border-radius: 3px; font-size: 11px; background: var(--success); color: var(--bg-primary);">‚úì COMPLETE</span>' :
                                    trait.available_quadrants > 0 ?
                                    `<span style="padding: 3px 8px; border-radius: 3px; font-size: 11px; background: var(--info-border); color: var(--bg-primary);">${trait.available_quadrants}/4 PARTIAL</span>` :
                                    '<span style="padding: 3px 8px; border-radius: 3px; font-size: 11px; background: var(--text-tertiary); color: var(--bg-primary);">NO DATA</span>';

                                // Get best scores for each quadrant
                                const instToInst = cd.inst_to_inst ? getBestScore(trait, 'inst_inst') : null;
                                const instToNat = cd.inst_to_nat ? getBestScore(trait, 'inst_nat') : null;
                                const natToInst = cd.nat_to_inst ? getBestScore(trait, 'nat_inst') : null;
                                const natToNat = cd.nat_to_nat ? getBestScore(trait, 'nat_nat') : null;

                                const formatScore = (score, quadrant) => {
                                    if (!score) return '<span style="color: var(--text-tertiary);">-</span>';
                                    return `<span class="quadrant-score" data-trait="${trait.name}" data-quadrant="${quadrant}" style="color: var(--text-secondary); font-size: 12px; cursor: pointer; text-decoration: underline; text-decoration-style: dotted;">${score.acc.toFixed(1)}%@L${score.layer}</span>`;
                                };

                                return `
                                    <tr style="border-bottom: 1px solid var(--border-color);">
                                        <td style="padding: 12px; font-weight: 500; color: var(--text-primary);">${trait.name}</td>
                                        <td style="padding: 12px; text-align: center;">${sepBadge}</td>
                                        <td style="padding: 12px; text-align: center;">${formatScore(instToInst, 'inst_inst')}</td>
                                        <td style="padding: 12px; text-align: center;">${formatScore(instToNat, 'inst_nat')}</td>
                                        <td style="padding: 12px; text-align: center;">${formatScore(natToInst, 'nat_inst')}</td>
                                        <td style="padding: 12px; text-align: center;">${formatScore(natToNat, 'nat_nat')}</td>
                                        <td style="padding: 12px; text-align: center;">${statusBadge}</td>
                                    </tr>
                                `;
                            }).join('')}
                        </tbody>
                    </table>
                </div>
            `;

            container.innerHTML = tableHTML;

            // Add click handlers to quadrant scores
            document.querySelectorAll('.quadrant-score').forEach(scoreSpan => {
                scoreSpan.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const traitName = scoreSpan.dataset.trait;
                    const quadrant = scoreSpan.dataset.quadrant;
                    viewQuadrantDetails(traitName, quadrant);
                });
            });
        }

        async function viewQuadrantDetails(traitName, quadrant) {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.5);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 1000;
            `;

            // Quadrant display names
            const quadrantNames = {
                'inst_inst': 'Instruction ‚Üí Instruction',
                'inst_nat': 'Instruction ‚Üí Natural',
                'nat_inst': 'Natural ‚Üí Instruction',
                'nat_nat': 'Natural ‚Üí Natural'
            };

            modal.innerHTML = `
                <div style="background: var(--bg-secondary); border-radius: 8px; padding: 30px; max-width: 1200px; max-height: 85vh; overflow-y: auto; position: relative;">
                    <button id="close-modal" style="position: absolute; top: 10px; right: 10px; background: none; border: none; font-size: 24px; cursor: pointer; color: var(--text-secondary);">√ó</button>
                    <h2 style="margin: 0 0 5px 0;">${traitName}</h2>
                    <h3 style="margin: 0 0 20px 0; font-weight: normal; color: var(--text-secondary);">${quadrantNames[quadrant]}</h3>
                    <div id="quadrant-detail-content">Loading cross-distribution data...</div>
                </div>
            `;

            document.body.appendChild(modal);

            const closeModal = () => document.body.removeChild(modal);
            modal.querySelector('#close-modal').addEventListener('click', closeModal);
            modal.addEventListener('click', (e) => {
                if (e.target === modal) closeModal();
            });

            // Load results if available
            try {
                const response = await fetch(`/api/cross-distribution/results/${traitName}`);
                const data = await response.json();

                const content = document.getElementById('quadrant-detail-content');

                if (data.error) {
                    content.innerHTML = `
                        <p style="color: var(--text-secondary);">No detailed results available for this trait yet.</p>
                        <p style="margin-top: 10px; color: var(--text-secondary); font-size: 14px;">
                            Results will be available after running cross-distribution evaluation.
                        </p>
                    `;
                    return;
                }

                // Extract quadrant data
                const quadrantData = data.quadrants[quadrant];
                if (!quadrantData) {
                    content.innerHTML = `<p style="color: var(--danger);">No data for quadrant: ${quadrant}</p>`;
                    return;
                }

                const methods = data.methods;
                const nLayers = data.n_layers;

                // Build accuracy heatmap data (4 methods √ó n_layers)
                const heatmapData = [];
                const methodLabels = [];

                for (const method of methods) {
                    if (!quadrantData.methods[method]) continue;

                    const methodData = quadrantData.methods[method];
                    const allLayers = methodData.all_layers;
                    if (!allLayers) continue;

                    const accuracies = allLayers.map(layerData => layerData.accuracy * 100); // Convert to percentage
                    heatmapData.push(accuracies);
                    methodLabels.push(method.replace(/_/g, ' '));
                }

                if (heatmapData.length === 0) {
                    content.innerHTML = `<p style="color: var(--text-secondary);">No method data available for this quadrant.</p>`;
                    return;
                }

                // Create summary stats
                const summaryHTML = `
                    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; margin-bottom: 20px;">
                        ${methods.map(method => {
                            const methodData = quadrantData.methods[method];
                            if (!methodData) return '';
                            return `
                                <div style="padding: 10px; background: var(--bg-primary); border-radius: 4px;">
                                    <div style="font-size: 11px; color: var(--text-tertiary); text-transform: uppercase;">${method.replace(/_/g, ' ')}</div>
                                    <div style="font-size: 18px; font-weight: 600; color: var(--primary-color);">${(methodData.best_accuracy * 100).toFixed(1)}%</div>
                                    <div style="font-size: 11px; color: var(--text-secondary);">Layer ${methodData.best_layer}</div>
                                    <div style="font-size: 10px; color: var(--text-tertiary); margin-top: 3px;">Avg: ${(methodData.avg_accuracy * 100).toFixed(1)}%</div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                `;

                content.innerHTML = summaryHTML + `
                    <div style="margin-top: 20px;">
                        <h4 style="margin-bottom: 10px;">Accuracy Across Layers (4 Methods √ó ${nLayers} Layers)</h4>
                        <div id="quadrant-heatmap" style="width: 100%; height: 400px;"></div>
                    </div>
                    <div style="margin-top: 20px; font-size: 12px; color: var(--text-secondary);">
                        <p><strong>Vector source:</strong> ${quadrantData.vector_source}</p>
                        <p><strong>Test distribution:</strong> ${quadrantData.test_source}</p>
                    </div>
                `;

                // Render heatmap
                const layers = Array.from({ length: nLayers }, (_, i) => i);
                const trace = {
                    z: heatmapData,
                    x: layers,
                    y: methodLabels,
                    type: 'heatmap',
                    colorscale: 'Viridis',
                    colorbar: {
                        title: 'Accuracy (%)',
                        titleside: 'right'
                    },
                    hovertemplate: '%{y}<br>Layer %{x}<br>Accuracy: %{z:.1f}%<extra></extra>',
                    zmin: 0,
                    zmax: 100
                };

                Plotly.newPlot('quadrant-heatmap', [trace], getPlotlyLayout({
                    margin: { l: 90, r: 60, t: 20, b: 40 },
                    xaxis: {
                        title: 'Layer',
                        showticklabels: true,
                        tickmode: 'linear',
                        dtick: 2
                    },
                    yaxis: {
                        title: 'Method',
                        side: 'left'
                    },
                    height: 400
                }), { displayModeBar: true });

            } catch (error) {
                const content = document.getElementById('quadrant-detail-content');
                content.innerHTML = `<p style="color: var(--danger);">Error loading results: ${error.message}</p>`;
            }
        }

        // Render monitoring view
        async function renderMonitoring() {
            const contentArea = document.getElementById('content-area');
            const filteredTraits = getFilteredTraits();

            if (filteredTraits.length === 0) {
                contentArea.innerHTML = `
                    <div class="card">
                        <div class="card-title">All Layers</div>
                        <div class="info">Select at least one trait to view trajectories</div>
                    </div>
                `;
                return;
            }

            // Load data for ALL selected traits
            contentArea.innerHTML = '<div id="all-traits-container"></div>';
            const container = document.getElementById('all-traits-container');

            for (const trait of filteredTraits) {
                const tier2Dir = `../experiments/${experimentData.name}/${trait.name}/inference/residual_stream_activations/`;

                // Create a unique div for this trait
                const traitDiv = document.createElement('div');
                traitDiv.id = `trait-${trait.name}`;
                traitDiv.style.marginBottom = '20px';
                container.appendChild(traitDiv);

                // Try to load prompt_0.json
                try {
                    const fetchPath = `${tier2Dir}prompt_0.json`;
                    console.log(`[${trait.name}] Fetching trajectory data`);
                    const response = await fetch(fetchPath);

                    if (!response.ok) {
                        console.log(`[${trait.name}] No data available (${response.status})`);
                        renderTier2InstructionsInContainer(traitDiv.id, trait);
                        continue;
                    }

                    const data = await response.json();
                    console.log(`[${trait.name}] Data loaded successfully`);
                    renderTier2DataInContainer(traitDiv.id, trait, data);
                } catch (error) {
                    console.log(`[${trait.name}] Load failed:`, error.message);
                    renderTier2InstructionsInContainer(traitDiv.id, trait);
                }
            }
        }

        function renderTier2InstructionsInContainer(containerId, trait) {
            const container = document.getElementById(containerId);
            if (!container) {
                console.error(`Container ${containerId} not found`);
                return;
            }

            // Get layer count from metadata
            const nLayers = trait.metadata?.n_layers || 26;
            const nCheckpoints = nLayers * 3;

            container.innerHTML = `
                <div class="card" style="margin-bottom: 10px;">
                    <div class="card-title">${getDisplayName(trait.name)}</div>

                    <div class="info" style="margin-bottom: 10px; font-size: 12px;">
                        ‚ö†Ô∏è No trajectory data available
                    </div>

                    <div style="background: var(--bg-tertiary); padding: 10px; border-radius: 6px; font-size: 12px;">
                        <p style="color: var(--text-secondary); margin-bottom: 8px;">
                            Capture per-token projections at all ${nCheckpoints} checkpoints (${nLayers} layers √ó 3 sublayers):
                        </p>
                        <pre style="background: var(--bg-primary); color: var(--text-primary); padding: 8px; border-radius: 4px; margin: 8px 0; overflow-x: auto; border: 1px solid var(--border-color); font-size: 11px;">python inference/capture_tier2.py --experiment ${experimentData.name} --trait ${trait.name} --prompts "..." --save-json</pre>
                    </div>
                </div>
            `;
        }

        function renderTier2DataInContainer(containerId, trait, data) {
            const container = document.getElementById(containerId);
            if (!container) {
                console.error(`Container ${containerId} not found`);
                return;
            }

            try {
                const promptProj = data.projections.prompt;  // [n_tokens, n_layers, 3]
                const responseProj = data.projections.response;
                console.log('Prompt projections shape:', promptProj.length, 'tokens x', promptProj[0].length, 'layers x', promptProj[0][0].length, 'sublayers');
                console.log('Response projections shape:', responseProj.length, 'tokens x', responseProj[0].length, 'layers x', responseProj[0][0].length, 'sublayers');

            // Combine prompt and response projections and tokens
            const allTokens = [...data.prompt.tokens, ...data.response.tokens];
            const allProj = [...promptProj, ...responseProj];
            const nPromptTokens = data.prompt.n_tokens;
            const nTotalTokens = allTokens.length;
            const nLayers = promptProj[0].length;  // Detect from data
            const nCheckpoints = nLayers * 3;

            // Create unique IDs for this trait's elements
            const traitId = trait.name;
            const trajectoryId = `trajectory-heatmap-${traitId}`;
            const sliderId = `unified-slider-${traitId}`;
            const sliderValueId = `unified-slider-value-${traitId}`;
            const sliderTokenId = `unified-slider-token-${traitId}`;
            const sliderPhaseId = `unified-slider-phase-${traitId}`;
            const logitContainerId = `logit-lens-container-${traitId}`;
            const logitTokenNumId = `logit-token-num-${traitId}`;
            const logitTokenTextId = `logit-token-text-${traitId}`;
            const logitPlotId = `logit-lens-plot-${traitId}`;
            const attentionViewerId = `attention-viewer-${traitId}`;

            container.innerHTML = `
                <div class="card" style="margin-bottom: 10px;">
                    <div class="card-title" style="margin-bottom: 5px;">${getDisplayName(trait.name)}</div>

                    <!-- Conversation context - compact -->
                    <div style="background: var(--bg-tertiary); padding: 5px 8px; border-radius: 4px; margin-bottom: 8px;">
                        <div style="color: var(--text-primary); font-size: 12px; margin-bottom: 2px;">${data.prompt.text} ${data.response.text}</div>
                        <div style="color: var(--text-secondary); font-size: 10px;">
                            ${data.prompt.n_tokens} prompt + ${data.response.n_tokens} response = ${nTotalTokens} tokens
                        </div>
                    </div>

                    <div id="${trajectoryId}" style="margin-bottom: 10px;"></div>
                </div>
            `;

            // Render combined trajectory heatmap with separator line
            try {
                renderCombinedTrajectoryHeatmap(trajectoryId, allProj, allTokens, nPromptTokens, 250);  // Reduced height
            } catch (plotError) {
                console.error(`[${trait.name}] Heatmap rendering failed:`, plotError);
                container.innerHTML += `<div class="info" style="color: var(--danger);">Failed to render heatmap: ${plotError.message}</div>`;
            }

            // Setup math rendering and toggle listeners
            renderMath();
            } catch (error) {
                console.error(`[${trait.name}] Error rendering trajectory data:`, error);
                if (container) {
                    container.innerHTML = `<div class="card"><div class="card-title">Error: ${getDisplayName(trait.name)}</div><div class="info">Failed to render trajectory data: ${error.message}</div></div>`;
                }
            }
        }

        function renderCombinedTrajectoryHeatmap(divId, projections, tokens, nPromptTokens, height = 400) {
            // projections: [n_tokens, n_layers, 3_sublayers]
            // We'll show layer-averaged (average over 3 sublayers)

            const nTokens = projections.length;
            const nLayers = projections[0].length;  // Dynamically get number of layers
            console.log(`Rendering combined trajectory heatmap for ${nTokens} tokens x ${nLayers} layers (${nPromptTokens} prompt + ${nTokens - nPromptTokens} response)`);

            // Average over sublayers to get [n_tokens, n_layers]
            // Skip BOS token (index 0) for better visualization dynamic range
            const startIdx = 1;  // Skip <bos>

            const layerAvg = [];
            for (let t = startIdx; t < nTokens; t++) {
                layerAvg[t - startIdx] = [];
                for (let l = 0; l < nLayers; l++) {
                    const avg = (projections[t][l][0] + projections[t][l][1] + projections[t][l][2]) / 3;
                    layerAvg[t - startIdx][l] = avg;
                }
            }

            // Transpose for heatmap: [n_layers, n_tokens-1] (excluding BOS)
            const heatmapData = [];
            const nDisplayTokens = nTokens - startIdx;
            for (let l = 0; l < nLayers; l++) {
                heatmapData[l] = [];
                for (let t = 0; t < nDisplayTokens; t++) {
                    heatmapData[l][t] = layerAvg[t][l];
                }
            }

            // Create shapes array for separator line and current token highlight
            const shapes = [
                // Vertical line separating prompt and response (adjusted for skipped BOS)
                {
                    type: 'line',
                    xref: 'x',
                    yref: 'paper',
                    x0: (nPromptTokens - startIdx) - 0.5,
                    x1: (nPromptTokens - startIdx) - 0.5,
                    y0: 0,
                    y1: 1,
                    line: {
                        color: 'rgba(255, 255, 255, 0.5)',
                        width: 2,
                        dash: 'dash'
                    }
                },
                // Highlight for current token (will be updated by slider)
                {
                    type: 'rect',
                    xref: 'x',
                    yref: 'paper',
                    x0: -0.5,
                    x1: 0.5,
                    y0: 0,
                    y1: 1,
                    fillcolor: 'rgba(74, 158, 255, 0.2)',
                    line: { width: 0 },
                    name: 'token-highlight'  // ID for updating
                }
            ];

            const data = [{
                z: heatmapData,
                x: tokens.slice(startIdx),  // Skip BOS in token labels too
                y: Array.from({length: nLayers}, (_, i) => `L${i}`),
                type: 'heatmap',
                colorscale: 'RdBu',
                zmid: 0,
                hovertemplate: 'Token: %{x}<br>Layer: %{y}<br>Score: %{z:.2f}<extra></extra>'
            }];

            // Adjust margins based on height
            const isCompact = height < 300;
            const layout = getPlotlyLayout({
                title: isCompact ? '' : 'Trait Trajectory',
                xaxis: {
                    title: isCompact ? '' : 'Tokens',
                    tickangle: -45,
                    tickfont: { size: isCompact ? 9 : 12 }
                },
                yaxis: {
                    title: isCompact ? '' : 'Layer',
                    tickfont: { size: isCompact ? 9 : 12 }
                },
                shapes: shapes,
                height: height,
                margin: isCompact ? { t: 5, b: 30, l: 30, r: 5 } : { t: 10, b: 50, l: 40, r: 10 }
            });

            Plotly.newPlot(divId, data, layout, {displayModeBar: false});
        }

        function renderAttentionViewer(divId, data, allTokens, nPromptTokens) {
            // Get number of layers
            const nLayers = Object.keys(data.attention_weights.prompt).length;

            const html = `
                <div style="border-top: 1px solid var(--border-color); padding-top: 15px; margin-top: 20px;">
                    <h3 style="color: var(--text-primary); margin-bottom: 5px; font-size: 14px;">Attention Patterns</h3>
                    <p style="color: var(--text-secondary); margin-bottom: 10px; font-size: 11px;">
                        Selected token's attention to context (controlled by slider above)
                    </p>
                    <div id="attention-heatmap"></div>
                </div>
            `;

            document.getElementById(divId).innerHTML = html;

            // Function to render attention heatmap for a specific token
            window.updateAttentionHeatmap = function(tokenIdx) {
                // Get attention data for this token
                let attnData;  // [n_layers, n_context]
                let contextTokens;

                if (tokenIdx < nPromptTokens) {
                    // Prompt token - extract from full attention matrix
                    // Data structure: prompt[layer_X] is [n_tokens, n_tokens] matrix
                    attnData = [];
                    for (let layer = 0; layer < nLayers; layer++) {
                        const layerAttnMatrix = data.attention_weights.prompt[`layer_${layer}`];

                        if (!layerAttnMatrix || !layerAttnMatrix[tokenIdx]) {
                            console.warn(`Missing attention data for prompt token ${tokenIdx}, layer ${layer}`);
                            attnData.push(new Array(tokenIdx + 1).fill(0));
                            continue;
                        }

                        // Extract this token's attention row, only up to current position (causal)
                        const tokenAttn = layerAttnMatrix[tokenIdx].slice(0, tokenIdx + 1);
                        attnData.push(tokenAttn);
                    }
                    contextTokens = data.prompt.tokens.slice(0, tokenIdx + 1);
                } else {
                    // Response token - already stored as single attention vector
                    // Data structure: response[token_idx][layer_X] is [context_length] vector
                    const responseIdx = tokenIdx - nPromptTokens;
                    attnData = [];
                    for (let layer = 0; layer < nLayers; layer++) {
                        const stepAttn = data.attention_weights.response[responseIdx];

                        if (!stepAttn || !stepAttn[`layer_${layer}`]) {
                            console.warn(`Missing attention data for response token ${responseIdx}, layer ${layer}`);
                            attnData.push(new Array(tokenIdx + 1).fill(0));
                            continue;
                        }

                        const layerAttn = stepAttn[`layer_${layer}`];
                        attnData.push(layerAttn);
                    }
                    contextTokens = allTokens.slice(0, tokenIdx + 1);
                }

                // Validate data dimensions
                const expectedContextLen = tokenIdx + 1;
                let hasValidData = true;
                for (let i = 0; i < attnData.length; i++) {
                    if (!attnData[i] || attnData[i].length !== expectedContextLen) {
                        console.warn(`Layer ${i} attention length mismatch: expected ${expectedContextLen}, got ${attnData[i]?.length || 0}`);
                        hasValidData = false;
                    }
                }

                if (!hasValidData) {
                    console.error('Attention data validation failed, displaying with available data');
                }

                // Create heatmap
                const trace = {
                    z: attnData,
                    x: contextTokens,
                    y: Array.from({length: nLayers}, (_, i) => `L${i}`),
                    type: 'heatmap',
                    colorscale: 'Viridis',
                    hovertemplate: 'Context Token: %{x}<br>Layer: %{y}<br>Attention: %{z:.4f}<extra></extra>',
                    colorbar: {
                        title: 'Attention Weight'
                    }
                };

                const layout = getPlotlyLayout({
                    title: `"${allTokens[tokenIdx]}" (pos ${tokenIdx})`,
                    xaxis: {
                        title: 'Context',
                        tickangle: -45,
                        side: 'bottom'
                    },
                    yaxis: {
                        title: 'Layer'
                    },
                    height: 300,
                    margin: { t: 10, b: 50, l: 40, r: 10 }
                });

                Plotly.newPlot('attention-heatmap', [trace], layout, { displayModeBar: false });
            }

            // Initialize with first token
            window.updateAttentionHeatmap(0);
        }

        function renderLogitLens(data, tokenIdx, allTokens, nPromptTokens) {
            const container = document.getElementById('logit-lens-container');

            // Check if logit lens data is available
            if (!data.logit_lens || !data.logit_lens.response) {
                container.style.display = 'none';
                return;
            }

            container.style.display = 'block';

            // Determine if this is a prompt or response token
            const isPromptToken = tokenIdx < nPromptTokens;
            const logitData = isPromptToken ? data.logit_lens.prompt : data.logit_lens.response;
            const actualIdx = isPromptToken ? tokenIdx : (tokenIdx - nPromptTokens);

            // Update token info
            const tokenText = allTokens[tokenIdx];
            document.getElementById('logit-token-num').textContent = tokenIdx + 1;
            document.getElementById('logit-token-text').textContent = tokenText;

            // Layer indices from LOGIT_LENS_LAYERS config: [0,1,2,3,6,9,12,15,18,21,24,25]
            const layerKeys = Object.keys(logitData).sort((a, b) => {
                const aNum = parseInt(a.replace('layer_', ''));
                const bNum = parseInt(b.replace('layer_', ''));
                return aNum - bNum;
            });

            const layerIndices = layerKeys.map(k => parseInt(k.replace('layer_', '')));

            // Build traces for top-3 predictions
            const traces = [];
            const colors = ['#4a9eff', '#ff6b6b', '#51cf66'];  // Blue, Red, Green

            for (let k = 0; k < 3; k++) {
                const probs = [];
                const tokens = [];

                for (const layerKey of layerKeys) {
                    const layerData = logitData[layerKey];

                    if (layerData && layerData.tokens[actualIdx]) {
                        probs.push(layerData.probs[actualIdx][k]);
                        if (tokens.length === 0) {
                            tokens.push(layerData.tokens[actualIdx][k]);
                        }
                    } else {
                        // Data not available for this layer/token
                        probs.push(null);
                    }
                }

                traces.push({
                    x: layerIndices,
                    y: probs,
                    name: `"${tokens[0] || '?'}"`,
                    mode: 'lines+markers',
                    line: { width: 3, color: colors[k] },
                    marker: { size: 8, color: colors[k] },
                    connectgaps: false
                });
            }

            // Layout
            const layout = {
                xaxis: {
                    title: 'Layer',
                    tickvals: layerIndices,
                    gridcolor: 'rgba(128, 128, 128, 0.2)',
                    zeroline: false
                },
                yaxis: {
                    title: 'Prob',
                    range: [0, 1],
                    gridcolor: 'rgba(128, 128, 128, 0.2)',
                    zeroline: false
                },
                height: 200,
                margin: { t: 10, b: 40, l: 40, r: 10 },
                paper_bgcolor: 'transparent',
                plot_bgcolor: 'transparent',
                font: {
                    color: getComputedStyle(document.documentElement).getPropertyValue('--text-primary').trim(),
                    size: 10
                },
                showlegend: true,
                legend: {
                    orientation: 'h',
                    yanchor: 'bottom',
                    y: -0.35,
                    xanchor: 'center',
                    x: 0.5,
                    font: { size: 10 }
                }
            };

            Plotly.newPlot('logit-lens-plot', traces, layout, { responsive: true, displayModeBar: false });
        }

        function setupUnifiedSlider(data, allTokens, nPromptTokens, nTotalTokens) {
            const slider = document.getElementById('unified-slider');

            // Function to update all visualizations when slider moves
            function updateAllVisualizations(tokenIdx) {
                // Update slider labels
                document.getElementById('unified-slider-value').textContent = tokenIdx;
                document.getElementById('unified-slider-token').textContent = allTokens[tokenIdx];

                // Update phase indicator (Prompt vs Response)
                const phase = tokenIdx < nPromptTokens ? '[Prompt]' : '[Response]';
                document.getElementById('unified-slider-phase').textContent = phase;

                // Heatmap position (adjusted for skipped BOS token)
                const startIdx = 1;  // BOS is skipped in heatmap
                const heatmapIdx = tokenIdx - startIdx;

                // Update trajectory heatmap highlight
                const shapes = [
                    // Separator line (adjusted for skipped BOS)
                    {
                        type: 'line',
                        xref: 'x',
                        yref: 'paper',
                        x0: (nPromptTokens - startIdx) - 0.5,
                        x1: (nPromptTokens - startIdx) - 0.5,
                        y0: 0,
                        y1: 1,
                        line: {
                            color: 'rgba(255, 255, 255, 0.5)',
                            width: 2,
                            dash: 'dash'
                        }
                    },
                    // Current token highlight (adjusted position for skipped BOS)
                    {
                        type: 'rect',
                        xref: 'x',
                        yref: 'paper',
                        x0: heatmapIdx - 0.5,
                        x1: heatmapIdx + 0.5,
                        y0: 0,
                        y1: 1,
                        fillcolor: 'rgba(74, 158, 255, 0.2)',
                        line: { width: 0 }
                    }
                ];

                Plotly.relayout('trajectory-heatmap', { shapes: shapes });

                // Update logit lens if available
                renderLogitLens(data, tokenIdx, allTokens, nPromptTokens);

                // Update attention heatmap if available
                if (window.updateAttentionHeatmap) {
                    window.updateAttentionHeatmap(tokenIdx);
                }
            }

            // Add slider event listener
            slider.addEventListener('input', (e) => {
                updateAllVisualizations(parseInt(e.target.value));
            });

            // Initialize at position 1 (skip BOS)
            updateAllVisualizations(1);
        }

        // Render Prompt Activation view
        async function renderPromptActivation() {
            const contentArea = document.getElementById('content-area');
            const filteredTraits = getFilteredTraits();

            if (filteredTraits.length === 0) {
                contentArea.innerHTML = `
                    <div class="card">
                        <div class="card-title">Per-Token Activation</div>
                        <div class="info">Select at least one trait to view per-token activation trajectories</div>
                    </div>
                `;
                return;
            }

            // Load data for ALL selected traits
            contentArea.innerHTML = '<div id="all-prompt-traits-container"></div>';
            const container = document.getElementById('all-prompt-traits-container');

            for (const trait of filteredTraits) {
                const tier2Dir = `../experiments/${experimentData.name}/${trait.name}/inference/residual_stream_activations/`;

                // Create a unique div for this trait
                const traitDiv = document.createElement('div');
                traitDiv.id = `prompt-trait-${trait.name}`;
                traitDiv.style.marginBottom = '20px';
                container.appendChild(traitDiv);

                // Try to load prompt_0.json
                try {
                    const fetchPath = `${tier2Dir}prompt_0.json`;
                    console.log(`[${trait.name}] Fetching prompt activation data`);
                    const response = await fetch(fetchPath);

                    if (!response.ok) {
                        console.log(`[${trait.name}] No data available (${response.status})`);
                        renderPromptActivationInstructions(traitDiv.id, trait);
                        continue;
                    }

                    const data = await response.json();
                    console.log(`[${trait.name}] Data loaded successfully`);
                    renderPromptActivationData(traitDiv.id, trait, data);
                } catch (error) {
                    console.log(`[${trait.name}] Load failed:`, error.message);
                    renderPromptActivationInstructions(traitDiv.id, trait);
                }
            }
        }

        function renderPromptActivationInstructions(containerId, trait) {
            const container = document.getElementById(containerId);
            const nLayers = trait.metadata?.n_layers || 26;

            container.innerHTML = `
                <div class="card" style="margin-bottom: 10px;">
                    <div class="card-title">${getDisplayName(trait.name)}</div>

                    <div class="info" style="margin-bottom: 10px; font-size: 12px;">
                        ‚ö†Ô∏è No per-token activation data available
                    </div>

                    <div style="background: var(--bg-tertiary); padding: 10px; border-radius: 6px; font-size: 12px;">
                        <p style="color: var(--text-secondary); margin-bottom: 8px;">
                            Capture per-token activation trajectory (prompt + response):
                        </p>
                        <pre style="background: var(--bg-primary); color: var(--text-primary); padding: 8px; border-radius: 4px; margin: 8px 0; overflow-x: auto; border: 1px solid var(--border-color); font-size: 11px;">python inference/capture_tier2.py --experiment ${experimentData.name} --trait ${trait.name} --prompts "..." --save-json</pre>
                    </div>
                </div>
            `;
        }

        function renderPromptActivationData(containerId, trait, data) {
            const container = document.getElementById(containerId);

            try {
                const promptProj = data.projections.prompt;  // [n_tokens, n_layers, 3]
                const responseProj = data.projections.response;  // [n_tokens, n_layers, 3]

                // Combine prompt and response
                const allTokens = [...data.prompt.tokens, ...data.response.tokens];
                const allProj = [...promptProj, ...responseProj];
                const nPromptTokens = data.prompt.n_tokens;
                const nTotalTokens = allTokens.length;
                const nLayers = promptProj[0].length;

                console.log(`Combined tokens: ${nTotalTokens} (${nPromptTokens} prompt + ${nTotalTokens - nPromptTokens} response), Layers: ${nLayers}`);

                // Create unique IDs for this trait's elements
                const traitId = trait.name;
                const plotId = `prompt-activation-plot-${traitId}`;

                container.innerHTML = `
                    <div class="card" style="margin-bottom: 10px;">
                        <div class="card-title" style="margin-bottom: 5px;">${getDisplayName(trait.name)} - Per-Token Activation</div>

                        <!-- Conversation context -->
                        <div style="background: var(--bg-tertiary); padding: 5px 8px; border-radius: 4px; margin-bottom: 8px;">
                            <div style="color: var(--text-primary); font-size: 12px; margin-bottom: 2px;">${data.prompt.text} ${data.response.text}</div>
                            <div style="color: var(--text-secondary); font-size: 10px;">
                                ${nPromptTokens} prompt + ${nTotalTokens - nPromptTokens} response = ${nTotalTokens} tokens
                            </div>
                        </div>

                        <div id="${plotId}" style="margin-bottom: 10px;"></div>
                    </div>
                `;

                // Render the combined activation plot
                renderPromptActivationPlot(plotId, allProj, allTokens, nLayers, nPromptTokens);

            } catch (error) {
                console.error('Error rendering prompt activation data:', error);
                container.innerHTML = `<div class="card"><div class="card-title">Error</div><div class="info">Failed to render prompt activation data: ${error.message}</div></div>`;
            }
        }

        function renderPromptActivationPlot(divId, projections, tokens, nLayers, nPromptTokens) {
            // projections: [n_tokens, n_layers, 3_sublayers]
            // We want: x-axis = token position, y-axis = activation strength
            // We'll average across all layers and sublayers for each token

            const nTokens = projections.length;
            console.log(`Rendering combined activation plot for ${nTokens} tokens (${nPromptTokens} prompt + ${nTokens - nPromptTokens} response) x ${nLayers} layers`);

            // Skip BOS token (index 0) for better visualization
            const startIdx = 1;

            // Calculate activation strength for each token (average across all layers and sublayers)
            const activations = [];
            const displayTokens = [];

            for (let t = startIdx; t < nTokens; t++) {
                let sum = 0;
                let count = 0;
                for (let l = 0; l < nLayers; l++) {
                    for (let s = 0; s < 3; s++) {
                        sum += projections[t][l][s];
                        count++;
                    }
                }
                activations.push(sum / count);
                displayTokens.push(tokens[t]);
            }

            // Create the line plot
            const trace = {
                x: Array.from({length: activations.length}, (_, i) => i),
                y: activations,
                type: 'scatter',
                mode: 'lines+markers',
                line: {
                    color: '#4a9eff',
                    width: 2
                },
                marker: {
                    size: 6,
                    color: '#4a9eff'
                },
                text: displayTokens,
                hovertemplate: 'Token %{x}: %{text}<br>Activation: %{y:.2f}<extra></extra>'
            };

            // Add subtle vertical line separator between prompt and response
            const shapes = [
                {
                    type: 'line',
                    x0: (nPromptTokens - startIdx) - 0.5,
                    x1: (nPromptTokens - startIdx) - 0.5,
                    y0: 0,
                    y1: 1,
                    yref: 'paper',
                    line: {
                        color: 'rgba(128, 128, 128, 0.15)',
                        width: 1,
                        dash: 'dot'
                    }
                }
            ];

            // Add annotations for prompt/response regions
            const annotations = [
                {
                    x: (nPromptTokens - startIdx) / 2 - 0.5,
                    y: 1.05,
                    yref: 'paper',
                    text: 'Prompt',
                    showarrow: false,
                    font: {
                        size: 10,
                        color: 'rgba(128, 128, 128, 0.7)'
                    }
                },
                {
                    x: (nPromptTokens - startIdx) + (activations.length - (nPromptTokens - startIdx)) / 2 - 0.5,
                    y: 1.05,
                    yref: 'paper',
                    text: 'Response',
                    showarrow: false,
                    font: {
                        size: 10,
                        color: 'rgba(128, 128, 128, 0.7)'
                    }
                }
            ];

            const layout = {
                xaxis: {
                    title: 'Token Position',
                    tickmode: 'array',
                    tickvals: Array.from({length: activations.length}, (_, i) => i),
                    ticktext: displayTokens,
                    tickangle: -45,
                    showgrid: false
                },
                yaxis: {
                    title: 'Average Activation (all layers)',
                    zeroline: true,
                    zerolinecolor: 'rgba(128, 128, 128, 0.3)',
                    zerolinewidth: 1,
                    showgrid: false
                },
                shapes: shapes,
                annotations: annotations,
                margin: { l: 60, r: 20, t: 40, b: 100 },
                height: 400,
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)',
                font: {
                    size: 11,
                    color: getComputedStyle(document.documentElement).getPropertyValue('--text-primary')
                },
                hovermode: 'closest'
            };

            const config = {
                responsive: true,
                displayModeBar: true,
                displaylogo: false,
                modeBarButtonsToRemove: ['lasso2d', 'select2d']
            };

            Plotly.newPlot(divId, [trace], layout, config);
        }

        // Render Layer Deep Dive view
        async function renderLayerDeepDive() {
            const contentArea = document.getElementById('content-area');
            const filteredTraits = getFilteredTraits();

            if (filteredTraits.length === 0) {
                contentArea.innerHTML = `
                    <div class="card">
                        <div class="card-title">Layer Deep Dive</div>
                        <div class="info">Select at least one trait to view layer internals</div>
                    </div>
                `;
                return;
            }

            // Try to find Tier 3 data for the first selected trait
            const trait = filteredTraits[0];
            const tier3Dir = `../experiments/${experimentData.name}/${trait.name}/inference/layer_internal_states/`;

            // Try to load prompt_0_layer16.json (default layer)
            try {
                const response = await fetch(`${tier3Dir}prompt_0_layer16.json`);
                if (!response.ok) throw new Error('No data found');

                const data = await response.json();
                renderTier3Data(trait, data);
            } catch (error) {
                // No data yet - show instructions
                renderTier3Instructions(trait);
            }
        }

        function renderTier3Instructions(trait) {
            const contentArea = document.getElementById('content-area');
            contentArea.innerHTML = `
                <div class="explanation">
                    <div class="explanation-summary">We can pinpoint exactly which neurons and attention mechanisms are responsible for computing a trait at a specific layer.</div>
                    <div class="explanation-details">

                    <h4>Captured Components</h4>

                    <p><strong>Attention Projections (before multihead split):</strong></p>
                    <p>$$\\mathbf{Q} = \\mathbf{h}\\mathbf{W}_Q, \\quad \\mathbf{K} = \\mathbf{h}\\mathbf{W}_K, \\quad \\mathbf{V} = \\mathbf{h}\\mathbf{W}_V$$</p>
                    <p>Query, Key, Value projections \\(\\in \\mathbb{R}^{T \\times d}\\)</p>

                    <p><strong>Attention Heads (post-split):</strong></p>
                    <p>$$\\text{head}_i = \\text{Attention}(\\mathbf{Q}_i, \\mathbf{K}_i, \\mathbf{V}_i) = \\text{softmax}\\left(\\frac{\\mathbf{Q}_i \\mathbf{K}_i^T}{\\sqrt{d_k}}\\right)\\mathbf{V}_i$$</p>
                    <p>Per-head outputs showing which heads activate for the trait</p>

                    <p><strong>MLP Internals:</strong></p>
                    <p>$$\\mathbf{h}_{\\text{mlp}} = \\mathbf{W}_2 \\cdot \\text{GELU}(\\mathbf{W}_1 \\mathbf{h})$$</p>
                    <ul>
                        <li>Pre-GELU: \\(\\mathbf{W}_1 \\mathbf{h} \\in \\mathbb{R}^{9216}\\) (2304 hidden √ó 4 expansion)</li>
                        <li>Post-GELU: Shows which of 9216 neurons fire for trait</li>
                    </ul>

                    <h4>Use Case</h4>
                    <p>Identifies specific neurons/heads responsible for trait computation, enabling:</p>
                    <ul>
                        <li>Neuron-level interpretation</li>
                        <li>Surgical intervention (ablation studies)</li>
                        <li>Feature visualization</li>
                    </ul>
                </div>
                <div class="card">
                    <div class="card-title">Layer Deep Dive: ${getDisplayName(trait.name)}</div>

                    <div class="info" style="margin-bottom: 20px;">
                        <strong>‚ö†Ô∏è No layer internals data available for ${trait.name}</strong>
                    </div>

                    <div style="background: var(--bg-tertiary); padding: 20px; border-radius: 8px;">
                        <h3 style="color: var(--text-primary); margin-bottom: 15px;">Capture Layer Internals</h3>
                        <p style="color: var(--text-secondary); margin-bottom: 15px;">
                            Capture complete internals (Q/K/V, attention heads, 9216 MLP neurons) for one layer:
                        </p>
                        <pre style="background: var(--bg-primary); color: var(--text-primary); padding: 15px; border-radius: 4px; margin: 15px 0; overflow-x: auto; border: 1px solid var(--border-color);">python inference/capture_tier3.py \\
  --experiment ${experimentData.name} \\
  --trait ${trait.name} \\
  --layer 16 \\
  --prompts "What is the capital of France?" \\
  --save-json</pre>
                        <p style="color: var(--text-secondary); margin-top: 15px;">
                            The <code style="background: var(--bg-primary); padding: 2px 6px; border-radius: 3px;">--save-json</code> flag creates visualization-friendly JSON files (~10-20 MB).
                        </p>
                        <p style="color: var(--text-tertiary); font-size: 13px; margin-top: 10px;">
                            This reveals which specific neurons and attention heads are responsible for ${getDisplayName(trait.name)}.
                        </p>
                    </div>
                </div>
            `;
        }

        function renderTier3Data(trait, data) {
            const contentArea = document.getElementById('content-area');

            // Get prompt GELU activations: [n_tokens, 9216]
            const promptGelu = data.internals.prompt.gelu;
            const promptTokens = data.prompt.tokens;

            contentArea.innerHTML = `
                <div class="explanation">
                    <div class="explanation-summary">We can pinpoint exactly which neurons and attention mechanisms are responsible for computing a trait at layer ${data.layer}.</div>
                    <div class="explanation-details">

                    <h4>Components Analyzed</h4>

                    <p><strong>Attention Projections:</strong></p>
                    <p>$$\\mathbf{Q}, \\mathbf{K}, \\mathbf{V} = \\mathbf{h} \\mathbf{W}_Q, \\mathbf{h} \\mathbf{W}_K, \\mathbf{h} \\mathbf{W}_V \\in \\mathbb{R}^{T \\times d}$$</p>

                    <p><strong>Attention Heads:</strong></p>
                    <p>$$\\text{head}_i = \\text{softmax}\\left(\\frac{\\mathbf{Q}_i \\mathbf{K}_i^T}{\\sqrt{d_k}}\\right)\\mathbf{V}_i$$</p>

                    <p><strong>MLP Neurons (9216 total):</strong></p>
                    <p>$$\\mathbf{z} = \\text{GELU}(\\mathbf{W}_1 \\mathbf{h}) \\in \\mathbb{R}^{9216}$$</p>
                    <p>Top 20 neurons ranked by \\(\\frac{1}{T}\\sum_t |z_t^{(i)}|\\) (average absolute activation)</p>

                    <h4>Interpretation</h4>
                    <p>Neurons with high activation magnitude are most responsible for this layer's contribution to the trait.</p>
                    </div>
                <div class="card">
                    <div class="card-title">Layer Deep Dive: ${getDisplayName(trait.name)} (Layer ${data.layer})</div>

                    <div style="background: var(--bg-tertiary); padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                        <div style="margin-bottom: 10px;">
                            <div style="color: var(--text-secondary); font-size: 13px; margin-bottom: 5px;">Full Conversation</div>
                            <div style="color: var(--text-primary); font-size: 16px; font-weight: 600;">${data.prompt.text} ${data.response.text}</div>
                        </div>
                        <div>
                            <div style="color: var(--text-secondary); font-size: 13px;">Layer</div>
                            <div style="color: var(--text-primary); font-size: 16px; font-weight: 600;">Layer ${data.layer} of 27</div>
                        </div>
                    </div>

                    <div id="sublayer-trajectory" style="margin-bottom: 30px;"></div>
                    <div id="contribution-breakdown" style="margin-bottom: 30px;"></div>
                    <div id="head-contributions" style="margin-bottom: 30px;"></div>
                    <div id="attention-heatmaps" style="margin-bottom: 30px;"></div>
                    <div id="top-neurons-combined"></div>
                </div>
            `;

            // Combine prompt and response tokens and activations
            const responseGelu = data.internals.response.gelu;
            const responseTokens = data.response.tokens;

            const allTokens = [...promptTokens, ...responseTokens];
            const allGelu = [...promptGelu, ...responseGelu];

            // Render new visualizations if trait projections available
            if (data.trait_projections) {
                renderSublayerTrajectory(data, promptTokens.length);
                renderContributionBreakdown(data, promptTokens.length);
                renderHeadContributions(data, promptTokens.length);
            }

            // Store data for slider updates
            window.currentLayerData = { data, promptLength: promptTokens.length };

            // Render attention heatmaps
            if (data.internals.prompt.attn_weights) {
                renderAttentionHeatmaps(data, promptTokens.length, 0);  // Start with token 0
            }

            // Render combined neuron activations
            renderTopNeurons('top-neurons-combined', 'Top Neurons (Full Conversation)', allGelu, allTokens, promptTokens.length);

            // Setup math rendering and toggle listeners
            renderMath();
        }

        // ============================================================================
        // Phase 1 Visualizations
        // ============================================================================

        function renderSublayerTrajectory(data, promptLength) {
            // Combine prompt and response projections
            const promptProj = data.trait_projections.prompt;
            const responseProj = data.trait_projections.response;

            const allTokens = [...data.prompt.tokens, ...data.response.tokens];
            const residualIn = [...promptProj.residual_in, ...responseProj.residual_in];
            const residualAfterAttn = [...promptProj.residual_after_attn, ...responseProj.residual_after_attn];
            const residualOut = [...promptProj.residual_out, ...responseProj.residual_out];

            const trace1 = {
                x: Array.from({length: allTokens.length}, (_, i) => i),
                y: residualIn,
                mode: 'lines+markers',
                name: 'Residual In',
                line: { color: '#888', width: 2 },
                marker: { size: 6 },
                hovertemplate: 'Token %{x}: %{text}<br>Trait Score: %{y:.3f}<extra></extra>',
                text: allTokens
            };

            const trace2 = {
                x: Array.from({length: allTokens.length}, (_, i) => i),
                y: residualAfterAttn,
                mode: 'lines+markers',
                name: 'After Attention',
                line: { color: '#4a9eff', width: 2 },
                marker: { size: 6 },
                hovertemplate: 'Token %{x}: %{text}<br>Trait Score: %{y:.3f}<extra></extra>',
                text: allTokens
            };

            const trace3 = {
                x: Array.from({length: allTokens.length}, (_, i) => i),
                y: residualOut,
                mode: 'lines+markers',
                name: 'After MLP (Output)',
                line: { color: '#4caf50', width: 2 },
                marker: { size: 6 },
                hovertemplate: 'Token %{x}: %{text}<br>Trait Score: %{y:.3f}<extra></extra>',
                text: allTokens
            };

            // Add separator line
            const shapes = [];
            if (promptLength) {
                shapes.push({
                    type: 'line',
                    xref: 'x',
                    yref: 'paper',
                    x0: promptLength - 0.5,
                    x1: promptLength - 0.5,
                    y0: 0,
                    y1: 1,
                    line: {
                        color: 'rgba(255, 255, 255, 0.3)',
                        width: 2,
                        dash: 'dash'
                    }
                });
            }

            const layout = getPlotlyLayout({
                title: '3-Checkpoint Trait Trajectory (Sublayer Evolution)',
                xaxis: { title: 'Token Position' },
                yaxis: { title: 'Trait Score' },
                height: 350,
                shapes: shapes
            });

            Plotly.newPlot('sublayer-trajectory', [trace1, trace2, trace3], layout, { displayModeBar: false });
        }

        function renderContributionBreakdown(data, promptLength) {
            // Combine prompt and response contributions
            const promptProj = data.trait_projections.prompt;
            const responseProj = data.trait_projections.response;

            const allTokens = [...data.prompt.tokens, ...data.response.tokens];
            const attnContrib = [...promptProj.attn_contribution, ...responseProj.attn_contribution];
            const mlpContrib = [...promptProj.mlp_contribution, ...responseProj.mlp_contribution];

            const trace1 = {
                x: Array.from({length: allTokens.length}, (_, i) => i),
                y: attnContrib,
                type: 'bar',
                name: 'Attention Contribution',
                marker: { color: '#4a9eff' },
                hovertemplate: 'Token %{x}: %{text}<br>Attention: %{y:.3f}<extra></extra>',
                text: allTokens
            };

            const trace2 = {
                x: Array.from({length: allTokens.length}, (_, i) => i),
                y: mlpContrib,
                type: 'bar',
                name: 'MLP Contribution',
                marker: { color: '#4caf50' },
                hovertemplate: 'Token %{x}: %{text}<br>MLP: %{y:.3f}<extra></extra>',
                text: allTokens
            };

            // Add separator line
            const shapes = [];
            if (promptLength) {
                shapes.push({
                    type: 'line',
                    xref: 'x',
                    yref: 'paper',
                    x0: promptLength - 0.5,
                    x1: promptLength - 0.5,
                    y0: 0,
                    y1: 1,
                    line: {
                        color: 'rgba(255, 255, 255, 0.3)',
                        width: 2,
                        dash: 'dash'
                    }
                });
            }

            const layout = getPlotlyLayout({
                title: 'Attention vs MLP Contribution (Per Token)',
                xaxis: { title: 'Token Position' },
                yaxis: { title: 'Trait Contribution' },
                barmode: 'group',
                height: 400,
                shapes: shapes
            });

            Plotly.newPlot('contribution-breakdown', [trace1, trace2], layout, { displayModeBar: false });
        }

        function renderHeadContributions(data, promptLength) {
            // Check if per-head contributions are available
            const promptProj = data.trait_projections.prompt;
            const responseProj = data.trait_projections.response;

            if (!promptProj.head_contributions && !responseProj.head_contributions) {
                document.getElementById('head-contributions').style.display = 'none';
                return;
            }

            document.getElementById('head-contributions').style.display = 'block';

            // Combine prompt and response head contributions
            // head_contributions is [n_heads, n_tokens]
            const headContribsPrompt = promptProj.head_contributions || [];
            const headContribsResponse = responseProj.head_contributions || [];

            const allTokens = [...data.prompt.tokens, ...data.response.tokens];
            const nHeads = headContribsPrompt.length || headContribsResponse.length;

            // Create traces for each head
            const traces = [];
            const colors = ['#4a9eff', '#ff6b6b', '#51cf66', '#ffc107', '#9c27b0', '#ff9800', '#00bcd4', '#e91e63'];

            for (let headIdx = 0; headIdx < nHeads; headIdx++) {
                // Combine prompt and response contributions for this head
                const promptContrib = headContribsPrompt[headIdx] || [];
                const responseContrib = headContribsResponse[headIdx] || [];
                const allContrib = [...promptContrib, ...responseContrib];

                traces.push({
                    x: Array.from({length: allContrib.length}, (_, i) => i),
                    y: allContrib,
                    mode: 'lines+markers',
                    name: `Head ${headIdx}`,
                    line: { color: colors[headIdx % colors.length], width: 2 },
                    marker: { size: 4 },
                    hovertemplate: 'Token %{x}: %{text}<br>Head ' + headIdx + ': %{y:.3f}<extra></extra>',
                    text: allTokens
                });
            }

            // Add separator line
            const shapes = [];
            if (promptLength) {
                shapes.push({
                    type: 'line',
                    xref: 'x',
                    yref: 'paper',
                    x0: promptLength - 0.5,
                    x1: promptLength - 0.5,
                    y0: 0,
                    y1: 1,
                    line: {
                        color: 'rgba(255, 255, 255, 0.3)',
                        width: 2,
                        dash: 'dash'
                    }
                });
            }

            const layout = getPlotlyLayout({
                title: 'Per-Head Trait Contributions (Which Heads Drive the Trait)',
                xaxis: { title: 'Token Position' },
                yaxis: { title: 'Head Contribution to Trait' },
                height: 400,
                shapes: shapes,
                showlegend: true,
                legend: {
                    orientation: 'h',
                    yanchor: 'bottom',
                    y: -0.3,
                    xanchor: 'center',
                    x: 0.5
                }
            });

            Plotly.newPlot('head-contributions', traces, layout, { displayModeBar: false });
        }

        function renderAttentionHeatmaps(data, promptLength, tokenIdx = 0) {
            // Show attention patterns for a single query token
            // Display how this token attends to all context tokens across 8 heads

            const allTokens = [...data.prompt.tokens, ...data.response.tokens];
            const isPromptToken = tokenIdx < promptLength;

            let attnWeights;  // [8_heads, seq_len] - just the row for this query token
            let contextTokens;

            if (isPromptToken) {
                // Query is in prompt - extract row from prompt attention
                const promptAttn = data.internals.prompt.attn_weights;  // [8_heads, prompt_len, prompt_len]
                attnWeights = promptAttn.map(head => head[tokenIdx]);  // [8_heads, prompt_len]
                contextTokens = data.prompt.tokens;
            } else {
                // Query is in response - extract row from response attention
                const responseIdx = tokenIdx - promptLength;
                const responseAttn = data.internals.response.attn_weights[responseIdx];  // [8_heads, context_len, context_len]
                const contextLen = promptLength + responseIdx + 1;
                attnWeights = responseAttn.map(head => head[head.length - 1]);  // Last row = this token's attention
                contextTokens = allTokens.slice(0, contextLen);  // All context up to this point
            }

            const html = `
                <div style="margin-bottom: 20px; padding: 15px; background: var(--bg-secondary); border-radius: 8px;">
                    <h3 style="margin: 0 0 15px 0; color: var(--text-primary);">Query Token Attention</h3>

                    <!-- Slider -->
                    <div style="margin-bottom: 10px;">
                        <label style="color: var(--text-secondary); font-size: 13px;">
                            Select Query Token: <span id="attn-slider-value" style="color: var(--text-primary); font-weight: 600;">0</span> -
                            "<span id="attn-slider-token" style="color: var(--text-primary); font-weight: 600;">${allTokens[0]}</span>"
                        </label>
                    </div>
                    <input type="range" id="attn-slider" min="0" max="${allTokens.length - 1}" value="${tokenIdx}"
                           style="width: 100%; height: 3px; border-radius: 2px; background: var(--border-color);">

                    <div style="margin-top: 15px; color: var(--text-secondary); font-size: 13px;">
                        Showing how token <span style="color: var(--text-primary); font-weight: 600;">"${allTokens[tokenIdx]}"</span>
                        (position ${tokenIdx}) attends to ${contextTokens.length} context tokens
                    </div>
                </div>

                <!-- 8 Head Patterns Stacked Vertically -->
                <div style="display: grid; grid-template-columns: 1fr; gap: 15px;">
                    ${Array.from({length: 8}, (_, i) => `<div id="attn-head-${i}"></div>`).join('')}
                </div>
            `;

            document.getElementById('attention-heatmaps').innerHTML = html;

            // Render each head as a 1-row heatmap
            for (let head = 0; head < 8; head++) {
                const headAttn = attnWeights[head];  // [context_len]

                // Create 1-row heatmap with query position highlighted
                const trace = {
                    z: [headAttn],  // Single row
                    x: contextTokens,
                    y: ['Attention'],
                    type: 'heatmap',
                    colorscale: 'Viridis',
                    hovertemplate: 'To: %{x}<br>Weight: %{z:.3f}<extra></extra>',
                    showscale: head === 7  // Only show scale on last plot
                };

                // Highlight the query position
                const shapes = [];
                const queryPosInContext = isPromptToken ? tokenIdx : headAttn.length - 1;
                shapes.push({
                    type: 'rect',
                    xref: 'x',
                    yref: 'paper',
                    x0: queryPosInContext - 0.5,
                    x1: queryPosInContext + 0.5,
                    y0: 0,
                    y1: 1,
                    line: { color: '#ff6b6b', width: 3 },
                    fillcolor: 'rgba(255, 107, 107, 0.1)'
                });

                const layout = getPlotlyLayout({
                    title: `Head ${head}`,
                    xaxis: { title: 'Context Token', tickangle: -45, tickfont: { size: 9 } },
                    yaxis: { title: '', showticklabels: false },
                    height: 80,
                    margin: { l: 25, r: 5, t: 10, b: 50 },
                    shapes: shapes
                });

                Plotly.newPlot(`attn-head-${head}`, [trace], layout, { displayModeBar: false });
            }

            // Add slider event listener
            document.getElementById('attn-slider').addEventListener('input', (e) => {
                const newTokenIdx = parseInt(e.target.value);
                document.getElementById('attn-slider-value').textContent = newTokenIdx;
                document.getElementById('attn-slider-token').textContent = allTokens[newTokenIdx];
                renderAttentionHeatmaps(data, promptLength, newTokenIdx);
            });
        }

        // ============================================================================
        // Neuron Visualization
        // ============================================================================

        function renderTopNeurons(divId, title, geluActivations, tokens, promptLength = null) {
            // Store for access by slider callback
            window.currentLayerData = { data: window.currentLayerData?.data, promptLength };
            // geluActivations: [n_tokens, 9216]
            // Show per-token heatmap with slider
            // promptLength: if provided, adds visual separator between prompt and response

            if (!geluActivations || geluActivations.length === 0) {
                document.getElementById(divId).innerHTML = '<div style="color: var(--text-secondary);">No data</div>';
                return;
            }

            const nTokens = geluActivations.length;
            const nNeurons = geluActivations[0].length;

            // Find top 50 neurons by average activation magnitude
            const neuronAvg = new Array(nNeurons).fill(0);
            for (let t = 0; t < nTokens; t++) {
                for (let n = 0; n < nNeurons; n++) {
                    neuronAvg[n] += Math.abs(geluActivations[t][n]);
                }
            }
            for (let n = 0; n < nNeurons; n++) {
                neuronAvg[n] /= nTokens;
            }

            const neuronIndices = Array.from({length: nNeurons}, (_, i) => i);
            neuronIndices.sort((a, b) => neuronAvg[b] - neuronAvg[a]);
            const topNeurons = neuronIndices.slice(0, 50);

            // Create heatmap data: [50_neurons, n_tokens]
            const heatmapData = topNeurons.map(neuronIdx => {
                return geluActivations.map(tokenActivations => tokenActivations[neuronIdx]);
            });

            // Create unique div IDs
            const heatmapId = `${divId}-heatmap`;
            const sliderId = `${divId}-slider`;
            const sliderValueId = `${divId}-slider-value`;
            const barChartId = `${divId}-bar`;

            const html = `
                <div style="margin-bottom: 30px;">
                    <h3 style="margin-bottom: 15px; color: var(--text-primary);">${title}</h3>

                    <div style="margin-bottom: 20px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <label style="color: var(--text-secondary); font-weight: 600;">
                                Token Position: <span id="${sliderValueId}" style="color: var(--primary-color);">0</span> / ${nTokens - 1}
                            </label>
                            <span style="color: var(--text-secondary); font-size: 12px;">
                                Token: "<span id="${sliderValueId}-token" style="font-weight: 600;">${tokens[0]}</span>"
                            </span>
                        </div>
                        <input type="range" id="${sliderId}" min="0" max="${nTokens - 1}" value="0"
                               style="width: 100%; height: 3px; border-radius: 2px; background: var(--border-color);">
                    </div>

                    <div id="${heatmapId}" style="margin-bottom: 30px;"></div>
                    <div id="${barChartId}"></div>
                </div>
            `;

            document.getElementById(divId).innerHTML = html;

            // Render heatmap (overview of all tokens √ó top neurons)
            const heatmapTrace = {
                z: heatmapData,
                x: tokens,
                y: topNeurons.map(n => `N${n}`),
                type: 'heatmap',
                colorscale: 'RdBu',
                zmid: 0,
                hovertemplate: 'Token: %{x}<br>Neuron: %{y}<br>Activation: %{z:.3f}<extra></extra>',
                colorbar: {
                    title: 'Activation'
                }
            };

            // Build shapes array for heatmap
            const shapes = [{
                type: 'rect',
                xref: 'x',
                yref: 'paper',
                x0: -0.5,
                x1: 0.5,
                y0: 0,
                y1: 1,
                fillcolor: 'rgba(74, 158, 255, 0.15)',
                line: { width: 0 }
            }];

            // Add separator line between prompt and response if provided
            if (promptLength !== null) {
                shapes.push({
                    type: 'line',
                    xref: 'x',
                    yref: 'paper',
                    x0: promptLength - 0.5,
                    x1: promptLength - 0.5,
                    y0: 0,
                    y1: 1,
                    line: {
                        color: 'rgba(255, 255, 255, 0.5)',
                        width: 2,
                        dash: 'dash'
                    }
                });
            }

            // Add annotations for prompt/response regions if applicable
            const annotations = [];
            if (promptLength !== null) {
                annotations.push({
                    x: (promptLength - 1) / 2,
                    y: 1.05,
                    xref: 'x',
                    yref: 'paper',
                    text: 'Prompt',
                    showarrow: false,
                    font: { size: 12, color: 'var(--text-secondary)' },
                    xanchor: 'center'
                });
                annotations.push({
                    x: promptLength + (nTokens - promptLength - 1) / 2,
                    y: 1.05,
                    xref: 'x',
                    yref: 'paper',
                    text: 'Response',
                    showarrow: false,
                    font: { size: 12, color: 'var(--text-secondary)' },
                    xanchor: 'center'
                });
            }

            const heatmapLayout = getPlotlyLayout({
                title: 'Neuron Activations Across All Tokens (Top 50 Neurons)',
                xaxis: { title: 'Token', tickangle: -45 },
                yaxis: { title: 'Neuron', autorange: 'reversed' },
                height: 400,
                shapes: shapes,
                annotations: annotations
            });

            Plotly.newPlot(heatmapId, [heatmapTrace], heatmapLayout, { displayModeBar: false });

            // Function to update bar chart for selected token
            function updateBarChart(tokenIdx) {
                const tokenActivations = geluActivations[tokenIdx];
                const topActivations = topNeurons.map(n => tokenActivations[n]);

                const barTrace = {
                    x: topNeurons.map(n => `N${n}`),
                    y: topActivations,
                    type: 'bar',
                    marker: {
                        color: topActivations.map(a => a > 0 ? '#4caf50' : '#f44336')
                    },
                    hovertemplate: 'Neuron: %{x}<br>Activation: %{y:.3f}<extra></extra>'
                };

                Plotly.newPlot(barChartId, [barTrace], getPlotlyLayout({
                    title: `Neuron Activations for Token "${tokens[tokenIdx]}" (Position ${tokenIdx})`,
                    xaxis: { title: 'Neuron Index', tickangle: -45 },
                    yaxis: { title: 'Activation' },
                    height: 350
                }), { displayModeBar: false });

                // Update heatmap highlight
                const newShapes = [{
                    type: 'rect',
                    xref: 'x',
                    yref: 'paper',
                    x0: tokenIdx - 0.5,
                    x1: tokenIdx + 0.5,
                    y0: 0,
                    y1: 1,
                    fillcolor: 'rgba(74, 158, 255, 0.15)',
                    line: { width: 0 }
                }];

                // Add separator line if provided
                if (promptLength !== null) {
                    newShapes.push({
                        type: 'line',
                        xref: 'x',
                        yref: 'paper',
                        x0: promptLength - 0.5,
                        x1: promptLength - 0.5,
                        y0: 0,
                        y1: 1,
                        line: {
                            color: 'rgba(255, 255, 255, 0.5)',
                            width: 2,
                            dash: 'dash'
                        }
                    });
                }

                // Preserve annotations when updating
                const layoutUpdate = { shapes: newShapes };
                if (annotations.length > 0) {
                    layoutUpdate.annotations = annotations;
                }
                Plotly.relayout(heatmapId, layoutUpdate);

                // Update slider label
                document.getElementById(sliderValueId).textContent = tokenIdx;
                document.getElementById(`${sliderValueId}-token`).textContent = tokens[tokenIdx];
            }

            // Initialize with first token
            updateBarChart(0);

            // Add slider event listener
            document.getElementById(sliderId).addEventListener('input', (e) => {
                updateBarChart(parseInt(e.target.value));
            });
        }

        // Setup event listeners
        function setupEventListeners() {
            // Experiment selection is now handled in loadExperiments()

            // Theme toggle
            document.getElementById('theme-toggle').addEventListener('click', toggleTheme);

            // Info tooltip
            document.getElementById('info-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                toggleInfo();
            });

            // Select all traits button
            document.getElementById('select-all-btn').addEventListener('click', toggleAllTraits);
        }

        // Utility functions
        function showError(message) {
            document.getElementById('content-area').innerHTML = `
                <div class="error">
                    <strong>Error:</strong> ${message}
                    <br><br>
                    Make sure you're running a local server from the trait-interp root directory:
                    <pre style="background: #2d2d2d; color: #f8f8f2; padding: 10px; border-radius: 4px; margin-top: 10px;">cd trait-interp
python -m http.server 8000</pre>
                    Then visit: <a href="http://localhost:8000/visualization/">http://localhost:8000/visualization/</a>
                </div>
            `;
        }

        // Initialize on page load
        init();
    </script>
</body>
</html>
