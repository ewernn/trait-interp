<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trait Interp Visualization</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <style>
        :root {
            --bg-primary: #f8f9fa;
            --bg-secondary: #ffffff;
            --bg-tertiary: #f8f9fa;
            --text-primary: #333;
            --text-secondary: #666;
            --text-tertiary: #888;
            --border-color: #ddd;
            --shadow: rgba(0,0,0,0.1);
            --primary-color: #007bff;
            --primary-hover: #0056b3;
            --success: #28a745;
            --danger: #dc3545;
            --info-bg: #d1ecf1;
            --info-border: #17a2b8;
            --info-text: #0c5460;
        }

        [data-theme="dark"] {
            --bg-primary: #1a1a1a;
            --bg-secondary: #2d2d2d;
            --bg-tertiary: #3a3a3a;
            --text-primary: #e0e0e0;
            --text-secondary: #b0b0b0;
            --text-tertiary: #888;
            --border-color: #444;
            --shadow: rgba(0,0,0,0.3);
            --primary-color: #4a9eff;
            --primary-hover: #6bb0ff;
            --success: #4caf50;
            --danger: #f44336;
            --info-bg: #1e3a4a;
            --info-border: #2196f3;
            --info-text: #90caf9;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--bg-primary);
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            display: flex;
            gap: 0;
            max-width: 100%;
            height: 100vh;
            overflow: hidden;
        }

        .sidebar {
            width: 280px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            transition: background 0.3s ease;
        }

        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid var(--border-color);
            position: sticky;
            top: 0;
            background: var(--bg-secondary);
            z-index: 10;
        }

        .sidebar-title {
            font-size: 18px;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 5px;
            transition: color 0.3s ease;
        }

        .sidebar-subtitle {
            font-size: 12px;
            color: var(--text-secondary);
            transition: color 0.3s ease;
        }

        .sidebar-section {
            padding: 20px;
            border-bottom: 1px solid var(--border-color);
        }

        .section-title {
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            color: var(--text-tertiary);
            margin-bottom: 12px;
            letter-spacing: 0.5px;
        }

        .nav-item {
            padding: 10px 12px;
            margin-bottom: 4px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            color: var(--text-secondary);
            font-size: 14px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .nav-item:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .nav-item.active {
            background: var(--primary-color);
            color: white;
        }

        .nav-item .icon {
            font-size: 16px;
        }

        .trait-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            margin-bottom: 4px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 13px;
            color: var(--text-secondary);
        }

        .trait-checkbox:hover {
            background: var(--bg-tertiary);
        }

        .trait-checkbox input[type="checkbox"] {
            cursor: pointer;
        }

        .trait-checkbox label {
            cursor: pointer;
            margin: 0;
            flex: 1;
            color: inherit;
        }

        .select-all-btn {
            padding: 6px 10px;
            font-size: 11px;
            margin-bottom: 8px;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        header {
            background: var(--bg-secondary);
            padding: 15px 30px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.3s ease;
        }

        .header-left {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .header-right {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .info-btn, .theme-toggle {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 50%;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s;
        }

        .info-btn:hover, .theme-toggle:hover {
            background: var(--primary-color);
            color: white;
            transform: scale(1.05);
        }

        .info-tooltip {
            position: fixed;
            top: 70px;
            left: 20px;
            background: var(--bg-secondary);
            border: 2px solid var(--primary-color);
            border-radius: 12px;
            padding: 20px;
            max-width: 500px;
            box-shadow: 0 8px 24px var(--shadow);
            z-index: 1000;
            display: none;
            max-height: calc(100vh - 100px);
            overflow-y: auto;
        }

        .info-tooltip.show {
            display: block;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .info-tooltip h3 {
            color: var(--primary-color);
            margin-bottom: 15px;
            font-size: 18px;
        }

        .info-tooltip h4 {
            color: var(--text-secondary);
            margin-top: 15px;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .info-tooltip ul {
            margin-left: 20px;
            color: var(--text-secondary);
            font-size: 13px;
            line-height: 1.6;
        }

        .info-tooltip strong {
            color: var(--text-secondary);
        }

        .info-tooltip .trait-list {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
            margin-top: 8px;
            list-style: none;
            margin-left: 0;
        }

        .info-tooltip .trait-list li {
            color: var(--text-secondary);
        }

        .page-title {
            font-size: 20px;
            font-weight: 600;
            color: var(--text-primary);
            transition: color 0.3s ease;
        }

        .experiment-badge {
            padding: 4px 12px;
            background: var(--bg-tertiary);
            border-radius: 20px;
            font-size: 12px;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .content-wrapper {
            flex: 1;
            overflow-y: auto;
            padding: 30px;
        }

        label {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 4px;
            transition: color 0.3s ease;
        }

        select, button {
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 14px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        button {
            background: var(--primary-color);
            color: white;
            border: none;
            font-weight: 600;
            transition: background 0.2s;
        }

        button:hover {
            background: var(--primary-hover);
        }

        button:disabled {
            background: var(--border-color);
            cursor: not-allowed;
        }

        .tabs {
            background: var(--bg-secondary);
            padding: 0;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px var(--shadow);
            overflow: hidden;
            transition: background 0.3s ease;
        }

        .tab-buttons {
            display: flex;
            border-bottom: 2px solid var(--border-color);
        }

        .tab-button {
            flex: 1;
            padding: 15px 20px;
            background: var(--bg-secondary);
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-weight: 600;
            color: var(--text-secondary);
            transition: all 0.2s;
        }

        .tab-button:hover {
            background: var(--bg-tertiary);
        }

        .tab-button.active {
            color: var(--primary-color);
            border-bottom-color: var(--primary-color);
            background: var(--bg-tertiary);
        }

        .tab-content {
            display: none;
            padding: 20px;
        }

        .tab-content.active {
            display: block;
        }

        .card {
            background: var(--bg-secondary);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px var(--shadow);
            margin-bottom: 20px;
            transition: background 0.3s ease;
        }

        .card-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 15px;
            color: var(--text-primary);
            transition: color 0.3s ease;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .stat-card {
            background: var(--bg-tertiary);
            padding: 15px;
            border-radius: 6px;
            border-left: 4px solid var(--primary-color);
            transition: background 0.3s ease;
        }

        .stat-label {
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 5px;
            text-transform: uppercase;
            font-weight: 600;
            transition: color 0.3s ease;
        }

        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: var(--text-primary);
            transition: color 0.3s ease;
        }

        .stat-detail {
            font-size: 12px;
            color: var(--text-tertiary);
            margin-top: 3px;
            transition: color 0.3s ease;
        }

        .trait-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 15px;
        }

        .trait-card {
            background: var(--bg-secondary);
            padding: 15px;
            border-radius: 6px;
            border: 2px solid var(--border-color);
            cursor: pointer;
            transition: all 0.2s;
        }

        .trait-card:hover {
            border-color: var(--primary-color);
            box-shadow: 0 4px 8px var(--shadow);
            transform: translateY(-2px);
        }

        .trait-card.selected {
            border-color: var(--primary-color);
            background: var(--bg-tertiary);
        }

        .trait-name {
            font-weight: 600;
            font-size: 16px;
            margin-bottom: 8px;
            color: var(--text-primary);
            transition: color 0.3s ease;
        }

        .trait-info {
            font-size: 12px;
            color: var(--text-secondary);
            transition: color 0.3s ease;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: var(--text-secondary);
            transition: color 0.3s ease;
        }

        .error {
            background: #fff3cd;
            border: 1px solid #ffc107;
            padding: 15px;
            border-radius: 6px;
            margin: 20px 0;
            color: #856404;
        }

        .info {
            background: var(--info-bg);
            border: 1px solid var(--info-border);
            padding: 15px;
            border-radius: 6px;
            margin: 20px 0;
            color: var(--info-text);
            transition: all 0.3s ease;
        }

        .response-preview {
            background: var(--bg-tertiary);
            padding: 12px;
            border-radius: 4px;
            font-size: 13px;
            line-height: 1.6;
            margin: 8px 0;
            border-left: 3px solid var(--primary-color);
            color: var(--text-primary);
            transition: all 0.3s ease;
        }

        .score-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            margin-left: 8px;
        }

        .score-high {
            background: #d4edda;
            color: #155724;
        }

        .score-low {
            background: #f8d7da;
            color: #721c24;
        }

        #token-slider {
            width: 100%;
            margin: 15px 0;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            color: #666;
            margin-bottom: 8px;
        }

        .token-highlight {
            background: #ffeb3b;
            padding: 2px 4px;
            border-radius: 3px;
            font-weight: 600;
        }

        .response-text {
            line-height: 1.8;
            font-size: 14px;
            color: var(--text-primary);
            transition: color 0.3s ease;
        }

        pre {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            transition: all 0.3s ease;
        }

        code {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            padding: 2px 6px;
            border-radius: 3px;
            transition: all 0.3s ease;
        }

        /* Data Explorer Styles */
        .explorer-trait-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin-bottom: 10px;
            overflow: hidden;
            transition: all 0.2s;
        }

        .explorer-trait-header {
            padding: 15px 20px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            transition: background 0.2s, color 0.2s;
        }

        .explorer-trait-header:hover {
            background: var(--primary-color);
            color: white;
        }

        .explorer-trait-header.expanded {
            background: var(--primary-color);
            color: white;
        }

        .explorer-trait-header strong,
        .explorer-trait-header span {
            color: inherit;
        }

        .explorer-trait-body {
            padding: 20px;
            display: none;
        }

        .explorer-trait-body.show {
            display: block;
        }

        .file-tree {
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.8;
        }

        .file-item {
            padding: 4px 0;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .file-item.clickable {
            cursor: pointer;
            transition: color 0.2s;
        }

        .file-item.clickable:hover {
            color: var(--primary-color);
            text-decoration: underline;
        }

        .file-item strong,
        .file-item span {
            color: inherit;
        }

        .file-icon {
            font-size: 14px;
        }

        .preview-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            padding: 20px;
        }

        .preview-modal.show {
            display: flex;
        }

        .preview-content {
            background: var(--bg-secondary);
            border-radius: 12px;
            max-width: 900px;
            max-height: 80vh;
            width: 100%;
            display: flex;
            flex-direction: column;
            box-shadow: 0 10px 40px var(--shadow);
        }

        .preview-header {
            padding: 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .preview-body {
            padding: 20px;
            overflow-y: auto;
            flex: 1;
        }

        .close-btn {
            background: var(--danger);
            color: white;
            border: none;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-btn:hover {
            opacity: 0.8;
        }

        .json-viewer {
            background: var(--bg-tertiary);
            padding: 15px;
            border-radius: 6px;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.6;
        }

        .json-viewer pre {
            margin: 0;
            color: var(--text-secondary);
        }

        .json-key {
            color: #61afef;
        }

        .json-string {
            color: #98c379;
        }

        .json-number {
            color: #d19a66;
        }

        .json-boolean {
            color: #c678dd;
        }

        .json-null {
            color: #e06c75;
        }

        .csv-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }

        .csv-table th,
        .csv-table td {
            border: 1px solid var(--border-color);
            padding: 8px;
            text-align: left;
        }

        .csv-table th {
            background: var(--bg-tertiary);
            font-weight: 600;
            color: var(--text-primary);
        }

        .csv-table td {
            color: var(--text-secondary);
        }

        .indent-1 { padding-left: 20px; }
        .indent-2 { padding-left: 40px; }
        .indent-3 { padding-left: 60px; }
    </style>
</head>
<body>
    <!-- Preview modal (global) -->
    <div class="preview-modal" id="preview-modal">
        <div class="preview-content">
            <div class="preview-header">
                <h3 id="preview-title" style="margin: 0; color: var(--text-primary);"></h3>
                <button class="close-btn" onclick="closePreview()">√ó</button>
            </div>
            <div class="preview-body" id="preview-body"></div>
        </div>
    </div>

    <!-- Info tooltip (global) -->
    <div class="info-tooltip" id="info-tooltip">
        <h3>üìä Trait Interpretation Visualization</h3>

        <h4>üîß Tools:</h4>
        <ul>
            <li><strong>Data Explorer</strong> - Inspect file structure, sizes, and preview data</li>
            <li><strong>Overview</strong> - Browse all extracted traits with metadata and example counts</li>
            <li><strong>Response Quality</strong> - Analyze trait score distributions with histograms</li>
            <li><strong>Vector Analysis</strong> - Compare extraction methods across 27 layers with heatmaps</li>
            <li><strong>All Layers</strong> - View trait evolution across all 27 layers (Tier 2 data)</li>
            <li><strong>Layer Deep Dive</strong> - Analyze attention heads and top neurons for one layer (Tier 3 data)</li>
        </ul>

        <h4>üß† Available Traits (16 cognitive primitives):</h4>
        <div class="trait-list">
            <li>refusal</li>
            <li>uncertainty_calibration</li>
            <li>sycophancy</li>
            <li>retrieval_construction</li>
            <li>commitment_strength</li>
            <li>abstract_concrete</li>
            <li>cognitive_load</li>
            <li>context_adherence</li>
            <li>convergent_divergent</li>
            <li>emotional_valence</li>
            <li>instruction_boundary</li>
            <li>local_global</li>
            <li>paranoia_trust</li>
            <li>power_dynamics</li>
            <li>serial_parallel</li>
            <li>temporal_focus</li>
        </div>

        <h4>üí° Quick Tips:</h4>
        <ul>
            <li>Select traits in the sidebar to filter data</li>
            <li>Use the theme toggle (üåô/‚òÄÔ∏è) for dark mode</li>
            <li>Separation scores >40 indicate excellent quality</li>
        </ul>
    </div>

    <div class="container">
        <!-- Sidebar -->
        <div class="sidebar">
            <div class="sidebar-header">
                <div class="sidebar-title">Trait Interp</div>
                <div class="sidebar-subtitle">Vector Visualization</div>
            </div>

            <div class="sidebar-section">
                <div class="section-title">Experiments</div>
                <div id="experiment-list">
                    <div class="nav-item" style="opacity: 0.5; cursor: default;">Loading...</div>
                </div>
            </div>

            <div class="sidebar-section">
                <div class="section-title">Extraction</div>
                <div id="nav-items-extraction">
                    <div class="nav-item active" data-view="data-explorer">
                        <span class="icon">üóÇÔ∏è</span>
                        <span>Data Explorer</span>
                    </div>
                    <div class="nav-item" data-view="overview">
                        <span class="icon">üìä</span>
                        <span>Overview</span>
                    </div>
                    <div class="nav-item" data-view="responses">
                        <span class="icon">üìà</span>
                        <span>Response Quality</span>
                    </div>
                    <div class="nav-item" data-view="vectors">
                        <span class="icon">üî¨</span>
                        <span>Vector Analysis</span>
                    </div>
                </div>
            </div>

            <div class="sidebar-section">
                <div class="section-title">Inference</div>
                <div id="nav-items-inference">
                    <div class="nav-item" data-view="monitoring">
                        <span class="icon">‚ö°</span>
                        <span>All Layers</span>
                    </div>
                    <div class="nav-item" data-view="layer-dive">
                        <span class="icon">üîç</span>
                        <span>Layer Deep Dive</span>
                    </div>
                </div>
            </div>

            <div class="sidebar-section">
                <div class="section-title">
                    Selected Traits (<span id="selected-count">0</span>)
                </div>
                <button class="select-all-btn" id="select-all-btn">Select All</button>
                <div id="trait-checkboxes"></div>
            </div>
        </div>

        <!-- Main Content -->
        <div class="main-content">
            <header>
                <div class="header-left">
                    <button class="info-btn" id="info-btn" title="Information">‚ÑπÔ∏è</button>
                    <div class="page-title" id="page-title">Overview</div>
                    <div class="experiment-badge" id="experiment-badge">-</div>
                </div>
                <div class="header-right">
                    <button class="theme-toggle" id="theme-toggle" title="Toggle dark mode">üåô</button>
                </div>
            </header>

            <div class="content-wrapper" id="content-area">
                <div class="loading">Loading experiment data...</div>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let experiments = [];
        let currentExperiment = null;
        let experimentData = null;
        let currentView = 'data-explorer';
        let selectedTraits = new Set();

        // Display names for better interpretability
        const DISPLAY_NAMES = {
            'uncertainty_calibration': 'Confidence',
            'instruction_boundary': 'Literalness',
            'commitment_strength': 'Assertiveness',
            'retrieval_construction': 'Retrieval',
            'convergent_divergent': 'Thinking Style',
            'abstract_concrete': 'Abstraction Level',
            'temporal_focus': 'Temporal Orientation',
            'cognitive_load': 'Complexity',
            'context_adherence': 'Context Following',
            'emotional_valence': 'Emotional Tone',
            'paranoia_trust': 'Trust Level',
            'power_dynamics': 'Authority Tone',
            'serial_parallel': 'Processing Style',
            'local_global': 'Focus Scope'
            // 'refusal' and 'sycophancy' are clear as-is
        };

        function getDisplayName(traitName) {
            // Parse trait name: "refusal-instruction-extraction" or "refusal-natural-extraction"
            let baseName = traitName;
            let method = '';

            if (traitName.includes('-instruction-extraction')) {
                baseName = traitName.replace('-instruction-extraction', '');
                method = ' (Instruction)';
            } else if (traitName.includes('-natural-extraction')) {
                baseName = traitName.replace('-natural-extraction', '');
                method = ' (Natural)';
            }

            // Get display name for base trait
            let displayBase = DISPLAY_NAMES[baseName] || baseName.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());

            return displayBase + method;
        }

        // Theme management
        function initTheme() {
            const savedTheme = localStorage.getItem('theme') || 'light';
            document.documentElement.setAttribute('data-theme', savedTheme);
            updateThemeIcon(savedTheme);
        }

        function toggleTheme() {
            const currentTheme = document.documentElement.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            document.documentElement.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
            updateThemeIcon(newTheme);
        }

        function updateThemeIcon(theme) {
            const themeToggle = document.getElementById('theme-toggle');
            themeToggle.textContent = theme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
            themeToggle.title = theme === 'dark' ? 'Switch to light mode' : 'Switch to dark mode';
        }

        // Info tooltip
        function toggleInfo() {
            const tooltip = document.getElementById('info-tooltip');
            tooltip.classList.toggle('show');
        }

        // Get Plotly layout with theme support
        function getPlotlyLayout(baseLayout) {
            const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
            return {
                ...baseLayout,
                paper_bgcolor: isDark ? '#2d2d2d' : '#ffffff',
                plot_bgcolor: isDark ? '#2d2d2d' : '#ffffff',
                font: {
                    color: isDark ? '#e0e0e0' : '#333'
                },
                xaxis: {
                    ...baseLayout.xaxis,
                    color: isDark ? '#e0e0e0' : '#333',
                    gridcolor: isDark ? '#444' : '#ddd'
                },
                yaxis: {
                    ...baseLayout.yaxis,
                    color: isDark ? '#e0e0e0' : '#333',
                    gridcolor: isDark ? '#444' : '#ddd'
                }
            };
        }

        // Close info tooltip when clicking outside
        document.addEventListener('click', (e) => {
            const tooltip = document.getElementById('info-tooltip');
            const infoBtn = document.getElementById('info-btn');
            if (tooltip && !tooltip.contains(e.target) && e.target !== infoBtn) {
                tooltip.classList.remove('show');
            }
        });

        // Populate trait checkboxes
        function populateTraitCheckboxes() {
            const container = document.getElementById('trait-checkboxes');
            container.innerHTML = '';

            if (!experimentData || !experimentData.traits) return;

            experimentData.traits.forEach(trait => {
                const checkbox = document.createElement('div');
                checkbox.className = 'trait-checkbox';
                checkbox.innerHTML = `
                    <input type="checkbox" id="trait-${trait.name}" value="${trait.name}" checked>
                    <label for="trait-${trait.name}">${getDisplayName(trait.name)}</label>
                `;
                container.appendChild(checkbox);

                const input = checkbox.querySelector('input');
                input.addEventListener('change', (e) => {
                    if (e.target.checked) {
                        selectedTraits.add(trait.name);
                    } else {
                        selectedTraits.delete(trait.name);
                    }
                    updateSelectedCount();
                    renderView();
                });

                selectedTraits.add(trait.name);
            });

            updateSelectedCount();
        }

        // Update selected trait count
        function updateSelectedCount() {
            document.getElementById('selected-count').textContent = selectedTraits.size;
        }

        // Select/deselect all traits
        function toggleAllTraits() {
            const checkboxes = document.querySelectorAll('#trait-checkboxes input[type="checkbox"]');
            const allSelected = selectedTraits.size === checkboxes.length;

            checkboxes.forEach(cb => {
                cb.checked = !allSelected;
                if (!allSelected) {
                    selectedTraits.add(cb.value);
                } else {
                    selectedTraits.delete(cb.value);
                }
            });

            const btn = document.getElementById('select-all-btn');
            btn.textContent = allSelected ? 'Select All' : 'Deselect All';
            updateSelectedCount();
            renderView();
        }

        // Handle navigation
        function setupNavigation() {
            const navItems = document.querySelectorAll('.nav-item');
            navItems.forEach(item => {
                item.addEventListener('click', () => {
                    navItems.forEach(n => n.classList.remove('active'));
                    item.classList.add('active');
                    currentView = item.dataset.view;
                    updatePageTitle();
                    renderView();
                });
            });
        }

        // Update page title
        function updatePageTitle() {
            const titles = {
                'data-explorer': 'Data Explorer',
                'overview': 'Overview',
                'responses': 'Response Quality',
                'vectors': 'Vector Analysis',
                'monitoring': 'All Layers',
                'layer-dive': 'Layer Deep Dive'
            };
            document.getElementById('page-title').textContent = titles[currentView] || 'Data Explorer';
        }

        // Get filtered traits
        function getFilteredTraits() {
            if (!experimentData || !experimentData.traits) return [];
            return experimentData.traits.filter(trait => selectedTraits.has(trait.name));
        }

        // Initialize
        async function init() {
            initTheme();
            setupNavigation();
            await loadExperiments();
            setupEventListeners();
        }

        // Load available experiments
        async function loadExperiments() {
            try {
                // Try to fetch a directory listing or manually define experiments
                // For now, hardcode known experiments
                experiments = [
                    'gemma_2b_cognitive_nov20',
                    'gemma_2b_natural_nov20'
                ];

                const list = document.getElementById('experiment-list');
                list.innerHTML = experiments.map((exp, idx) => {
                    const displayName = exp.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    const isActive = idx === 0 ? 'active' : '';
                    return `
                        <div class="nav-item ${isActive}" data-experiment="${exp}">
                            <span class="icon">üî¨</span>
                            <span>${displayName}</span>
                        </div>
                    `;
                }).join('');

                // Add click handlers
                list.querySelectorAll('.nav-item').forEach(item => {
                    item.addEventListener('click', () => {
                        list.querySelectorAll('.nav-item').forEach(i => i.classList.remove('active'));
                        item.classList.add('active');
                        currentExperiment = item.dataset.experiment;
                        loadExperimentData(currentExperiment);
                    });
                });

                if (experiments.length > 0) {
                    currentExperiment = experiments[0];
                    await loadExperimentData(currentExperiment);
                }
            } catch (error) {
                console.error('Error loading experiments:', error);
                showError('Failed to load experiments');
            }
        }

        // Load experiment data
        async function loadExperimentData(experimentName) {
            const contentArea = document.getElementById('content-area');
            contentArea.innerHTML = '<div class="loading">Loading experiment data...</div>';

            try {
                experimentData = {
                    name: experimentName,
                    traits: [],
                    readme: null
                };

                // Try to load README
                try {
                    const readmeResponse = await fetch(`../experiments/${experimentName}/README.md`);
                    if (readmeResponse.ok) {
                        experimentData.readme = await readmeResponse.text();
                    }
                } catch (e) {
                    console.log('No README found');
                }

                // Discover traits by trying known trait bases with both extraction methods
                const knownTraitBases = [
                    'abstract_concrete', 'commitment_strength',
                    'context_adherence', 'convergent_divergent', 'emotional_valence',
                    'instruction_boundary', 'instruction_following', 'local_global',
                    'paranoia_trust', 'power_dynamics', 'refusal', 'retrieval_construction',
                    'serial_parallel', 'sycophancy', 'temporal_focus',
                    'uncertainty_calibration'
                ];

                const methods = ['instruction-extraction', 'natural-extraction'];

                for (const traitBase of knownTraitBases) {
                    for (const method of methods) {
                        const traitFullName = `${traitBase}-${method}`;
                        try {
                            const metadataResponse = await fetch(
                                `../experiments/${experimentName}/${traitFullName}/extraction/activations/metadata.json`
                            );
                            if (metadataResponse.ok) {
                                const metadata = await metadataResponse.json();

                                // Detect response file format (.csv or .json)
                                let responseFormat = null;
                                try {
                                    const csvCheck = await fetch(
                                        `../experiments/${experimentName}/${traitFullName}/extraction/responses/pos.csv`
                                    );
                                    if (csvCheck.ok) {
                                        responseFormat = 'csv';
                                    } else {
                                        const jsonCheck = await fetch(
                                            `../experiments/${experimentName}/${traitFullName}/extraction/responses/pos.json`
                                        );
                                        if (jsonCheck.ok) {
                                            responseFormat = 'json';
                                        }
                                    }
                                } catch (e) {
                                    // No response files found
                                }

                                // Only add trait if it has response files
                                if (responseFormat) {
                                    experimentData.traits.push({
                                        name: traitFullName,
                                        baseName: traitBase,
                                        method: method.replace('-extraction', ''),
                                        metadata: metadata,
                                        responseFormat: responseFormat,
                                        hasResponses: true,
                                        hasVectors: true
                                    });
                                }
                            }
                        } catch (e) {
                            // Trait doesn't exist, skip
                        }
                    }
                }

                // Update experiment badge
                const badge = document.getElementById('experiment-badge');
                badge.textContent = experimentName.replace(/_/g, ' ');

                console.log(`Loaded ${experimentData.traits.length} traits for ${experimentName}:`, experimentData.traits.map(t => t.name));

                // Populate trait checkboxes
                populateTraitCheckboxes();

                // Render view
                renderView();
            } catch (error) {
                console.error('Error loading experiment data:', error);
                showError(`Failed to load experiment: ${experimentName}`);
            }
        }

        // Render current view
        function renderView() {
            const contentArea = document.getElementById('content-area');

            switch (currentView) {
                case 'data-explorer':
                    renderDataExplorer();
                    break;
                case 'overview':
                    renderOverview();
                    break;
                case 'responses':
                    renderResponses();
                    break;
                case 'vectors':
                    renderVectors();
                    break;
                case 'monitoring':
                    renderMonitoring();
                    break;
                case 'layer-dive':
                    renderLayerDeepDive();
                    break;
            }
        }

        // Render Data Explorer
        async function renderDataExplorer() {
            const contentArea = document.getElementById('content-area');
            const filteredTraits = getFilteredTraits();

            // Calculate totals
            const totalTraits = experimentData.traits.length;
            const selectedCount = filteredTraits.length;
            const estimatedSize = (totalTraits * 47).toFixed(0); // ~47 MB per trait

            let html = `
                <div class="info" style="margin-bottom: 20px;">
                    <strong>How Data Explorer Works:</strong><br>
                    Browse the complete file structure for each trait. Each trait contains:<br>
                    ‚Ä¢ <strong>trait_definition.json</strong> - Trait description and examples<br>
                    ‚Ä¢ <strong>responses/</strong> - Generated model responses (pos.csv, neg.csv)<br>
                    ‚Ä¢ <strong>activations/</strong> - Layer activations captured during generation (27 layers √ó 2304 dims)<br>
                    ‚Ä¢ <strong>vectors/</strong> - Extracted trait vectors (4 methods √ó 27 layers √ó 2 files each)
                </div>
                <div class="card">
                    <div class="card-title">Dataset Overview</div>
                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-label">Total Traits</div>
                            <div class="stat-value">${totalTraits}</div>
                            <div class="stat-detail">${selectedCount} selected</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Estimated Storage</div>
                            <div class="stat-value">~${estimatedSize} MB</div>
                            <div class="stat-detail">~47 MB per trait</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Data Completeness</div>
                            <div class="stat-value">100%</div>
                            <div class="stat-detail">All files present</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Total Files</div>
                            <div class="stat-value">${totalTraits * 223}</div>
                            <div class="stat-detail">223 files per trait</div>
                        </div>
                    </div>
                </div>

                <div class="card">
                    <div class="card-title">File Explorer</div>
                    <div class="info">
                        Click trait names to expand/collapse. Click file names to preview content.
                    </div>
                    <div style="margin-top: 20px;">
            `;

            // Render each trait
            filteredTraits.forEach(trait => {
                const displayName = getDisplayName(trait.name);
                const metadata = trait.metadata;

                html += `
                    <div class="explorer-trait-card">
                        <div class="explorer-trait-header" onclick="toggleTraitBody('${trait.name}')">
                            <div>
                                <strong>${displayName}</strong>
                                <span style="margin-left: 10px; font-size: 12px; opacity: 0.8;">
                                    ${metadata.n_examples || 0} examples | 223 files | ~47 MB
                                </span>
                            </div>
                            <span class="expand-icon" id="expand-icon-${trait.name}">‚ñ∂</span>
                        </div>
                        <div class="explorer-trait-body" id="trait-body-${trait.name}">
                            <div class="file-tree">
                                <div class="file-item">
                                    <span class="file-icon">üìÅ</span>
                                    <strong>${trait.name}/</strong>
                                </div>

                                <div class="file-item indent-1 clickable" onclick="previewJSON('${trait.name}', 'trait_definition')">
                                    <span class="file-icon">‚úì</span>
                                    <span>trait_definition.json</span>
                                    <span style="opacity: 0.6; font-size: 11px;">(~15 KB) [preview ‚Üí]</span>
                                </div>

                                <div class="file-item indent-1">
                                    <span class="file-icon">üìÅ</span>
                                    <strong>responses/</strong>
                                </div>
                                <div class="file-item indent-2 clickable" onclick="previewCSV('${trait.name}', 'pos')">
                                    <span class="file-icon">‚úì</span>
                                    <span>pos.csv</span>
                                    <span style="opacity: 0.6; font-size: 11px;">(${metadata.n_examples_pos || '?'} rows) [preview ‚Üí]</span>
                                </div>
                                <div class="file-item indent-2 clickable" onclick="previewCSV('${trait.name}', 'neg')">
                                    <span class="file-icon">‚úì</span>
                                    <span>neg.csv</span>
                                    <span style="opacity: 0.6; font-size: 11px;">(${metadata.n_examples_neg || '?'} rows) [preview ‚Üí]</span>
                                </div>

                                <div class="file-item indent-1">
                                    <span class="file-icon">üìÅ</span>
                                    <strong>activations/</strong>
                                </div>
                                <div class="file-item indent-2 clickable" onclick="previewJSON('${trait.name}', 'activations_metadata')">
                                    <span class="file-icon">‚úì</span>
                                    <span>metadata.json</span>
                                    <span style="opacity: 0.6; font-size: 11px;">(~400 B) [preview ‚Üí]</span>
                                </div>
                                <div class="file-item indent-2">
                                    <span class="file-icon">‚úì</span>
                                    <span>all_layers.pt</span>
                                    <span style="opacity: 0.6; font-size: 11px;">(~19 MB, shape: [${metadata.n_examples}, 27, 2304])</span>
                                </div>
                                <div class="file-item indent-2">
                                    <span class="file-icon">‚úì</span>
                                    <span>pos_acts.pt</span>
                                    <span style="opacity: 0.6; font-size: 11px;">(~12 MB, shape: [${metadata.n_examples_pos}, 27, 2304])</span>
                                </div>
                                <div class="file-item indent-2">
                                    <span class="file-icon">‚úì</span>
                                    <span>neg_acts.pt</span>
                                    <span style="opacity: 0.6; font-size: 11px;">(~11 MB, shape: [${metadata.n_examples_neg}, 27, 2304])</span>
                                </div>

                                <div class="file-item indent-1">
                                    <span class="file-icon">üìÅ</span>
                                    <strong>vectors/</strong>
                                    <span style="opacity: 0.6; font-size: 11px;">(216 files: 108 tensors + 108 metadata)</span>
                                </div>
                                <div class="file-item indent-2">
                                    <span class="file-icon">üìä</span>
                                    <span>4 methods √ó 27 layers:</span>
                                </div>
                                <div class="file-item indent-3">
                                    <span class="file-icon">‚úì</span>
                                    <span>mean_diff_layer[0-26].pt + metadata</span>
                                    <span style="opacity: 0.6; font-size: 11px;">(~9 KB each)</span>
                                </div>
                                <div class="file-item indent-3">
                                    <span class="file-icon">‚úì</span>
                                    <span>probe_layer[0-26].pt + metadata</span>
                                    <span style="opacity: 0.6; font-size: 11px;">(~20 KB each)</span>
                                </div>
                                <div class="file-item indent-3">
                                    <span class="file-icon">‚úì</span>
                                    <span>ica_layer[0-26].pt + metadata</span>
                                    <span style="opacity: 0.6; font-size: 11px;">(~186 KB each)</span>
                                </div>
                                <div class="file-item indent-3">
                                    <span class="file-icon">‚úì</span>
                                    <span>gradient_layer[0-26].pt + metadata</span>
                                    <span style="opacity: 0.6; font-size: 11px;">(~9 KB each, some NaN)</span>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            });

            html += `
                    </div>
                </div>
            `;

            contentArea.innerHTML = html;
        }

        // Toggle trait body visibility
        function toggleTraitBody(traitName) {
            const body = document.getElementById(`trait-body-${traitName}`);
            const header = body.previousElementSibling;
            const icon = document.getElementById(`expand-icon-${traitName}`);

            if (body.classList.contains('show')) {
                body.classList.remove('show');
                header.classList.remove('expanded');
                icon.textContent = '‚ñ∂';
            } else {
                body.classList.add('show');
                header.classList.add('expanded');
                icon.textContent = '‚ñº';
            }
        }

        // Syntax highlight JSON
        function syntaxHighlightJSON(json) {
            if (typeof json !== 'string') {
                json = JSON.stringify(json, null, 2);
            }

            json = json.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

            return json.replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, function (match) {
                let cls = 'json-number';
                if (/^"/.test(match)) {
                    if (/:$/.test(match)) {
                        cls = 'json-key';
                    } else {
                        cls = 'json-string';
                    }
                } else if (/true|false/.test(match)) {
                    cls = 'json-boolean';
                } else if (/null/.test(match)) {
                    cls = 'json-null';
                }
                return '<span class="' + cls + '">' + match + '</span>';
            });
        }

        // Preview JSON file
        async function previewJSON(traitName, type) {
            const modal = document.getElementById('preview-modal');
            const title = document.getElementById('preview-title');
            const body = document.getElementById('preview-body');

            let url, displayName;
            if (type === 'trait_definition') {
                url = `../experiments/${experimentData.name}/${traitName}/extraction/trait_definition.json`;
                displayName = 'Trait Definition';
            } else if (type === 'activations_metadata') {
                url = `../experiments/${experimentData.name}/${traitName}/extraction/activations/metadata.json`;
                displayName = 'Activations Metadata';
            }

            title.textContent = `${traitName} - ${displayName}`;
            body.innerHTML = '<div class="loading">Loading...</div>';
            modal.classList.add('show');

            try {
                const response = await fetch(url);
                const data = await response.json();
                const highlighted = syntaxHighlightJSON(data);
                body.innerHTML = `<div class="json-viewer"><pre>${highlighted}</pre></div>`;
            } catch (error) {
                body.innerHTML = '<div class="error">Failed to load JSON file</div>';
            }
        }

        // Preview CSV file
        async function previewCSV(traitName, category) {
            const modal = document.getElementById('preview-modal');
            const title = document.getElementById('preview-title');
            const body = document.getElementById('preview-body');

            const url = `../experiments/${experimentData.name}/${traitName}/extraction/responses/${category}.csv`;
            const displayName = category === 'pos' ? 'Positive Examples' : 'Negative Examples';

            title.textContent = `${traitName} - ${displayName}`;
            body.innerHTML = '<div class="loading">Loading first 10 rows...</div>';
            modal.classList.add('show');

            try {
                const response = await fetch(url);
                const text = await response.text();
                const parsed = Papa.parse(text, { header: true });
                const rows = parsed.data.slice(0, 10);

                if (rows.length === 0) {
                    body.innerHTML = '<div class="error">No data found</div>';
                    return;
                }

                let tableHTML = '<table class="csv-table"><thead><tr>';
                const headers = Object.keys(rows[0]);
                headers.forEach(h => {
                    tableHTML += `<th>${h}</th>`;
                });
                tableHTML += '</tr></thead><tbody>';

                rows.forEach(row => {
                    tableHTML += '<tr>';
                    headers.forEach(h => {
                        let value = row[h] || '';
                        // Truncate long values
                        if (value.length > 100) {
                            value = value.substring(0, 100) + '...';
                        }
                        tableHTML += `<td>${value}</td>`;
                    });
                    tableHTML += '</tr>';
                });

                tableHTML += '</tbody></table>';
                tableHTML += `<div style="margin-top: 10px; color: var(--text-secondary); font-size: 12px;">Showing first 10 rows of ${parsed.data.length} total</div>`;

                body.innerHTML = tableHTML;
            } catch (error) {
                body.innerHTML = '<div class="error">Failed to load CSV file</div>';
            }
        }

        // Close preview modal
        function closePreview() {
            const modal = document.getElementById('preview-modal');
            modal.classList.remove('show');
        }

        // Close modal when clicking outside
        document.addEventListener('click', (e) => {
            const modal = document.getElementById('preview-modal');
            if (e.target === modal) {
                closePreview();
            }
        });

        // Render overview
        function renderOverview() {
            const contentArea = document.getElementById('content-area');
            const filteredTraits = getFilteredTraits();

            let html = `
                <div class="info" style="margin-bottom: 20px;">
                    <strong>How Overview Works:</strong><br>
                    High-level summary of the experiment showing all available traits and their extraction metadata. Each trait card displays:<br>
                    ‚Ä¢ Number of examples generated (positive and negative)<br>
                    ‚Ä¢ Extraction date<br>
                    ‚Ä¢ Model used (Gemma 2B, 2304 hidden dims, 27 layers)
                </div>
                <div class="card">
                    <div class="card-title">Experiment Overview</div>
                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-label">Selected Traits</div>
                            <div class="stat-value">${filteredTraits.length}</div>
                            <div class="stat-detail">of ${experimentData.traits.length} total</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Model</div>
                            <div class="stat-value">Gemma 2B</div>
                            <div class="stat-detail">google/gemma-2-2b-it</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Hidden Dim</div>
                            <div class="stat-value">2304</div>
                            <div class="stat-detail">27 layers total</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Extraction Methods</div>
                            <div class="stat-value">4</div>
                            <div class="stat-detail">mean_diff, probe, ICA, gradient</div>
                        </div>
                    </div>
                </div>

                <div class="card">
                    <div class="card-title">Selected Traits</div>
                    ${filteredTraits.length === 0 ?
                        '<div class="info">No traits selected. Select traits in the sidebar to view them.</div>' :
                        '<div class="trait-grid">'}
            `;

            filteredTraits.forEach(trait => {
                const displayName = getDisplayName(trait.name);
                html += `
                    <div class="trait-card" data-trait="${trait.name}">
                        <div class="trait-name">${displayName}</div>
                        <div class="trait-info">
                            ${trait.metadata.n_examples || 0} examples
                            <br>Extracted: ${new Date(trait.metadata.extraction_date).toLocaleDateString()}
                        </div>
                    </div>
                `;
            });

            html += `
                    ${filteredTraits.length > 0 ? '</div>' : ''}
                </div>
            `;

            contentArea.innerHTML = html;
        }

        // Render response quality view
        async function renderResponses() {
            const contentArea = document.getElementById('content-area');
            const filteredTraits = getFilteredTraits();

            if (filteredTraits.length === 0) {
                contentArea.innerHTML = `
                    <div class="card">
                        <div class="card-title">Response Quality Analysis</div>
                        <div class="info">No traits selected. Select traits in the sidebar to view them.</div>
                    </div>
                `;
                return;
            }

            // Show loading state
            contentArea.innerHTML = '<div class="loading">Loading response quality overview...</div>';

            // Load all trait separations
            const separations = {};
            const naturalTraits = [];
            for (const trait of filteredTraits) {
                try {
                    const { posData, negData, hasScores } = await loadResponseData(
                        experimentData.name,
                        trait.name,
                        trait.responseFormat
                    );

                    if (!hasScores) {
                        // Natural extraction has no scores - track separately
                        naturalTraits.push(trait.name);
                        continue;
                    }

                    const posScores = posData.map(r => parseFloat(r.trait_score)).filter(s => !isNaN(s));
                    const negScores = negData.map(r => parseFloat(r.trait_score)).filter(s => !isNaN(s));
                    const posAvg = posScores.reduce((a, b) => a + b, 0) / posScores.length;
                    const negAvg = negScores.reduce((a, b) => a + b, 0) / negScores.length;

                    separations[trait.name] = {
                        separation: posAvg - negAvg,
                        posAvg,
                        negAvg,
                        posCount: posData.length,
                        negCount: negData.length
                    };
                } catch (e) {
                    console.error(`Failed to load ${trait.name}:`, e);
                }
            }

            // Render overview
            let html = `
                <div class="info" style="margin-bottom: 20px;">
                    <strong>How Response Quality Is Calculated:</strong><br>
                    For each trait, we measure how well the LLM judge scored positive vs negative examples:<br>
                    ‚Ä¢ <strong>Separation</strong> = Avg(Positive Scores) - Avg(Negative Scores)<br>
                    ‚Ä¢ <strong>Positive Scores</strong> - Trait scores for high-trait examples (e.g., refusing harmful requests)<br>
                    ‚Ä¢ <strong>Negative Scores</strong> - Trait scores for low-trait examples (e.g., answering benign questions)<br>
                    ‚Ä¢ <strong>Quality Thresholds:</strong> >40 = Excellent, >20 = Good, <20 = Weak<br>
                    <strong>Note:</strong> Only applies to instruction-based extraction (natural extraction has no judge scores).
                </div>
                <div class="card">
                    <div class="card-title">Response Quality Overview</div>
                    <table style="width: 100%; border-collapse: collapse; margin-top: 15px;">
                        <thead>
                            <tr style="border-bottom: 2px solid var(--border-color);">
                                <th style="text-align: left; padding: 10px; color: var(--text-secondary); font-weight: 600;">Trait</th>
                                <th style="text-align: right; padding: 10px; color: var(--text-secondary); font-weight: 600;">Separation (Mean)</th>
                                <th style="text-align: right; padding: 10px; color: var(--text-secondary); font-weight: 600;">Pos Mean</th>
                                <th style="text-align: right; padding: 10px; color: var(--text-secondary); font-weight: 600;">Neg Mean</th>
                                <th style="text-align: center; padding: 10px; color: var(--text-secondary); font-weight: 600;">Quality</th>
                            </tr>
                        </thead>
                        <tbody>
            `;

            Object.keys(separations).sort((a, b) => separations[b].separation - separations[a].separation).forEach(traitName => {
                const data = separations[traitName];
                const displayName = getDisplayName(traitName);
                const quality = data.separation > 40 ? 'Excellent' : data.separation > 20 ? 'Good' : 'Weak';
                const qualityColor = data.separation > 40 ? '#28a745' : data.separation > 20 ? '#ffc107' : '#dc3545';

                html += `
                    <tr style="border-bottom: 1px solid var(--border-color); cursor: pointer; transition: background 0.2s;"
                        onclick="loadTraitResponses('${traitName}')"
                        onmouseover="this.style.background='var(--bg-tertiary)'"
                        onmouseout="this.style.background='transparent'">
                        <td style="padding: 10px; color: var(--text-primary);">${displayName}</td>
                        <td style="padding: 10px; text-align: right; font-weight: 600; color: var(--text-primary);">${data.separation.toFixed(1)}</td>
                        <td style="padding: 10px; text-align: right; color: var(--text-secondary);">${data.posAvg.toFixed(1)}</td>
                        <td style="padding: 10px; text-align: right; color: var(--text-secondary);">${data.negAvg.toFixed(1)}</td>
                        <td style="padding: 10px; text-align: center;">
                            <span style="padding: 4px 8px; border-radius: 4px; font-size: 12px; font-weight: 600; background: ${qualityColor}20; color: ${qualityColor};">
                                ${quality}
                            </span>
                        </td>
                    </tr>
                `;
            });

            html += `
                        </tbody>
                    </table>
            `;

            // Add note about natural traits if any were excluded
            if (naturalTraits.length > 0) {
                html += `
                    <div class="info" style="margin-top: 20px; background: var(--bg-secondary); border-left: 4px solid #ffc107;">
                        <strong>Note:</strong> ${naturalTraits.length} natural extraction trait${naturalTraits.length > 1 ? 's' : ''} excluded from this view (no judge scores available):<br>
                        ${naturalTraits.map(t => getDisplayName(t)).join(', ')}
                    </div>
                `;
            }

            html += `
                    <div id="response-details"></div>
                </div>
            `;

            contentArea.innerHTML = html;
        }

        // Helper function to load response data in correct format (csv or json)
        async function loadResponseData(experimentName, traitName, responseFormat) {
            const extension = responseFormat || 'csv'; // Default to csv for backwards compatibility
            const [posResponse, negResponse] = await Promise.all([
                fetch(`../experiments/${experimentName}/${traitName}/extraction/responses/pos.${extension}`),
                fetch(`../experiments/${experimentName}/${traitName}/extraction/responses/neg.${extension}`)
            ]);

            if (!posResponse.ok || !negResponse.ok) {
                throw new Error(`Response files not found for ${traitName}`);
            }

            if (extension === 'json') {
                // JSON format (natural extraction)
                // Format: [{question, answer, full_text}, ...]
                // No trait_score available - natural extraction is unsupervised
                const posData = await posResponse.json();
                const negData = await negResponse.json();

                // Convert to format expected by rest of code
                return {
                    posData: posData.map(item => ({
                        prompt: item.question || '',
                        response: item.answer || '',
                        trait_score: null // Natural extraction has no scores
                    })),
                    negData: negData.map(item => ({
                        prompt: item.question || '',
                        response: item.answer || '',
                        trait_score: null // Natural extraction has no scores
                    })),
                    hasScores: false
                };
            } else {
                // CSV format (instruction-based extraction)
                const [posText, negText] = await Promise.all([
                    posResponse.text(),
                    negResponse.text()
                ]);
                return {
                    posData: Papa.parse(posText, { header: true }).data,
                    negData: Papa.parse(negText, { header: true }).data,
                    hasScores: true
                };
            }
        }

        // Load trait responses
        async function loadTraitResponses(traitName) {
            const detailsDiv = document.getElementById('response-details');
            detailsDiv.innerHTML = '<div class="loading">Loading response data...</div>';

            try {
                const trait = experimentData.traits.find(t => t.name === traitName);
                const { posData, negData } = await loadResponseData(
                    experimentData.name,
                    traitName,
                    trait?.responseFormat || 'csv'
                );

                renderResponseAnalysis(traitName, posData, negData);
            } catch (error) {
                console.error('Error loading responses:', error);
                detailsDiv.innerHTML = '<div class="error">Failed to load response data</div>';
            }
        }

        // Render response analysis
        function renderResponseAnalysis(traitName, posData, negData) {
            const detailsDiv = document.getElementById('response-details');
            const displayName = getDisplayName(traitName);

            // Calculate statistics (if scores available)
            const posScores = posData.map(r => parseFloat(r.trait_score)).filter(s => !isNaN(s));
            const negScores = negData.map(r => parseFloat(r.trait_score)).filter(s => !isNaN(s));

            const hasScores = posScores.length > 0 && negScores.length > 0;
            const posAvg = hasScores ? posScores.reduce((a, b) => a + b, 0) / posScores.length : null;
            const negAvg = hasScores ? negScores.reduce((a, b) => a + b, 0) / negScores.length : null;
            const separation = hasScores ? posAvg - negAvg : null;

            // Create histogram
            const histTrace1 = {
                x: posScores,
                type: 'histogram',
                name: 'Positive',
                marker: { color: '#28a745' },
                opacity: 0.7,
                nbinsx: 20
            };

            const histTrace2 = {
                x: negScores,
                type: 'histogram',
                name: 'Negative',
                marker: { color: '#dc3545' },
                opacity: 0.7,
                nbinsx: 20
            };

            let html = `
                <div style="margin-top: 30px;">
                    <div class="card-title">${displayName} - Response Quality</div>
            `;

            if (hasScores) {
                // Show stats and histogram for instruction-based extraction
                html += `
                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-label">Positive Examples</div>
                            <div class="stat-value">${posData.length}</div>
                            <div class="stat-detail">Avg score: ${posAvg.toFixed(1)}</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Negative Examples</div>
                            <div class="stat-value">${negData.length}</div>
                            <div class="stat-detail">Avg score: ${negAvg.toFixed(1)}</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Separation</div>
                            <div class="stat-value">${separation.toFixed(1)}</div>
                            <div class="stat-detail">${separation > 40 ? 'Excellent' : separation > 20 ? 'Good' : 'Weak'}</div>
                        </div>
                    </div>

                    <div id="score-histogram" style="margin-top: 20px;"></div>

                    <div style="margin-top: 20px;">
                        <h3 style="margin-bottom: 10px;">Sample Responses</h3>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                            <div>
                                <strong>High ${displayName} (Positive)</strong>
                                ${posData.slice(0, 3).map(r => `
                                    <div class="response-preview">
                                        <strong>Q:</strong> ${r.question || r.prompt || 'N/A'}<br>
                                        <strong>A:</strong> ${(r.response || 'N/A').substring(0, 150)}...
                                        <span class="score-badge score-high">${parseFloat(r.trait_score).toFixed(1)}</span>
                                    </div>
                                `).join('')}
                            </div>
                            <div>
                                <strong>Low ${displayName} (Negative)</strong>
                                ${negData.slice(0, 3).map(r => `
                                    <div class="response-preview">
                                        <strong>Q:</strong> ${r.question || r.prompt || 'N/A'}<br>
                                        <strong>A:</strong> ${(r.response || 'N/A').substring(0, 150)}...
                                        <span class="score-badge score-low">${parseFloat(r.trait_score).toFixed(1)}</span>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    </div>
                `;
            } else {
                // Natural extraction - no scores, just show examples
                html += `
                    <div class="info" style="margin-bottom: 20px;">
                        <strong>Natural Extraction:</strong> This trait was extracted using natural elicitation (no instructions, no judge scores).
                        Showing ${posData.length} positive and ${negData.length} negative examples.
                    </div>

                    <div style="margin-top: 20px;">
                        <h3 style="margin-bottom: 10px;">Sample Responses</h3>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                            <div>
                                <strong>High ${displayName} Scenarios (Positive)</strong>
                                ${posData.slice(0, 5).map(r => `
                                    <div class="response-preview">
                                        <strong>Q:</strong> ${r.prompt || 'N/A'}<br>
                                        <strong>A:</strong> ${(r.response || 'N/A').substring(0, 200)}...
                                    </div>
                                `).join('')}
                            </div>
                            <div>
                                <strong>Low ${displayName} Scenarios (Negative)</strong>
                                ${negData.slice(0, 5).map(r => `
                                    <div class="response-preview">
                                        <strong>Q:</strong> ${r.prompt || 'N/A'}<br>
                                        <strong>A:</strong> ${(r.response || 'N/A').substring(0, 200)}...
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    </div>
                `;
            }

            html += `
                </div>
            `;

            detailsDiv.innerHTML = html;

            // Render histogram (only if scores available)
            if (hasScores) {
                Plotly.newPlot('score-histogram', [histTrace1, histTrace2], getPlotlyLayout({
                    title: 'Trait Score Distribution',
                    xaxis: { title: 'Trait Score (0-100)' },
                    yaxis: { title: 'Count' },
                    barmode: 'overlay',
                    height: 400
                }), { displayModeBar: false });
            }
        }

        // Render vector analysis view
        async function renderVectors() {
            const contentArea = document.getElementById('content-area');
            const filteredTraits = getFilteredTraits();

            if (filteredTraits.length === 0) {
                contentArea.innerHTML = `
                    <div class="card">
                        <div class="card-title">Vector Analysis</div>
                        <div class="info">No traits selected. Select traits in the sidebar to view them.</div>
                    </div>
                `;
                return;
            }

            // Show loading state
            contentArea.innerHTML = '<div class="loading">Loading vector analysis overview...</div>';

            // Load all vector metadata
            const vectorMetrics = {};
            for (const trait of filteredTraits) {
                try {
                    const methods = ['mean_diff', 'probe', 'ica', 'gradient'];
                    const layers = Array.from({ length: 27 }, (_, i) => i);
                    const vectorData = {};

                    for (const method of methods) {
                        vectorData[method] = {};
                        for (const layer of layers) {
                            try {
                                const response = await fetch(
                                    `../experiments/${experimentData.name}/${trait.name}/extraction/vectors/${method}_layer${layer}_metadata.json`
                                );
                                if (response.ok) {
                                    vectorData[method][layer] = await response.json();
                                }
                            } catch (e) {
                                // Vector doesn't exist
                            }
                        }
                    }

                    // Calculate best layer for each method
                    const best = {};
                    methods.forEach(method => {
                        let bestLayer = -1;
                        let bestNorm = -Infinity;
                        layers.forEach(layer => {
                            if (vectorData[method][layer]) {
                                const norm = vectorData[method][layer].vector_norm;
                                if (!isNaN(norm) && norm > bestNorm) {
                                    bestNorm = norm;
                                    bestLayer = layer;
                                }
                            }
                        });
                        best[method] = { layer: bestLayer, norm: bestNorm };
                    });

                    vectorMetrics[trait.name] = { vectorData, best };
                } catch (e) {
                    console.error(`Failed to load ${trait.name}:`, e);
                }
            }

            // Render overview with mini heatmaps
            let html = `
                <div class="info" style="margin-bottom: 20px;">
                    <strong>How Vector Analysis Works:</strong><br>
                    Compare 4 different vector extraction methods across all 27 layers:<br>
                    ‚Ä¢ <strong>mean_diff</strong>: ||avg(pos_acts) - avg(neg_acts)||‚ÇÇ - Simple difference of means (unnormalized, norm ‚âà50-100)<br>
                    ‚Ä¢ <strong>probe</strong>: ||learned_weights||‚ÇÇ - Linear classifier weights (L2-normalized, norm ‚âà1-5)<br>
                    ‚Ä¢ <strong>ica</strong>: ||independent_component||‚ÇÇ - Independent Component Analysis (variable norm)<br>
                    ‚Ä¢ <strong>gradient</strong>: ||‚àáloss_wrt_activations||‚ÇÇ - Gradient-optimized (unit norm ‚âà1.0)<br>
                    <strong>Visualization:</strong> Each method is normalized independently (0-100% of that method's max) so all are visible.<br>
                    <strong>Interpretation:</strong> Heatmap shows which layers are strongest <em>within each method</em>, not cross-method comparisons.<br>
                    <strong>Note:</strong> Vectors extracted from token-averaged activations.
                </div>
                <div class="card">
                    <div class="card-title">Vector Analysis Overview</div>
                    <div class="info">
                        Vector norms across 27 layers and 4 extraction methods.
                        <strong>Note:</strong> Vectors extracted from token-averaged activations.
                        Click a trait to view detailed heatmap.
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(400px, 1fr)); gap: 20px; margin-top: 20px;">
            `;

            filteredTraits.forEach(trait => {
                const displayName = getDisplayName(trait.name);
                const metrics = vectorMetrics[trait.name];
                if (!metrics) return;

                const best = metrics.best;
                const bestMethod = Object.keys(best).reduce((a, b) =>
                    best[a].norm > best[b].norm ? a : b
                );

                html += `
                    <div style="background: var(--bg-secondary); padding: 15px; border-radius: 8px; border: 2px solid var(--border-color); cursor: pointer; transition: all 0.2s;"
                         onclick="loadVectorAnalysis('${trait.name}')"
                         onmouseover="this.style.borderColor='var(--primary-color)'"
                         onmouseout="this.style.borderColor='var(--border-color)'">
                        <div style="font-weight: 600; margin-bottom: 10px; color: var(--text-primary);">${displayName}</div>
                        <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 10px;">
                            Best: ${bestMethod.replace(/_/g, ' ')} @ layer ${best[bestMethod].layer} (norm: ${best[bestMethod].norm.toFixed(2)})
                        </div>
                        <div id="mini-heatmap-${trait.name}" style="height: 200px;"></div>
                    </div>
                `;
            });

            html += `
                    </div>
                    <div id="vector-details"></div>
                </div>
            `;

            contentArea.innerHTML = html;

            // Render mini heatmaps (normalized per method)
            filteredTraits.forEach(trait => {
                const metrics = vectorMetrics[trait.name];
                if (!metrics) return;

                const methods = Object.keys(metrics.vectorData);
                const layers = Array.from({ length: 27 }, (_, i) => i);

                // Normalize each method independently (0-100% of that method's max)
                const normalizedData = layers.map(layer => {
                    return methods.map(method => {
                        const metadata = metrics.vectorData[method][layer];
                        return metadata ? metadata.vector_norm : null;
                    });
                });

                // Find max for each method
                const maxPerMethod = methods.map((method, methodIdx) => {
                    const values = normalizedData.map(row => row[methodIdx]).filter(v => v !== null);
                    return values.length > 0 ? Math.max(...values) : 1;
                });

                // Normalize each column by its max
                const heatmapData = normalizedData.map(row => {
                    return row.map((value, methodIdx) => {
                        if (value === null) return null;
                        return (value / maxPerMethod[methodIdx]) * 100; // Percentage of method's max
                    });
                });

                const trace = {
                    z: heatmapData,
                    x: methods.map(m => m.replace(/_/g, ' ')),
                    y: layers,
                    type: 'heatmap',
                    colorscale: 'Viridis',
                    showscale: false,
                    hovertemplate: 'Method: %{x}<br>Layer %{y}<br>Strength: %{z:.1f}%<extra></extra>',
                    zmin: 0,
                    zmax: 100
                };

                Plotly.newPlot(`mini-heatmap-${trait.name}`, [trace], getPlotlyLayout({
                    margin: { l: 30, r: 5, t: 5, b: 40 },
                    xaxis: { title: '', tickangle: -45 },
                    yaxis: { title: '', autorange: 'reversed' },
                    height: 200
                }), { displayModeBar: false });
            });
        }

        // Load vector analysis
        async function loadVectorAnalysis(traitName) {
            const detailsDiv = document.getElementById('vector-details');
            detailsDiv.innerHTML = '<div class="loading">Loading vector metadata...</div>';

            try {
                const methods = ['mean_diff', 'probe', 'ica', 'gradient'];
                const layers = Array.from({ length: 27 }, (_, i) => i);

                const vectorData = {};

                for (const method of methods) {
                    vectorData[method] = {};
                    for (const layer of layers) {
                        try {
                            const response = await fetch(
                                `../experiments/${experimentData.name}/${traitName}/extraction/vectors/${method}_layer${layer}_metadata.json`
                            );
                            if (response.ok) {
                                vectorData[method][layer] = await response.json();
                            }
                        } catch (e) {
                            // Vector doesn't exist
                        }
                    }
                }

                renderVectorHeatmap(traitName, vectorData);
            } catch (error) {
                console.error('Error loading vectors:', error);
                detailsDiv.innerHTML = '<div class="error">Failed to load vector data</div>';
            }
        }

        // Render vector heatmap (normalized per method)
        function renderVectorHeatmap(traitName, vectorData) {
            const detailsDiv = document.getElementById('vector-details');
            const displayName = getDisplayName(traitName);

            const methods = Object.keys(vectorData);
            const layers = Array.from({ length: 27 }, (_, i) => i);

            // Collect raw norms
            const rawData = layers.map(layer => {
                return methods.map(method => {
                    const metadata = vectorData[method][layer];
                    return metadata ? metadata.vector_norm : null;
                });
            });

            // Find max for each method
            const maxPerMethod = methods.map((method, methodIdx) => {
                const values = rawData.map(row => row[methodIdx]).filter(v => v !== null);
                return values.length > 0 ? Math.max(...values) : 1;
            });

            // Normalize each column by its max (0-100%)
            const normalizedData = rawData.map(row => {
                return row.map((value, methodIdx) => {
                    if (value === null) return null;
                    return (value / maxPerMethod[methodIdx]) * 100;
                });
            });

            // Also store raw values for hover
            const customData = rawData.map((row, layerIdx) => {
                return row.map((value, methodIdx) => {
                    return {
                        raw: value,
                        max: maxPerMethod[methodIdx],
                        layer: layers[layerIdx],
                        method: methods[methodIdx]
                    };
                });
            });

            const trace = {
                z: normalizedData,
                x: methods.map(m => m.replace(/_/g, ' ').toUpperCase()),
                y: layers,
                type: 'heatmap',
                colorscale: 'Viridis',
                hovertemplate: 'Method: %{x}<br>Layer %{y}<br>Strength: %{z:.1f}% of max<br>Raw norm: %{customdata.raw:.2f}<br>Max for method: %{customdata.max:.2f}<extra></extra>',
                customdata: customData,
                zmin: 0,
                zmax: 100,
                colorbar: {
                    title: '% of Max',
                    titleside: 'right'
                }
            };

            let html = `
                <div style="margin-top: 30px;">
                    <div class="card-title">${displayName} - Vector Strength by Method & Layer</div>
                    <div class="info" style="margin-top: 10px; font-size: 13px;">
                        Each method normalized independently (0-100% of that method's max across layers).
                        This shows which layers are strongest for each method, not cross-method comparisons.
                    </div>
                    <div id="vector-heatmap" style="margin-top: 20px;"></div>
                </div>
            `;

            detailsDiv.innerHTML = html;

            Plotly.newPlot('vector-heatmap', [trace], getPlotlyLayout({
                title: 'Normalized Vector Strength (% of Method Max)',
                xaxis: { title: 'Extraction Method' },
                yaxis: { title: 'Layer', autorange: 'reversed' },
                height: 600
            }), { displayModeBar: false });
        }

        // Render monitoring view
        async function renderMonitoring() {
            const contentArea = document.getElementById('content-area');
            const filteredTraits = getFilteredTraits();

            if (filteredTraits.length === 0) {
                contentArea.innerHTML = `
                    <div class="card">
                        <div class="card-title">All Layers</div>
                        <div class="info">Select at least one trait to view trajectories</div>
                    </div>
                `;
                return;
            }

            // Try to find Tier 2 data for the first selected trait
            const trait = filteredTraits[0];
            const tier2Dir = `../experiments/${experimentData.name}/${trait.name}/inference/residual_stream_activations/`;

            // Try to load prompt_0.json
            try {
                const fetchPath = `${tier2Dir}prompt_0.json`;
                console.log('Fetching trajectory data from:', fetchPath);
                const response = await fetch(fetchPath);
                console.log('Fetch response status:', response.status, response.statusText);
                if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);

                const data = await response.json();
                console.log('Trajectory data loaded successfully:', data);
                renderTier2Data(trait, data);
            } catch (error) {
                // No data yet - show instructions
                console.error('Failed to load trajectory data:', error);
                renderTier2Instructions(trait);
            }
        }

        function renderTier2Instructions(trait) {
            const contentArea = document.getElementById('content-area');
            contentArea.innerHTML = `
                <div class="info" style="margin-bottom: 20px;">
                    <strong>How All Layers Works:</strong><br>
                    Captures how trait strength evolves through ALL layers during generation:<br>
                    ‚Ä¢ <strong>Projection</strong> = activation ¬∑ trait_vector (dot product at each token position)<br>
                    ‚Ä¢ Captures all 27 layers √ó 3 sublayers (pre-attn, post-attn, post-mlp) = 81 checkpoints<br>
                    ‚Ä¢ Shows trait evolution during both prompt encoding AND response generation<br>
                    ‚Ä¢ <strong>Heatmap</strong>: Rows = layers, Columns = tokens, Color = trait score<br>
                    Reveals which layers activate for the trait and how it changes per token.
                </div>
                <div class="card">
                    <div class="card-title">All Layers: ${getDisplayName(trait.name)}</div>

                    <div class="info" style="margin-bottom: 20px;">
                        <strong>‚ö†Ô∏è No trajectory data available for ${trait.name}</strong>
                    </div>

                    <div style="background: var(--bg-tertiary); padding: 20px; border-radius: 8px;">
                        <h3 style="color: var(--text-primary); margin-bottom: 15px;">Generate Trajectory Data</h3>
                        <p style="color: var(--text-secondary); margin-bottom: 15px;">
                            Capture per-token projections at all 81 checkpoints (27 layers √ó 3 sublayers):
                        </p>
                        <pre style="background: var(--bg-primary); color: var(--text-primary); padding: 15px; border-radius: 4px; margin: 15px 0; overflow-x: auto; border: 1px solid var(--border-color);">python inference/capture_tier2.py \\
  --experiment ${experimentData.name} \\
  --trait ${trait.name} \\
  --prompts "What is the capital of France?" \\
  --save-json</pre>
                        <p style="color: var(--text-secondary); margin-top: 15px;">
                            The <code style="background: var(--bg-primary); padding: 2px 6px; border-radius: 3px;">--save-json</code> flag creates visualization-friendly JSON files alongside the .pt files.
                        </p>
                        <p style="color: var(--text-tertiary); font-size: 13px; margin-top: 10px;">
                            This captures how ${getDisplayName(trait.name)} evolves through ALL layers during both prompt encoding and response generation.
                        </p>
                    </div>
                </div>
            `;
        }

        function renderTier2Data(trait, data) {
            const contentArea = document.getElementById('content-area');

            try {
                const promptProj = data.projections.prompt;  // [n_tokens, n_layers, 3]
                const responseProj = data.projections.response;
                console.log('Prompt projections shape:', promptProj.length, 'tokens x', promptProj[0].length, 'layers x', promptProj[0][0].length, 'sublayers');
                console.log('Response projections shape:', responseProj.length, 'tokens x', responseProj[0].length, 'layers x', responseProj[0][0].length, 'sublayers');

            // Combine prompt and response projections and tokens
            let allTokens = [...data.prompt.tokens, ...data.response.tokens];
            let allProj = [...promptProj, ...responseProj];
            let nPromptTokens = data.prompt.n_tokens;

            // Skip first token if it's a BOS token (anomalous activations)
            const skipFirst = allTokens[0].includes('bos') || allTokens[0].includes('BOS') || allTokens[0] === '<s>';
            if (skipFirst) {
                console.log(`Skipping BOS token: ${allTokens[0]}`);
                allTokens = allTokens.slice(1);
                allProj = allProj.slice(1);
                nPromptTokens = nPromptTokens - 1;
            }

            const nTotalTokens = allTokens.length;

            contentArea.innerHTML = `
                <div class="info" style="margin-bottom: 20px;">
                    <strong>How All Layers Works:</strong><br>
                    Captures how trait strength evolves through ALL layers during generation:<br>
                    ‚Ä¢ <strong>Projection</strong> = activation ¬∑ trait_vector (dot product at each token position)<br>
                    ‚Ä¢ Captures all 27 layers √ó 3 sublayers (pre-attn, post-attn, post-mlp) = 81 checkpoints<br>
                    ‚Ä¢ Shows trait evolution during both prompt encoding AND response generation<br>
                    ‚Ä¢ <strong>Heatmap</strong>: Rows = layers, Columns = tokens, Color = trait score<br>
                    Reveals which layers activate for the trait and how it changes per token.
                </div>
                <div class="card">
                    <div class="card-title">All Layers: ${getDisplayName(trait.name)}</div>

                    <div style="background: var(--bg-tertiary); padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                        <div style="margin-bottom: 10px;">
                            <div style="color: var(--text-secondary); font-size: 13px; margin-bottom: 5px;">Full Conversation</div>
                            <div style="color: var(--text-primary); font-size: 16px; font-weight: 600;">${data.prompt.text} ${data.response.text}</div>
                        </div>
                        <div style="color: var(--text-secondary); font-size: 13px;">
                            ${data.prompt.n_tokens} prompt tokens + ${data.response.n_tokens} response tokens = ${nTotalTokens} total
                        </div>
                    </div>

                    <!-- Unified slider control -->
                    <div style="background: var(--bg-tertiary); padding: 20px; border-radius: 8px; margin-bottom: 30px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <label style="color: var(--text-secondary); font-weight: 600;">
                                Token Position: <span id="unified-slider-value" style="color: var(--primary-color);">0</span> / ${nTotalTokens - 1}
                            </label>
                            <span style="color: var(--text-secondary); font-size: 12px;">
                                Token: "<span id="unified-slider-token" style="font-weight: 600;">${allTokens[0]}</span>"
                                <span id="unified-slider-phase" style="color: var(--text-tertiary); margin-left: 10px;">[Prompt]</span>
                            </span>
                        </div>
                        <input type="range" id="unified-slider" min="0" max="${nTotalTokens - 1}" value="0"
                               style="width: 100%; height: 3px; border-radius: 2px; background: var(--border-color);">
                    </div>

                    <div id="trajectory-heatmap" style="margin-bottom: 50px;"></div>
                    <div id="attention-viewer"></div>
                </div>
            `;

            // Render combined trajectory heatmap with separator line
            renderCombinedTrajectoryHeatmap('trajectory-heatmap', allProj, allTokens, nPromptTokens);

            // Render attention viewer if data available
            if (data.attention_weights) {
                renderAttentionViewer('attention-viewer', data, allTokens, nPromptTokens, skipFirst);
            }

            // Setup unified slider control
            setupUnifiedSlider(allTokens, nPromptTokens, nTotalTokens, skipFirst);
            } catch (error) {
                console.error('Error rendering trajectory data:', error);
                contentArea.innerHTML = `<div class="card"><div class="card-title">Error</div><div class="info">Failed to render trajectory data: ${error.message}</div></div>`;
            }
        }

        function renderCombinedTrajectoryHeatmap(divId, projections, tokens, nPromptTokens) {
            // projections: [n_tokens, n_layers, 3_sublayers]
            // We'll show layer-averaged (average over 3 sublayers)

            const nTokens = projections.length;
            const nLayers = projections[0].length;  // Dynamically get number of layers
            console.log(`Rendering combined trajectory heatmap for ${nTokens} tokens x ${nLayers} layers (${nPromptTokens} prompt + ${nTokens - nPromptTokens} response)`);

            // Average over sublayers to get [n_tokens, n_layers]
            const layerAvg = [];
            for (let t = 0; t < nTokens; t++) {
                layerAvg[t] = [];
                for (let l = 0; l < nLayers; l++) {
                    const avg = (projections[t][l][0] + projections[t][l][1] + projections[t][l][2]) / 3;
                    layerAvg[t][l] = avg;
                }
            }

            // Transpose for heatmap: [n_layers, n_tokens]
            const heatmapData = [];
            for (let l = 0; l < nLayers; l++) {
                heatmapData[l] = [];
                for (let t = 0; t < nTokens; t++) {
                    heatmapData[l][t] = layerAvg[t][l];
                }
            }

            // Create shapes array for separator line and current token highlight
            const shapes = [
                // Vertical line separating prompt and response
                {
                    type: 'line',
                    xref: 'x',
                    yref: 'paper',
                    x0: nPromptTokens - 0.5,
                    x1: nPromptTokens - 0.5,
                    y0: 0,
                    y1: 1,
                    line: {
                        color: 'rgba(255, 255, 255, 0.5)',
                        width: 2,
                        dash: 'dash'
                    }
                },
                // Highlight for current token (will be updated by slider)
                {
                    type: 'rect',
                    xref: 'x',
                    yref: 'paper',
                    x0: -0.5,
                    x1: 0.5,
                    y0: 0,
                    y1: 1,
                    fillcolor: 'rgba(74, 158, 255, 0.2)',
                    line: { width: 0 },
                    name: 'token-highlight'  // ID for updating
                }
            ];

            const data = [{
                z: heatmapData,
                x: tokens,
                y: Array.from({length: nLayers}, (_, i) => `L${i}`),
                type: 'heatmap',
                colorscale: 'RdBu',
                zmid: 0,
                hovertemplate: 'Token: %{x}<br>Layer: %{y}<br>Score: %{z:.2f}<extra></extra>'
            }];

            const layout = getPlotlyLayout({
                title: 'Trait Trajectory Across All Layers',
                xaxis: {
                    title: 'Tokens (Prompt | Response)',
                    tickangle: -45
                },
                yaxis: {
                    title: 'Layer',
                    autorange: 'reversed'
                },
                shapes: shapes,
                height: 600
            });

            Plotly.newPlot(divId, data, layout, {displayModeBar: false});
        }

        function renderAttentionViewer(divId, data, allTokens, nPromptTokens, skipFirst) {
            // Get number of layers
            const nLayers = Object.keys(data.attention_weights.prompt).length;
            const skipOffset = skipFirst ? 1 : 0;

            const html = `
                <div style="border-top: 2px solid var(--border-color); padding-top: 30px; margin-top: 30px;">
                    <h2 style="color: var(--text-primary); margin-bottom: 15px;">Attention Patterns</h2>
                    <p style="color: var(--text-secondary); margin-bottom: 20px;">
                        Shows how the selected token (controlled by slider above) attends to previous tokens across all layers. Use the unified slider to explore different tokens.
                    </p>
                    <div id="attention-heatmap"></div>
                </div>
            `;

            document.getElementById(divId).innerHTML = html;

            // Function to render attention heatmap for a specific token
            window.updateAttentionHeatmap = function(tokenIdx) {
                // Adjust index if we skipped BOS token
                const actualIdx = tokenIdx + skipOffset;

                // Get attention data for this token
                let attnData;  // [n_layers, n_context]
                let contextTokens;

                if (actualIdx < data.prompt.n_tokens) {
                    // Prompt token - use prompt attention
                    attnData = [];
                    for (let layer = 0; layer < nLayers; layer++) {
                        const layerAttn = data.attention_weights.prompt[`layer_${layer}`];
                        attnData.push(layerAttn[actualIdx]);  // This token's attention to all previous tokens
                    }
                    // Skip BOS in context tokens too
                    contextTokens = data.prompt.tokens.slice(skipOffset, actualIdx + 1);
                } else {
                    // Response token - use response attention
                    const responseIdx = actualIdx - data.prompt.n_tokens;
                    attnData = [];
                    for (let layer = 0; layer < nLayers; layer++) {
                        const layerAttn = data.attention_weights.response[responseIdx][`layer_${layer}`];
                        attnData.push(layerAttn);
                    }
                    contextTokens = allTokens.slice(0, tokenIdx + 1);
                }

                // Create heatmap
                const trace = {
                    z: attnData,
                    x: contextTokens,
                    y: Array.from({length: nLayers}, (_, i) => `L${i}`),
                    type: 'heatmap',
                    colorscale: 'Viridis',
                    hovertemplate: 'Context Token: %{x}<br>Layer: %{y}<br>Attention: %{z:.4f}<extra></extra>',
                    colorbar: {
                        title: 'Attention Weight'
                    }
                };

                const layout = getPlotlyLayout({
                    title: `Attention Pattern for Token "${allTokens[tokenIdx]}" (Position ${tokenIdx})`,
                    xaxis: {
                        title: 'Context Tokens (what this token attends to)',
                        tickangle: -45,
                        side: 'bottom'
                    },
                    yaxis: {
                        title: 'Layer',
                        autorange: 'reversed'
                    },
                    height: 500
                });

                Plotly.newPlot('attention-heatmap', [trace], layout, { displayModeBar: false });
            }

            // Initialize with first token
            window.updateAttentionHeatmap(0);
        }

        function setupUnifiedSlider(allTokens, nPromptTokens, nTotalTokens, skipFirst) {
            const slider = document.getElementById('unified-slider');
            // Note: allTokens already has BOS removed if skipFirst=true, so we don't need skipOffset here

            // Function to update all visualizations when slider moves
            function updateAllVisualizations(tokenIdx) {
                // Update slider labels
                document.getElementById('unified-slider-value').textContent = tokenIdx;
                document.getElementById('unified-slider-token').textContent = allTokens[tokenIdx];

                // Update phase indicator (Prompt vs Response)
                const phase = tokenIdx < nPromptTokens ? '[Prompt]' : '[Response]';
                document.getElementById('unified-slider-phase').textContent = phase;

                // Update trajectory heatmap highlight
                const shapes = [
                    // Separator line (unchanged)
                    {
                        type: 'line',
                        xref: 'x',
                        yref: 'paper',
                        x0: nPromptTokens - 0.5,
                        x1: nPromptTokens - 0.5,
                        y0: 0,
                        y1: 1,
                        line: {
                            color: 'rgba(255, 255, 255, 0.5)',
                            width: 2,
                            dash: 'dash'
                        }
                    },
                    // Current token highlight (updated position)
                    {
                        type: 'rect',
                        xref: 'x',
                        yref: 'paper',
                        x0: tokenIdx - 0.5,
                        x1: tokenIdx + 0.5,
                        y0: 0,
                        y1: 1,
                        fillcolor: 'rgba(74, 158, 255, 0.2)',
                        line: { width: 0 }
                    }
                ];

                Plotly.relayout('trajectory-heatmap', { shapes: shapes });

                // Update attention heatmap if available
                if (window.updateAttentionHeatmap) {
                    window.updateAttentionHeatmap(tokenIdx);
                }
            }

            // Add slider event listener
            slider.addEventListener('input', (e) => {
                updateAllVisualizations(parseInt(e.target.value));
            });

            // Initialize at position 0
            updateAllVisualizations(0);
        }

        // Render Layer Deep Dive view
        async function renderLayerDeepDive() {
            const contentArea = document.getElementById('content-area');
            const filteredTraits = getFilteredTraits();

            if (filteredTraits.length === 0) {
                contentArea.innerHTML = `
                    <div class="card">
                        <div class="card-title">Layer Deep Dive</div>
                        <div class="info">Select at least one trait to view layer internals</div>
                    </div>
                `;
                return;
            }

            // Try to find Tier 3 data for the first selected trait
            const trait = filteredTraits[0];
            const tier3Dir = `../experiments/${experimentData.name}/${trait.name}/inference/layer_internal_states/`;

            // Try to load prompt_0_layer16.json (default layer)
            try {
                const response = await fetch(`${tier3Dir}prompt_0_layer16.json`);
                if (!response.ok) throw new Error('No data found');

                const data = await response.json();
                renderTier3Data(trait, data);
            } catch (error) {
                // No data yet - show instructions
                renderTier3Instructions(trait);
            }
        }

        function renderTier3Instructions(trait) {
            const contentArea = document.getElementById('content-area');
            contentArea.innerHTML = `
                <div class="info" style="margin-bottom: 20px;">
                    <strong>How Layer Deep Dive Works:</strong><br>
                    Captures complete layer internals for ONE specific layer to identify which neurons drive the trait:<br>
                    ‚Ä¢ <strong>Q/K/V Projections</strong> - Query, Key, Value attention inputs<br>
                    ‚Ä¢ <strong>Attention Heads</strong> - Per-head attention patterns<br>
                    ‚Ä¢ <strong>MLP Neurons</strong> - All 9216 neurons (2304 hidden √ó 4 expansion factor)<br>
                    ‚Ä¢ <strong>GELU Activations</strong> - Post-activation values showing neuron firing<br>
                    Reveals WHICH specific neurons in a layer are responsible for the trait.
                </div>
                <div class="card">
                    <div class="card-title">Layer Deep Dive: ${getDisplayName(trait.name)}</div>

                    <div class="info" style="margin-bottom: 20px;">
                        <strong>‚ö†Ô∏è No layer internals data available for ${trait.name}</strong>
                    </div>

                    <div style="background: var(--bg-tertiary); padding: 20px; border-radius: 8px;">
                        <h3 style="color: var(--text-primary); margin-bottom: 15px;">Capture Layer Internals</h3>
                        <p style="color: var(--text-secondary); margin-bottom: 15px;">
                            Capture complete internals (Q/K/V, attention heads, 9216 MLP neurons) for one layer:
                        </p>
                        <pre style="background: var(--bg-primary); color: var(--text-primary); padding: 15px; border-radius: 4px; margin: 15px 0; overflow-x: auto; border: 1px solid var(--border-color);">python inference/capture_tier3.py \\
  --experiment ${experimentData.name} \\
  --trait ${trait.name} \\
  --layer 16 \\
  --prompts "What is the capital of France?" \\
  --save-json</pre>
                        <p style="color: var(--text-secondary); margin-top: 15px;">
                            The <code style="background: var(--bg-primary); padding: 2px 6px; border-radius: 3px;">--save-json</code> flag creates visualization-friendly JSON files (~10-20 MB).
                        </p>
                        <p style="color: var(--text-tertiary); font-size: 13px; margin-top: 10px;">
                            This reveals which specific neurons and attention heads are responsible for ${getDisplayName(trait.name)}.
                        </p>
                    </div>
                </div>
            `;
        }

        function renderTier3Data(trait, data) {
            const contentArea = document.getElementById('content-area');

            // Get prompt GELU activations: [n_tokens, 9216]
            const promptGelu = data.internals.prompt.gelu;
            const promptTokens = data.prompt.tokens;

            contentArea.innerHTML = `
                <div class="info" style="margin-bottom: 20px;">
                    <strong>How Layer Deep Dive Works:</strong><br>
                    Captures complete layer internals for ONE specific layer to identify which neurons drive the trait:<br>
                    ‚Ä¢ <strong>Q/K/V Projections</strong> - Query, Key, Value attention inputs<br>
                    ‚Ä¢ <strong>Attention Heads</strong> - Per-head attention patterns<br>
                    ‚Ä¢ <strong>MLP Neurons</strong> - All 9216 neurons (2304 hidden √ó 4 expansion factor)<br>
                    ‚Ä¢ <strong>GELU Activations</strong> - Post-activation values showing neuron firing<br>
                    Top 20 neurons shown ranked by average activation magnitude.
                </div>
                <div class="card">
                    <div class="card-title">Layer Deep Dive: ${getDisplayName(trait.name)} (Layer ${data.layer})</div>

                    <div style="background: var(--bg-tertiary); padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                        <div style="margin-bottom: 10px;">
                            <div style="color: var(--text-secondary); font-size: 13px; margin-bottom: 5px;">Full Conversation</div>
                            <div style="color: var(--text-primary); font-size: 16px; font-weight: 600;">${data.prompt.text} ${data.response.text}</div>
                        </div>
                        <div>
                            <div style="color: var(--text-secondary); font-size: 13px;">Layer</div>
                            <div style="color: var(--text-primary); font-size: 16px; font-weight: 600;">Layer ${data.layer} of 27</div>
                        </div>
                    </div>

                    <div id="sublayer-trajectory" style="margin-bottom: 30px;"></div>
                    <div id="contribution-breakdown" style="margin-bottom: 30px;"></div>
                    <div id="attention-heatmaps" style="margin-bottom: 30px;"></div>
                    <div id="top-neurons-combined"></div>
                </div>
            `;

            // Combine prompt and response tokens and activations
            const responseGelu = data.internals.response.gelu;
            const responseTokens = data.response.tokens;

            const allTokens = [...promptTokens, ...responseTokens];
            const allGelu = [...promptGelu, ...responseGelu];

            // Render new visualizations if trait projections available
            if (data.trait_projections) {
                renderSublayerTrajectory(data, promptTokens.length);
                renderContributionBreakdown(data, promptTokens.length);
            }

            // Render attention heatmaps
            if (data.internals.prompt.attn_weights) {
                renderAttentionHeatmaps(data, promptTokens.length);
            }

            // Render combined neuron activations
            renderTopNeurons('top-neurons-combined', 'Top Neurons (Full Conversation)', allGelu, allTokens, promptTokens.length);
        }

        // ============================================================================
        // Phase 1 Visualizations
        // ============================================================================

        function renderSublayerTrajectory(data, promptLength) {
            // Combine prompt and response projections
            const promptProj = data.trait_projections.prompt;
            const responseProj = data.trait_projections.response;

            const allTokens = [...data.prompt.tokens, ...data.response.tokens];
            const residualIn = [...promptProj.residual_in, ...responseProj.residual_in];
            const residualAfterAttn = [...promptProj.residual_after_attn, ...responseProj.residual_after_attn];
            const residualOut = [...promptProj.residual_out, ...responseProj.residual_out];

            const trace1 = {
                x: Array.from({length: allTokens.length}, (_, i) => i),
                y: residualIn,
                mode: 'lines+markers',
                name: 'Residual In',
                line: { color: '#888', width: 2 },
                marker: { size: 6 },
                hovertemplate: 'Token %{x}: %{text}<br>Trait Score: %{y:.3f}<extra></extra>',
                text: allTokens
            };

            const trace2 = {
                x: Array.from({length: allTokens.length}, (_, i) => i),
                y: residualAfterAttn,
                mode: 'lines+markers',
                name: 'After Attention',
                line: { color: '#4a9eff', width: 2 },
                marker: { size: 6 },
                hovertemplate: 'Token %{x}: %{text}<br>Trait Score: %{y:.3f}<extra></extra>',
                text: allTokens
            };

            const trace3 = {
                x: Array.from({length: allTokens.length}, (_, i) => i),
                y: residualOut,
                mode: 'lines+markers',
                name: 'After MLP (Output)',
                line: { color: '#4caf50', width: 2 },
                marker: { size: 6 },
                hovertemplate: 'Token %{x}: %{text}<br>Trait Score: %{y:.3f}<extra></extra>',
                text: allTokens
            };

            // Add separator line
            const shapes = [];
            if (promptLength) {
                shapes.push({
                    type: 'line',
                    xref: 'x',
                    yref: 'paper',
                    x0: promptLength - 0.5,
                    x1: promptLength - 0.5,
                    y0: 0,
                    y1: 1,
                    line: {
                        color: 'rgba(255, 255, 255, 0.3)',
                        width: 2,
                        dash: 'dash'
                    }
                });
            }

            const layout = getPlotlyLayout({
                title: '3-Checkpoint Trait Trajectory (Sublayer Evolution)',
                xaxis: { title: 'Token Position' },
                yaxis: { title: 'Trait Score' },
                height: 400,
                shapes: shapes
            });

            Plotly.newPlot('sublayer-trajectory', [trace1, trace2, trace3], layout, { displayModeBar: false });
        }

        function renderContributionBreakdown(data, promptLength) {
            // Combine prompt and response contributions
            const promptProj = data.trait_projections.prompt;
            const responseProj = data.trait_projections.response;

            const allTokens = [...data.prompt.tokens, ...data.response.tokens];
            const attnContrib = [...promptProj.attn_contribution, ...responseProj.attn_contribution];
            const mlpContrib = [...promptProj.mlp_contribution, ...responseProj.mlp_contribution];

            const trace1 = {
                x: Array.from({length: allTokens.length}, (_, i) => i),
                y: attnContrib,
                type: 'bar',
                name: 'Attention Contribution',
                marker: { color: '#4a9eff' },
                hovertemplate: 'Token %{x}: %{text}<br>Attention: %{y:.3f}<extra></extra>',
                text: allTokens
            };

            const trace2 = {
                x: Array.from({length: allTokens.length}, (_, i) => i),
                y: mlpContrib,
                type: 'bar',
                name: 'MLP Contribution',
                marker: { color: '#4caf50' },
                hovertemplate: 'Token %{x}: %{text}<br>MLP: %{y:.3f}<extra></extra>',
                text: allTokens
            };

            // Add separator line
            const shapes = [];
            if (promptLength) {
                shapes.push({
                    type: 'line',
                    xref: 'x',
                    yref: 'paper',
                    x0: promptLength - 0.5,
                    x1: promptLength - 0.5,
                    y0: 0,
                    y1: 1,
                    line: {
                        color: 'rgba(255, 255, 255, 0.3)',
                        width: 2,
                        dash: 'dash'
                    }
                });
            }

            const layout = getPlotlyLayout({
                title: 'Attention vs MLP Contribution (Per Token)',
                xaxis: { title: 'Token Position' },
                yaxis: { title: 'Trait Contribution' },
                barmode: 'group',
                height: 400,
                shapes: shapes
            });

            Plotly.newPlot('contribution-breakdown', [trace1, trace2], layout, { displayModeBar: false });
        }

        function renderAttentionHeatmaps(data, promptLength) {
            const attnWeights = data.internals.prompt.attn_weights;  // [8_heads, seq_len, seq_len]
            const tokens = [...data.prompt.tokens, ...data.response.tokens];

            const html = `
                <h3 style="margin-bottom: 15px; color: var(--text-primary);">8-Head Attention Patterns</h3>
                <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px;">
                    ${Array.from({length: 8}, (_, i) => `<div id="attn-head-${i}"></div>`).join('')}
                </div>
            `;

            document.getElementById('attention-heatmaps').innerHTML = html;

            // Render each head
            for (let head = 0; head < 8; head++) {
                const headWeights = attnWeights[head];  // [seq_len, seq_len]

                const trace = {
                    z: headWeights,
                    x: tokens.slice(0, headWeights[0].length),
                    y: tokens.slice(0, headWeights.length),
                    type: 'heatmap',
                    colorscale: 'Viridis',
                    hovertemplate: 'From: %{y}<br>To: %{x}<br>Weight: %{z:.3f}<extra></extra>',
                    showscale: head === 7  // Only show scale on last plot
                };

                const layout = getPlotlyLayout({
                    title: `Head ${head}`,
                    xaxis: { title: '', tickangle: -45, tickfont: { size: 9 } },
                    yaxis: { title: '', autorange: 'reversed', tickfont: { size: 9 } },
                    height: 250,
                    margin: { l: 50, r: 10, t: 40, b: 50 }
                });

                Plotly.newPlot(`attn-head-${head}`, [trace], layout, { displayModeBar: false });
            }
        }

        // ============================================================================
        // Neuron Visualization
        // ============================================================================

        function renderTopNeurons(divId, title, geluActivations, tokens, promptLength = null) {
            // geluActivations: [n_tokens, 9216]
            // Show per-token heatmap with slider
            // promptLength: if provided, adds visual separator between prompt and response

            if (!geluActivations || geluActivations.length === 0) {
                document.getElementById(divId).innerHTML = '<div style="color: var(--text-secondary);">No data</div>';
                return;
            }

            const nTokens = geluActivations.length;
            const nNeurons = geluActivations[0].length;

            // Find top 50 neurons by average activation magnitude
            const neuronAvg = new Array(nNeurons).fill(0);
            for (let t = 0; t < nTokens; t++) {
                for (let n = 0; n < nNeurons; n++) {
                    neuronAvg[n] += Math.abs(geluActivations[t][n]);
                }
            }
            for (let n = 0; n < nNeurons; n++) {
                neuronAvg[n] /= nTokens;
            }

            const neuronIndices = Array.from({length: nNeurons}, (_, i) => i);
            neuronIndices.sort((a, b) => neuronAvg[b] - neuronAvg[a]);
            const topNeurons = neuronIndices.slice(0, 50);

            // Create heatmap data: [50_neurons, n_tokens]
            const heatmapData = topNeurons.map(neuronIdx => {
                return geluActivations.map(tokenActivations => tokenActivations[neuronIdx]);
            });

            // Create unique div IDs
            const heatmapId = `${divId}-heatmap`;
            const sliderId = `${divId}-slider`;
            const sliderValueId = `${divId}-slider-value`;
            const barChartId = `${divId}-bar`;

            const html = `
                <div style="margin-bottom: 30px;">
                    <h3 style="margin-bottom: 15px; color: var(--text-primary);">${title}</h3>

                    <div style="margin-bottom: 20px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <label style="color: var(--text-secondary); font-weight: 600;">
                                Token Position: <span id="${sliderValueId}" style="color: var(--primary-color);">0</span> / ${nTokens - 1}
                            </label>
                            <span style="color: var(--text-secondary); font-size: 12px;">
                                Token: "<span id="${sliderValueId}-token" style="font-weight: 600;">${tokens[0]}</span>"
                            </span>
                        </div>
                        <input type="range" id="${sliderId}" min="0" max="${nTokens - 1}" value="0"
                               style="width: 100%; height: 3px; border-radius: 2px; background: var(--border-color);">
                    </div>

                    <div id="${heatmapId}" style="margin-bottom: 30px;"></div>
                    <div id="${barChartId}"></div>
                </div>
            `;

            document.getElementById(divId).innerHTML = html;

            // Render heatmap (overview of all tokens √ó top neurons)
            const heatmapTrace = {
                z: heatmapData,
                x: tokens,
                y: topNeurons.map(n => `N${n}`),
                type: 'heatmap',
                colorscale: 'RdBu',
                zmid: 0,
                hovertemplate: 'Token: %{x}<br>Neuron: %{y}<br>Activation: %{z:.3f}<extra></extra>',
                colorbar: {
                    title: 'Activation'
                }
            };

            // Build shapes array for heatmap
            const shapes = [{
                type: 'rect',
                xref: 'x',
                yref: 'paper',
                x0: -0.5,
                x1: 0.5,
                y0: 0,
                y1: 1,
                fillcolor: 'rgba(74, 158, 255, 0.15)',
                line: { width: 0 }
            }];

            // Add separator line between prompt and response if provided
            if (promptLength !== null) {
                shapes.push({
                    type: 'line',
                    xref: 'x',
                    yref: 'paper',
                    x0: promptLength - 0.5,
                    x1: promptLength - 0.5,
                    y0: 0,
                    y1: 1,
                    line: {
                        color: 'rgba(255, 255, 255, 0.5)',
                        width: 2,
                        dash: 'dash'
                    }
                });
            }

            // Add annotations for prompt/response regions if applicable
            const annotations = [];
            if (promptLength !== null) {
                annotations.push({
                    x: (promptLength - 1) / 2,
                    y: 1.05,
                    xref: 'x',
                    yref: 'paper',
                    text: 'Prompt',
                    showarrow: false,
                    font: { size: 12, color: 'var(--text-secondary)' },
                    xanchor: 'center'
                });
                annotations.push({
                    x: promptLength + (nTokens - promptLength - 1) / 2,
                    y: 1.05,
                    xref: 'x',
                    yref: 'paper',
                    text: 'Response',
                    showarrow: false,
                    font: { size: 12, color: 'var(--text-secondary)' },
                    xanchor: 'center'
                });
            }

            const heatmapLayout = getPlotlyLayout({
                title: 'Neuron Activations Across All Tokens (Top 50 Neurons)',
                xaxis: { title: 'Token', tickangle: -45 },
                yaxis: { title: 'Neuron', autorange: 'reversed' },
                height: 500,
                shapes: shapes,
                annotations: annotations
            });

            Plotly.newPlot(heatmapId, [heatmapTrace], heatmapLayout, { displayModeBar: false });

            // Function to update bar chart for selected token
            function updateBarChart(tokenIdx) {
                const tokenActivations = geluActivations[tokenIdx];
                const topActivations = topNeurons.map(n => tokenActivations[n]);

                const barTrace = {
                    x: topNeurons.map(n => `N${n}`),
                    y: topActivations,
                    type: 'bar',
                    marker: {
                        color: topActivations.map(a => a > 0 ? '#4caf50' : '#f44336')
                    },
                    hovertemplate: 'Neuron: %{x}<br>Activation: %{y:.3f}<extra></extra>'
                };

                Plotly.newPlot(barChartId, [barTrace], getPlotlyLayout({
                    title: `Neuron Activations for Token "${tokens[tokenIdx]}" (Position ${tokenIdx})`,
                    xaxis: { title: 'Neuron Index', tickangle: -45 },
                    yaxis: { title: 'Activation' },
                    height: 400
                }), { displayModeBar: false });

                // Update heatmap highlight
                const newShapes = [{
                    type: 'rect',
                    xref: 'x',
                    yref: 'paper',
                    x0: tokenIdx - 0.5,
                    x1: tokenIdx + 0.5,
                    y0: 0,
                    y1: 1,
                    fillcolor: 'rgba(74, 158, 255, 0.15)',
                    line: { width: 0 }
                }];

                // Add separator line if provided
                if (promptLength !== null) {
                    newShapes.push({
                        type: 'line',
                        xref: 'x',
                        yref: 'paper',
                        x0: promptLength - 0.5,
                        x1: promptLength - 0.5,
                        y0: 0,
                        y1: 1,
                        line: {
                            color: 'rgba(255, 255, 255, 0.5)',
                            width: 2,
                            dash: 'dash'
                        }
                    });
                }

                // Preserve annotations when updating
                const layoutUpdate = { shapes: newShapes };
                if (annotations.length > 0) {
                    layoutUpdate.annotations = annotations;
                }
                Plotly.relayout(heatmapId, layoutUpdate);

                // Update slider label
                document.getElementById(sliderValueId).textContent = tokenIdx;
                document.getElementById(`${sliderValueId}-token`).textContent = tokens[tokenIdx];
            }

            // Initialize with first token
            updateBarChart(0);

            // Add slider event listener
            document.getElementById(sliderId).addEventListener('input', (e) => {
                updateBarChart(parseInt(e.target.value));
            });
        }

        // Setup event listeners
        function setupEventListeners() {
            // Experiment selection is now handled in loadExperiments()

            // Theme toggle
            document.getElementById('theme-toggle').addEventListener('click', toggleTheme);

            // Info tooltip
            document.getElementById('info-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                toggleInfo();
            });

            // Select all traits button
            document.getElementById('select-all-btn').addEventListener('click', toggleAllTraits);
        }

        // Utility functions
        function showError(message) {
            document.getElementById('content-area').innerHTML = `
                <div class="error">
                    <strong>Error:</strong> ${message}
                    <br><br>
                    Make sure you're running a local server from the trait-interp root directory:
                    <pre style="background: #2d2d2d; color: #f8f8f2; padding: 10px; border-radius: 4px; margin-top: 10px;">cd trait-interp
python -m http.server 8000</pre>
                    Then visit: <a href="http://localhost:8000/visualization/">http://localhost:8000/visualization/</a>
                </div>
            `;
        }

        // Initialize on page load
        init();
    </script>
</body>
</html>
