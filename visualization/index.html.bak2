<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trait Interp Visualization</title>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            },
            startup: {
                ready: () => {
                    MathJax.startup.defaultReady();
                    console.log('MathJax loaded');
                }
            }
        };
    </script>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        :root {
            --bg-primary: #f8f9fa;
            --bg-secondary: #ffffff;
            --bg-tertiary: #f8f9fa;
            --text-primary: #333;
            --text-secondary: #666;
            --text-tertiary: #888;
            --border-color: #ddd;
            --shadow: rgba(0,0,0,0.1);
            --primary-color: #007bff;
            --primary-hover: #0056b3;
            --success: #28a745;
            --danger: #dc3545;
            --info-bg: #d1ecf1;
            --info-border: #17a2b8;
            --info-text: #0c5460;
        }

        [data-theme="dark"] {
            --bg-primary: #1a1a1a;
            --bg-secondary: #2d2d2d;
            --bg-tertiary: #3a3a3a;
            --text-primary: #e0e0e0;
            --text-secondary: #b0b0b0;
            --text-tertiary: #888;
            --border-color: #444;
            --shadow: rgba(0,0,0,0.3);
            --primary-color: #4a9eff;
            --primary-hover: #6bb0ff;
            --success: #4caf50;
            --danger: #f44336;
            --info-bg: #1e3a4a;
            --info-border: #2196f3;
            --info-text: #90caf9;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--bg-primary);
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            display: flex;
            gap: 0;
            max-width: 100%;
            height: 100vh;
            overflow: hidden;
        }

        .transformer-sidebar {
            width: 200px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            transition: all 0.3s ease;
            position: relative;
        }

        .transformer-sidebar.hidden {
            width: 0;
            border: none;
            overflow: hidden;
        }

        .transformer-header {
            padding: 15px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            background: var(--bg-secondary);
            z-index: 10;
        }

        .transformer-title {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .transformer-toggle {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 16px;
            padding: 4px;
            line-height: 1;
            transition: transform 0.3s ease;
        }

        .transformer-toggle:hover {
            color: var(--primary-color);
            transform: scale(1.1);
        }

        .transformer-content {
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .layer-box {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 8px;
            transition: all 0.2s ease;
        }

        .layer-box.highlighted {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(74, 158, 255, 0.2);
        }

        .layer-number {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 4px;
        }

        .sublayer {
            font-size: 9px;
            color: var(--text-secondary);
            padding: 2px 4px;
            background: var(--bg-secondary);
            border-radius: 3px;
            margin-bottom: 2px;
        }

        .sublayer:last-child {
            margin-bottom: 0;
        }

        .layer-ellipsis {
            text-align: center;
            padding: 12px;
            color: var(--text-tertiary);
            font-size: 11px;
            font-weight: 600;
        }

        .input-output-box {
            background: var(--bg-tertiary);
            border: 2px dashed var(--border-color);
            border-radius: 6px;
            padding: 8px;
            text-align: center;
            font-size: 11px;
            font-weight: 600;
            color: var(--text-secondary);
        }

        .sidebar {
            width: 280px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            transition: background 0.3s ease;
        }

        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid var(--border-color);
            position: sticky;
            top: 0;
            background: var(--bg-secondary);
            z-index: 10;
        }

        .sidebar-title {
            font-size: 18px;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 5px;
            transition: color 0.3s ease;
        }

        .sidebar-subtitle {
            font-size: 12px;
            color: var(--text-secondary);
            transition: color 0.3s ease;
        }

        .sidebar-section {
            padding: 20px;
            border-bottom: 1px solid var(--border-color);
        }

        .section-title {
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            color: var(--text-tertiary);
            margin-bottom: 12px;
            letter-spacing: 0.5px;
        }

        .nav-item {
            padding: 10px 12px;
            margin-bottom: 4px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            color: var(--text-secondary);
            font-size: 14px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .nav-item:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .nav-item.active {
            background: var(--primary-color);
            color: white;
        }

        .nav-item .icon {
            font-size: 16px;
        }

        .trait-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            margin-bottom: 4px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 13px;
            color: var(--text-secondary);
        }

        .trait-checkbox:hover {
            background: var(--bg-tertiary);
        }

        .trait-checkbox input[type="checkbox"] {
            cursor: pointer;
        }

        .trait-checkbox label {
            cursor: pointer;
            margin: 0;
            flex: 1;
            color: inherit;
        }

        .select-all-btn {
            padding: 6px 10px;
            font-size: 11px;
            margin-bottom: 8px;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        header {
            background: var(--bg-secondary);
            padding: 15px 30px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.3s ease;
        }

        .header-left {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .header-right {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .info-btn, .theme-toggle {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 50%;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s;
        }

        .info-btn:hover, .theme-toggle:hover {
            background: var(--primary-color);
            color: white;
            transform: scale(1.05);
        }

        .info-tooltip {
            position: fixed;
            top: 70px;
            left: 20px;
            background: var(--bg-secondary);
            border: 2px solid var(--primary-color);
            border-radius: 12px;
            padding: 20px;
            max-width: 500px;
            box-shadow: 0 8px 24px var(--shadow);
            z-index: 1000;
            display: none;
            max-height: calc(100vh - 100px);
            overflow-y: auto;
        }

        .info-tooltip.show {
            display: block;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .info-tooltip h3 {
            color: var(--primary-color);
            margin-bottom: 15px;
            font-size: 18px;
        }

        .info-tooltip h4 {
            color: var(--text-secondary);
            margin-top: 15px;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .info-tooltip ul {
            margin-left: 20px;
            color: var(--text-secondary);
            font-size: 13px;
            line-height: 1.6;
        }

        .info-tooltip strong {
            color: var(--text-secondary);
        }

        .info-tooltip .trait-list {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
            margin-top: 8px;
            list-style: none;
            margin-left: 0;
        }

        .info-tooltip .trait-list li {
            color: var(--text-secondary);
        }

        .page-title {
            font-size: 20px;
            font-weight: 600;
            color: var(--text-primary);
            transition: color 0.3s ease;
        }

        .experiment-badge {
            padding: 4px 12px;
            background: var(--bg-tertiary);
            border-radius: 20px;
            font-size: 12px;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .content-wrapper {
            flex: 1;
            overflow-y: auto;
            padding: 30px;
        }

        label {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 4px;
            transition: color 0.3s ease;
        }

        select, button {
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 14px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        button {
            background: var(--primary-color);
            color: white;
            border: none;
            font-weight: 600;
            transition: background 0.2s;
        }

        button:hover {
            background: var(--primary-hover);
        }

        button:disabled {
            background: var(--border-color);
            cursor: not-allowed;
        }

        .tabs {
            background: var(--bg-secondary);
            padding: 0;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px var(--shadow);
            overflow: hidden;
            transition: background 0.3s ease;
        }

        .tab-buttons {
            display: flex;
            border-bottom: 2px solid var(--border-color);
        }

        .tab-button {
            flex: 1;
            padding: 15px 20px;
            background: var(--bg-secondary);
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-weight: 600;
            color: var(--text-secondary);
            transition: all 0.2s;
        }

        .tab-button:hover {
            background: var(--bg-tertiary);
        }

        .tab-button.active {
            color: var(--primary-color);
            border-bottom-color: var(--primary-color);
            background: var(--bg-tertiary);
        }

        .tab-content {
            display: none;
            padding: 20px;
        }

        .tab-content.active {
            display: block;
        }

        .card {
            background: var(--bg-secondary);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px var(--shadow);
            margin-bottom: 20px;
            transition: background 0.3s ease;
        }

        .card-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 15px;
            color: var(--text-primary);
            transition: color 0.3s ease;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .stat-card {
            background: var(--bg-tertiary);
            padding: 15px;
            border-radius: 6px;
            border-left: 4px solid var(--primary-color);
            transition: background 0.3s ease;
        }

        .stat-label {
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 5px;
            text-transform: uppercase;
            font-weight: 600;
            transition: color 0.3s ease;
        }

        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: var(--text-primary);
            transition: color 0.3s ease;
        }

        .stat-detail {
            font-size: 12px;
            color: var(--text-tertiary);
            margin-top: 3px;
            transition: color 0.3s ease;
        }

        .trait-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 15px;
        }

        .trait-card {
            background: var(--bg-secondary);
            padding: 15px;
            border-radius: 6px;
            border: 2px solid var(--border-color);
            cursor: pointer;
            transition: all 0.2s;
        }

        .trait-card:hover {
            border-color: var(--primary-color);
            box-shadow: 0 4px 8px var(--shadow);
            transform: translateY(-2px);
        }

        .trait-card.selected {
            border-color: var(--primary-color);
            background: var(--bg-tertiary);
        }

        .trait-name {
            font-weight: 600;
            font-size: 16px;
            margin-bottom: 8px;
            color: var(--text-primary);
            transition: color 0.3s ease;
        }

        .trait-info {
            font-size: 12px;
            color: var(--text-secondary);
            transition: color 0.3s ease;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: var(--text-secondary);
            transition: color 0.3s ease;
        }

        .error {
            background: #fff3cd;
            border: 1px solid #ffc107;
            padding: 15px;
            border-radius: 6px;
            margin: 20px 0;
            color: #856404;
        }

        .info {
            background: var(--info-bg);
            border: 1px solid var(--info-border);
            padding: 15px;
            border-radius: 6px;
            margin: 20px 0;
            color: var(--info-text);
            transition: all 0.3s ease;
        }

        .explanation {
            background: var(--bg-secondary);
            padding: 15px 20px;
            margin: 20px 0;
            border-left: 3px solid var(--text-tertiary);
            color: var(--text-secondary);
            font-size: 14px;
            line-height: 1.8;
            transition: all 0.3s ease;
        }

        .explanation-summary {
            color: var(--text-primary);
            font-size: 14px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            padding: 5px 0;
        }

        .explanation-summary:hover {
            color: var(--primary-color);
        }

        .explanation-summary::after {
            content: '‚Üí';
            font-size: 12px;
            color: var(--text-tertiary);
            transition: transform 0.3s ease;
        }

        .explanation-summary:hover::after {
            transform: translateX(4px);
            color: var(--primary-color);
        }

        .explanation-details {
            display: none;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid var(--border-color);
        }

        .explanation.expanded {
            border-left-color: var(--primary-color);
            background: var(--bg-tertiary);
        }

        .explanation.expanded .explanation-details {
            display: block;
        }

        .explanation.expanded .explanation-summary::after {
            content: '‚Üì';
        }

        .explanation-details h4 {
            color: var(--text-primary);
            font-size: 15px;
            font-weight: 600;
            margin: 15px 0 10px 0;
        }

        .explanation-details h4:first-child {
            margin-top: 0;
        }

        .explanation-details ul {
            margin: 10px 0 10px 20px;
        }

        .explanation-details code {
            background: var(--bg-tertiary);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
        }

        .response-preview {
            background: var(--bg-tertiary);
            padding: 12px;
            border-radius: 4px;
            font-size: 13px;
            line-height: 1.6;
            margin: 8px 0;
            border-left: 3px solid var(--primary-color);
            color: var(--text-primary);
            transition: all 0.3s ease;
        }

        .score-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            margin-left: 8px;
        }

        .score-high {
            background: #d4edda;
            color: #155724;
        }

        .score-low {
            background: #f8d7da;
            color: #721c24;
        }

        #token-slider {
            width: 100%;
            margin: 15px 0;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            color: #666;
            margin-bottom: 8px;
        }

        .token-highlight {
            background: #ffeb3b;
            padding: 2px 4px;
            border-radius: 3px;
            font-weight: 600;
        }

        .response-text {
            line-height: 1.8;
            font-size: 14px;
            color: var(--text-primary);
            transition: color 0.3s ease;
        }

        pre {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            transition: all 0.3s ease;
        }

        code {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            padding: 2px 6px;
            border-radius: 3px;
            transition: all 0.3s ease;
        }

        /* Data Explorer Styles */
        .explorer-trait-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin-bottom: 10px;
            overflow: hidden;
            transition: all 0.2s;
        }

        .explorer-trait-header {
            padding: 15px 20px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            transition: background 0.2s, color 0.2s;
        }

        .explorer-trait-header:hover {
            background: var(--primary-color);
            color: white;
        }

        .explorer-trait-header.expanded {
            background: var(--primary-color);
            color: white;
        }

        .explorer-trait-header strong,
        .explorer-trait-header span {
            color: inherit;
        }

        .explorer-trait-body {
            padding: 20px;
            display: none;
        }

        .explorer-trait-body.show {
            display: block;
        }

        .file-tree {
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.8;
        }

        .file-item {
            padding: 4px 0;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .file-item.clickable {
            cursor: pointer;
            transition: color 0.2s;
        }

        .file-item.clickable:hover {
            color: var(--primary-color);
            text-decoration: underline;
        }

        .file-item strong,
        .file-item span {
            color: inherit;
        }

        .file-icon {
            font-size: 14px;
        }

        .preview-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            padding: 20px;
        }

        .preview-modal.show {
            display: flex;
        }

        .preview-content {
            background: var(--bg-secondary);
            border-radius: 12px;
            max-width: 900px;
            max-height: 80vh;
            width: 100%;
            display: flex;
            flex-direction: column;
            box-shadow: 0 10px 40px var(--shadow);
        }

        .preview-header {
            padding: 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .preview-body {
            padding: 20px;
            overflow-y: auto;
            flex: 1;
        }

        .close-btn {
            background: var(--danger);
            color: white;
            border: none;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-btn:hover {
            opacity: 0.8;
        }

        .json-viewer {
            background: var(--bg-tertiary);
            padding: 15px;
            border-radius: 6px;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.6;
        }

        .json-viewer pre {
            margin: 0;
            color: var(--text-secondary);
        }

        .json-key {
            color: #61afef;
        }

        .json-string {
            color: #98c379;
        }

        .json-number {
            color: #d19a66;
        }

        .json-boolean {
            color: #c678dd;
        }

        .json-null {
            color: #e06c75;
        }

        .csv-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }

        .csv-table th,
        .csv-table td {
            border: 1px solid var(--border-color);
            padding: 8px;
            text-align: left;
        }

        .csv-table th {
            background: var(--bg-tertiary);
            font-weight: 600;
            color: var(--text-primary);
        }

        .csv-table td {
            color: var(--text-secondary);
        }

        .indent-1 { padding-left: 20px; }
        .indent-2 { padding-left: 40px; }
        .indent-3 { padding-left: 60px; }
    </style>
</head>
<body>
    <!-- Preview modal (global) -->
    <div class="preview-modal" id="preview-modal">
        <div class="preview-content">
            <div class="preview-header">
                <h3 id="preview-title" style="margin: 0; color: var(--text-primary);"></h3>
                <button class="close-btn" onclick="closePreview()">√ó</button>
            </div>
            <div class="preview-body" id="preview-body"></div>
        </div>
    </div>

    <!-- Info tooltip (global) -->
    <div class="info-tooltip" id="info-tooltip">
        <h3>üìä Trait Interpretation Visualization</h3>

        <h4>üîß Tools:</h4>
        <ul>
            <li><strong>Data Explorer</strong> - Inspect file structure, sizes, and preview data</li>
            <li><strong>Overview</strong> - Browse all extracted traits with metadata and example counts</li>
            <li><strong>Vector Analysis</strong> - Compare extraction methods across 27 layers with heatmaps</li>
            <li><strong>All Layers</strong> - View trait evolution across all 27 layers (Tier 2 data)</li>
            <li><strong>Layer Deep Dive</strong> - Analyze attention heads and top neurons for one layer (Tier 3 data)</li>
        </ul>

        <h4>üß† Available Traits (16 cognitive primitives):</h4>
        <div class="trait-list">
            <li>refusal</li>
            <li>uncertainty_calibration</li>
            <li>sycophancy</li>
            <li>retrieval_construction</li>
            <li>commitment_strength</li>
            <li>abstract_concrete</li>
            <li>cognitive_load</li>
            <li>context_adherence</li>
            <li>convergent_divergent</li>
            <li>emotional_valence</li>
            <li>instruction_boundary</li>
            <li>local_global</li>
            <li>paranoia_trust</li>
            <li>power_dynamics</li>
            <li>serial_parallel</li>
            <li>temporal_focus</li>
        </div>

        <h4>üí° Quick Tips:</h4>
        <ul>
            <li>Select traits in the sidebar to filter data</li>
            <li>Use the theme toggle (üåô/‚òÄÔ∏è) for dark mode</li>
            <li>Separation scores >40 indicate excellent quality</li>
        </ul>
    </div>

    <div class="container">
        <!-- Transformer Architecture Visualization -->
        <div class="transformer-sidebar" id="transformer-sidebar">
            <div class="transformer-header">
                <div class="transformer-title">Architecture</div>
                <button class="transformer-toggle" id="transformer-toggle" title="Hide architecture">‚óÄ</button>
            </div>
            <div class="transformer-content">
                <!-- Output at top -->
                <div class="input-output-box">Output</div>

                <!-- Last 2 layers (top of stack) -->
                <div class="layer-box" data-layer="26">
                    <div class="layer-number">Layer 26</div>
                    <div class="sublayer">Add & Norm</div>
                    <div class="sublayer">Feed Forward</div>
                    <div class="sublayer">Add & Norm</div>
                    <div class="sublayer">Multi-Head Attention</div>
                </div>

                <div class="layer-box" data-layer="25">
                    <div class="layer-number">Layer 25</div>
                    <div class="sublayer">Add & Norm</div>
                    <div class="sublayer">Feed Forward</div>
                    <div class="sublayer">Add & Norm</div>
                    <div class="sublayer">Multi-Head Attention</div>
                </div>

                <!-- Ellipsis -->
                <div class="layer-ellipsis">‚Üë<br>[22 more layers]<br>‚Üë</div>

                <!-- First 2 layers (bottom of stack) -->
                <div class="layer-box" data-layer="1">
                    <div class="layer-number">Layer 1</div>
                    <div class="sublayer">Add & Norm</div>
                    <div class="sublayer">Feed Forward</div>
                    <div class="sublayer">Add & Norm</div>
                    <div class="sublayer">Multi-Head Attention</div>
                </div>

                <div class="layer-box" data-layer="0">
                    <div class="layer-number">Layer 0</div>
                    <div class="sublayer">Add & Norm</div>
                    <div class="sublayer">Feed Forward</div>
                    <div class="sublayer">Add & Norm</div>
                    <div class="sublayer">Multi-Head Attention</div>
                </div>

                <!-- Input at bottom -->
                <div class="input-output-box">Input Embedding</div>
            </div>
        </div>

        <!-- Sidebar -->
        <div class="sidebar">
            <div class="sidebar-header">
                <div class="sidebar-title">Trait Interp</div>
                <div class="sidebar-subtitle">Vector Visualization</div>
            </div>

            <div class="sidebar-section">
                <div class="section-title">Experiments</div>
                <div id="experiment-list">
                    <div class="nav-item" style="opacity: 0.5; cursor: default;">Loading...</div>
                </div>
            </div>

            <div class="sidebar-section">
                <div class="section-title">Extraction</div>
                <div id="nav-items-extraction">
                    <div class="nav-item active" data-view="data-explorer">
                        <span class="icon">üóÇÔ∏è</span>
                        <span>Data Explorer</span>
                    </div>
                    <div class="nav-item" data-view="vectors">
                        <span class="icon">üî¨</span>
                        <span>Vector Analysis</span>
                    </div>
                </div>
            </div>

            <div class="sidebar-section">
                <div class="section-title">Inference</div>
                <div id="nav-items-inference">
                    <div class="nav-item" data-view="monitoring">
                        <span class="icon">‚ö°</span>
                        <span>All Layers</span>
                    </div>
                    <div class="nav-item" data-view="layer-dive">
                        <span class="icon">üîç</span>
                        <span>Layer Deep Dive</span>
                    </div>
                </div>
            </div>

            <div class="sidebar-section">
                <div class="section-title">
                    Selected Traits (<span id="selected-count">0</span>)
                </div>
                <button class="select-all-btn" id="select-all-btn">Select All</button>
                <div id="trait-checkboxes"></div>
            </div>
        </div>

        <!-- Main Content -->
        <div class="main-content">
            <header>
                <div class="header-left">
                    <button class="info-btn" id="info-btn" title="Information">‚ÑπÔ∏è</button>
                    <div class="page-title" id="page-title">Overview</div>
                    <div class="experiment-badge" id="experiment-badge">-</div>
                </div>
                <div class="header-right">
                    <button class="theme-toggle" id="theme-toggle" title="Toggle dark mode">üåô</button>
                </div>
            </header>

            <div class="content-wrapper" id="content-area">
                <div class="loading">Loading experiment data...</div>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let experiments = [];
        let currentExperiment = null;
        let experimentData = null;
        let currentView = 'data-explorer';
        let selectedTraits = new Set();

        // Display names for better interpretability
        const DISPLAY_NAMES = {
            'uncertainty_calibration': 'Confidence',
            'instruction_boundary': 'Literalness',
            'commitment_strength': 'Assertiveness',
            'retrieval_construction': 'Retrieval',
            'convergent_divergent': 'Thinking Style',
            'abstract_concrete': 'Abstraction Level',
            'temporal_focus': 'Temporal Orientation',
            'cognitive_load': 'Complexity',
            'context_adherence': 'Context Following',
            'emotional_valence': 'Emotional Tone',
            'paranoia_trust': 'Trust Level',
            'power_dynamics': 'Authority Tone',
            'serial_parallel': 'Processing Style',
            'local_global': 'Focus Scope'
            // 'refusal' and 'sycophancy' are clear as-is
        };

        function getDisplayName(traitName) {
            // Parse trait name: "refusal" or "refusal_natural"
            let baseName = traitName;
            let method = '';

            if (traitName.endsWith('_natural')) {
                baseName = traitName.replace('_natural', '');
                method = ' (Natural)';
            }

            // Get display name for base trait
            let displayBase = DISPLAY_NAMES[baseName] || baseName.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());

            return displayBase + method;
        }

        // Transformer sidebar toggle
        function toggleTransformerSidebar() {
            const sidebar = document.getElementById('transformer-sidebar');
            const toggle = document.getElementById('transformer-toggle');

            if (sidebar.classList.contains('hidden')) {
                sidebar.classList.remove('hidden');
                toggle.textContent = '‚óÄ';
                toggle.title = 'Hide architecture';
                localStorage.setItem('transformerSidebarVisible', 'true');
            } else {
                sidebar.classList.add('hidden');
                toggle.textContent = '‚ñ∂';
                toggle.title = 'Show architecture';
                localStorage.setItem('transformerSidebarVisible', 'false');
            }
        }

        function initTransformerSidebar() {
            const visible = localStorage.getItem('transformerSidebarVisible');
            if (visible === 'false') {
                toggleTransformerSidebar();
            }

            document.getElementById('transformer-toggle').addEventListener('click', toggleTransformerSidebar);
        }

        // Theme management
        function initTheme() {
            const savedTheme = localStorage.getItem('theme') || 'light';
            document.documentElement.setAttribute('data-theme', savedTheme);
            updateThemeIcon(savedTheme);
        }

        function toggleTheme() {
            const currentTheme = document.documentElement.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            document.documentElement.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
            updateThemeIcon(newTheme);
        }

        function updateThemeIcon(theme) {
            const themeToggle = document.getElementById('theme-toggle');
            themeToggle.textContent = theme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
            themeToggle.title = theme === 'dark' ? 'Switch to light mode' : 'Switch to dark mode';
        }

        // Info tooltip
        function toggleInfo() {
            const tooltip = document.getElementById('info-tooltip');
            tooltip.classList.toggle('show');
        }

        // Toggle explanation details
        function setupExplanationToggles() {
            document.querySelectorAll('.explanation-summary').forEach(summary => {
                summary.addEventListener('click', function() {
                    const explanation = this.closest('.explanation');
                    explanation.classList.toggle('expanded');
                });
            });
        }

        // Get Plotly layout with theme support
        function getPlotlyLayout(baseLayout) {
            const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
            return {
                ...baseLayout,
                paper_bgcolor: isDark ? '#2d2d2d' : '#ffffff',
                plot_bgcolor: isDark ? '#2d2d2d' : '#ffffff',
                font: {
                    color: isDark ? '#e0e0e0' : '#333'
                },
                xaxis: {
                    ...baseLayout.xaxis,
                    color: isDark ? '#e0e0e0' : '#333',
                    gridcolor: isDark ? '#444' : '#ddd'
                },
                yaxis: {
                    ...baseLayout.yaxis,
                    color: isDark ? '#e0e0e0' : '#333',
                    gridcolor: isDark ? '#444' : '#ddd'
                }
            };
        }

        // Close info tooltip when clicking outside
        document.addEventListener('click', (e) => {
            const tooltip = document.getElementById('info-tooltip');
            const infoBtn = document.getElementById('info-btn');
            if (tooltip && !tooltip.contains(e.target) && e.target !== infoBtn) {
                tooltip.classList.remove('show');
            }
        });

        // Populate trait checkboxes
        function populateTraitCheckboxes() {
            const container = document.getElementById('trait-checkboxes');
            container.innerHTML = '';

            if (!experimentData || !experimentData.traits) return;

            experimentData.traits.forEach(trait => {
                const checkbox = document.createElement('div');
                checkbox.className = 'trait-checkbox';
                checkbox.innerHTML = `
                    <input type="checkbox" id="trait-${trait.name}" value="${trait.name}" checked>
                    <label for="trait-${trait.name}">${getDisplayName(trait.name)}</label>
                `;
                container.appendChild(checkbox);

                const input = checkbox.querySelector('input');
                input.addEventListener('change', (e) => {
                    if (e.target.checked) {
                        selectedTraits.add(trait.name);
                    } else {
                        selectedTraits.delete(trait.name);
                    }
                    updateSelectedCount();
                    renderView();
                });

                selectedTraits.add(trait.name);
            });

            updateSelectedCount();
        }

        // Update selected trait count
        function updateSelectedCount() {
            document.getElementById('selected-count').textContent = selectedTraits.size;
        }

        // Select/deselect all traits
        function toggleAllTraits() {
            const checkboxes = document.querySelectorAll('#trait-checkboxes input[type="checkbox"]');
            const allSelected = selectedTraits.size === checkboxes.length;

            checkboxes.forEach(cb => {
                cb.checked = !allSelected;
                if (!allSelected) {
                    selectedTraits.add(cb.value);
                } else {
                    selectedTraits.delete(cb.value);
                }
            });

            const btn = document.getElementById('select-all-btn');
            btn.textContent = allSelected ? 'Select All' : 'Deselect All';
            updateSelectedCount();
            renderView();
        }

        // Handle navigation
        function setupNavigation() {
            const navItems = document.querySelectorAll('.nav-item');
            navItems.forEach(item => {
                item.addEventListener('click', () => {
                    navItems.forEach(n => n.classList.remove('active'));
                    item.classList.add('active');
                    currentView = item.dataset.view;
                    updatePageTitle();
                    renderView();
                });
            });
        }

        // Update page title
        function updatePageTitle() {
            const titles = {
                'data-explorer': 'Data Explorer',
                'overview': 'Overview',
                'vectors': 'Vector Analysis',
                'monitoring': 'All Layers',
                'layer-dive': 'Layer Deep Dive'
            };
            document.getElementById('page-title').textContent = titles[currentView] || 'Data Explorer';
        }

        // Get filtered traits
        function getFilteredTraits() {
            if (!experimentData || !experimentData.traits) return [];
            return experimentData.traits.filter(trait => selectedTraits.has(trait.name));
        }

        // Render math with MathJax
        function renderMath() {
            if (window.MathJax) {
                MathJax.typesetPromise().catch((err) => console.log('MathJax rendering error:', err));
            }
            // Setup explanation toggles after content is rendered
            setupExplanationToggles();
        }

        // Initialize
        async function init() {
            initTheme();
            initTransformerSidebar();
            setupNavigation();
            await loadExperiments();
            setupEventListeners();
        }

        // Load available experiments
        async function loadExperiments() {
            try {
                // Fetch experiments from API
                const response = await fetch('/api/experiments');
                const data = await response.json();
                experiments = data.experiments || [];

                const list = document.getElementById('experiment-list');
                list.innerHTML = experiments.map((exp, idx) => {
                    const displayName = exp.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    const isActive = idx === 0 ? 'active' : '';
                    return `
                        <div class="nav-item ${isActive}" data-experiment="${exp}">
                            <span class="icon">üî¨</span>
                            <span>${displayName}</span>
                        </div>
                    `;
                }).join('');

                // Add click handlers
                list.querySelectorAll('.nav-item').forEach(item => {
                    item.addEventListener('click', () => {
                        list.querySelectorAll('.nav-item').forEach(i => i.classList.remove('active'));
                        item.classList.add('active');
                        currentExperiment = item.dataset.experiment;
                        loadExperimentData(currentExperiment);
                    });
                });

                if (experiments.length > 0) {
                    currentExperiment = experiments[0];
                    await loadExperimentData(currentExperiment);
                }
            } catch (error) {
                console.error('Error loading experiments:', error);
                showError('Failed to load experiments');
            }
        }

        // Load experiment data
        async function loadExperimentData(experimentName) {
            const contentArea = document.getElementById('content-area');
            contentArea.innerHTML = '<div class="loading">Loading experiment data...</div>';

            try {
                experimentData = {
                    name: experimentName,
                    traits: [],
                    readme: null
                };

                // Try to load README
                try {
                    const readmeResponse = await fetch(`../experiments/${experimentName}/README.md`);
                    if (readmeResponse.ok) {
                        experimentData.readme = await readmeResponse.text();
                    }
                } catch (e) {
                    console.log('No README found');
                }

                // Fetch traits from API
                const traitsResponse = await fetch(`/api/experiments/${experimentName}/traits`);
                const traitsData = await traitsResponse.json();
                const traitNames = traitsData.traits || [];

                // Load each trait with metadata
                for (const traitName of traitNames) {
                    // Detect response file format
                    let responseFormat = null;
                    try {
                        const csvCheck = await fetch(
                            `../experiments/${experimentName}/${traitName}/extraction/responses/pos.csv`
                        );
                        if (csvCheck.ok) {
                            responseFormat = 'csv';
                        } else {
                            const jsonCheck = await fetch(
                                `../experiments/${experimentName}/${traitName}/extraction/responses/pos.json`
                            );
                            if (jsonCheck.ok) {
                                responseFormat = 'json';
                            }
                        }
                    } catch (e) {
                        console.warn(`No responses for ${traitName}`);
                        continue;
                    }

                    if (responseFormat) {
                        // Try to load metadata
                        let metadata = null;
                        try {
                            const metadataRes = await fetch(
                                `../experiments/${experimentName}/${traitName}/extraction/activations/metadata.json`
                            );
                            if (metadataRes.ok) {
                                metadata = await metadataRes.json();
                            }
                        } catch (e) {
                            console.warn(`No metadata for ${traitName}`);
                        }

                        // Detect method (natural vs instruction)
                        const method = traitName.endsWith('_natural') ? 'natural' : 'instruction';
                        const baseName = traitName.replace('_natural', '');

                        experimentData.traits.push({
                            name: traitName,
                            baseName: baseName,
                            method: method,
                            responseFormat: responseFormat,
                            hasResponses: true,
                            hasVectors: false,  // Will check later
                            metadata: metadata
                        });
                    }
                }

                // Update experiment badge
                const badge = document.getElementById('experiment-badge');
                badge.textContent = experimentName.replace(/_/g, ' ');

                console.log(`Loaded ${experimentData.traits.length} traits for ${experimentName}:`, experimentData.traits.map(t => t.name));

                // Populate trait checkboxes
                populateTraitCheckboxes();

                // Render view
                renderView();
            } catch (error) {
                console.error('Error loading experiment data:', error);
                showError(`Failed to load experiment: ${experimentName}`);
            }
        }

        // Render current view
        function renderView() {
            const contentArea = document.getElementById('content-area');

            switch (currentView) {
                case 'data-explorer':
                    renderDataExplorer();
                    break;
                case 'vectors':
                    renderVectors();
                    break;
                case 'monitoring':
                    renderMonitoring();
                    break;
                case 'layer-dive':
                    renderLayerDeepDive();
                    break;
            }
        }

        // Render Data Explorer
        async function renderDataExplorer() {
            const contentArea = document.getElementById('content-area');
            const filteredTraits = getFilteredTraits();

            // Calculate totals
            const totalTraits = experimentData.traits.length;
            const selectedCount = filteredTraits.length;
            const estimatedSize = (totalTraits * 47).toFixed(0); // ~47 MB per trait

            let html = `
                <div class="explanation">
                    <div class="explanation-summary">Browse complete extraction pipeline files (responses, activations, vectors)</div>
                    <div class="explanation-details">
                    <p>Browse the complete file structure for each trait's extraction pipeline.</p>

                    <h4>Directory Structure</h4>

                    <p><strong>trait_definition.json:</strong></p>
                    <p>Trait description, contrastive instructions, test questions, and evaluation prompt.</p>

                    <p><strong>responses/:</strong></p>
                    <p>Model responses to positive and negative prompts (CSV or JSON format).</p>

                    <p><strong>activations/:</strong></p>
                    <p>Captured layer activations \\(\\mathbf{A} \\in \\mathbb{R}^{n \\times d}\\) where \\(d=2304\\) (Gemma 2B hidden dim).</p>
                    <ul>
                        <li>27 layers √ó 2 sides (pos/neg) = 54 files</li>
                        <li>Token-averaged: \\(\\bar{\\mathbf{a}}_i = \\frac{1}{T} \\sum_{t=1}^T \\mathbf{h}_t^{(i)}\\)</li>
                    </ul>

                    <p><strong>vectors/:</strong></p>
                    <p>Extracted trait direction vectors.</p>
                    <ul>
                        <li>4 methods: mean_diff, probe, ica, gradient</li>
                        <li>27 layers per method</li>
                        <li>2 files per vector: .pt (tensor) + _metadata.json</li>
                    </ul>

                    <p><strong>Total per trait:</strong> ~47 MB (activations dominate storage)</p>
                    </div>
                <div class="card">
                    <div class="card-title">Dataset Overview</div>
                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-label">Total Traits</div>
                            <div class="stat-value">${totalTraits}</div>
                            <div class="stat-detail">${selectedCount} selected</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Estimated Storage</div>
                            <div class="stat-value">~${estimatedSize} MB</div>
                            <div class="stat-detail">~47 MB per trait</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Data Completeness</div>
                            <div class="stat-value">100%</div>
                            <div class="stat-detail">All files present</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Total Files</div>
                            <div class="stat-value">${totalTraits * 223}</div>
                            <div class="stat-detail">223 files per trait</div>
                        </div>
                    </div>
                <div class="card">
                    <div class="card-title">File Explorer</div>
                    <div class="info">
                        Click trait names to expand/collapse. Click file names to preview content.
                    </div>
                    <div style="margin-top: 20px;">
            `;

            // Render each trait
            filteredTraits.forEach(trait => {
                const displayName = getDisplayName(trait.name);
                const metadata = trait.metadata || {};

                html += `
                    <div class="explorer-trait-card">
                        <div class="explorer-trait-header" onclick="toggleTraitBody('${trait.name}')">
                            <div>
                                <strong>${displayName}</strong>
                                <span style="margin-left: 10px; font-size: 12px; opacity: 0.8;">
                                    ${metadata.n_examples || 0} examples | 223 files | ~47 MB
                                </span>
                            </div>
                            <span class="expand-icon" id="expand-icon-${trait.name}">‚ñ∂</span>
                        </div>
                        <div class="explorer-trait-body" id="trait-body-${trait.name}">
                            <div class="file-tree">
                                <div class="file-item">
                                    <span class="file-icon">üìÅ</span>
                                    <strong>${trait.name}/</strong>
                                </div>

                                <div class="file-item indent-1 clickable" onclick="previewJSON('${trait.name}', 'trait_definition')">
                                    <span class="file-icon">‚úì</span>
                                    <span>trait_definition.json</span>
                                    <span style="opacity: 0.6; font-size: 11px;">(~15 KB) [preview ‚Üí]</span>
                                </div>

                                <div class="file-item indent-1">
                                    <span class="file-icon">üìÅ</span>
                                    <strong>responses/</strong>
                                </div>
                                <div class="file-item indent-2 clickable" onclick="previewCSV('${trait.name}', 'pos')">
                                    <span class="file-icon">‚úì</span>
                                    <span>pos.csv</span>
                                    <span style="opacity: 0.6; font-size: 11px;">(${metadata.n_examples_pos || '?'} rows) [preview ‚Üí]</span>
                                </div>
                                <div class="file-item indent-2 clickable" onclick="previewCSV('${trait.name}', 'neg')">
                                    <span class="file-icon">‚úì</span>
                                    <span>neg.csv</span>
                                    <span style="opacity: 0.6; font-size: 11px;">(${metadata.n_examples_neg || '?'} rows) [preview ‚Üí]</span>
                                </div>

                                <div class="file-item indent-1">
                                    <span class="file-icon">üìÅ</span>
                                    <strong>activations/</strong>
                                </div>
                                <div class="file-item indent-2 clickable" onclick="previewJSON('${trait.name}', 'activations_metadata')">
                                    <span class="file-icon">‚úì</span>
                                    <span>metadata.json</span>
                                    <span style="opacity: 0.6; font-size: 11px;">(~400 B) [preview ‚Üí]</span>
                                </div>
                                <div class="file-item indent-2">
                                    <span class="file-icon">‚úì</span>
                                    <span>all_layers.pt</span>
                                    <span style="opacity: 0.6; font-size: 11px;">(~19 MB, shape: [${metadata.n_examples}, 27, 2304])</span>
                                </div>
                                <div class="file-item indent-2">
                                    <span class="file-icon">‚úì</span>
                                    <span>pos_acts.pt</span>
                                    <span style="opacity: 0.6; font-size: 11px;">(~12 MB, shape: [${metadata.n_examples_pos}, 27, 2304])</span>
                                </div>
                                <div class="file-item indent-2">
                                    <span class="file-icon">‚úì</span>
                                    <span>neg_acts.pt</span>
                                    <span style="opacity: 0.6; font-size: 11px;">(~11 MB, shape: [${metadata.n_examples_neg}, 27, 2304])</span>
                                </div>

                                <div class="file-item indent-1">
                                    <span class="file-icon">üìÅ</span>
                                    <strong>vectors/</strong>
                                    <span style="opacity: 0.6; font-size: 11px;">(216 files: 108 tensors + 108 metadata)</span>
                                </div>
                                <div class="file-item indent-2">
                                    <span class="file-icon">üìä</span>
                                    <span>4 methods √ó 27 layers:</span>
                                </div>
                                <div class="file-item indent-3">
                                    <span class="file-icon">‚úì</span>
                                    <span>mean_diff_layer[0-26].pt + metadata</span>
                                    <span style="opacity: 0.6; font-size: 11px;">(~9 KB each)</span>
                                </div>
                                <div class="file-item indent-3">
                                    <span class="file-icon">‚úì</span>
                                    <span>probe_layer[0-26].pt + metadata</span>
                                    <span style="opacity: 0.6; font-size: 11px;">(~20 KB each)</span>
                                </div>
                                <div class="file-item indent-3">
                                    <span class="file-icon">‚úì</span>
                                    <span>ica_layer[0-26].pt + metadata</span>
                                    <span style="opacity: 0.6; font-size: 11px;">(~186 KB each)</span>
                                </div>
                                <div class="file-item indent-3">
                                    <span class="file-icon">‚úì</span>
                                    <span>gradient_layer[0-26].pt + metadata</span>
                                    <span style="opacity: 0.6; font-size: 11px;">(~9 KB each, some NaN)</span>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            });

            html += `
                    </div>
                </div>
            `;

            contentArea.innerHTML = html;
            renderMath();
        }

        // Toggle trait body visibility
        function toggleTraitBody(traitName) {
            const body = document.getElementById(`trait-body-${traitName}`);
            const header = body.previousElementSibling;
            const icon = document.getElementById(`expand-icon-${traitName}`);

            if (body.classList.contains('show')) {
                body.classList.remove('show');
                header.classList.remove('expanded');
                icon.textContent = '‚ñ∂';
            } else {
                body.classList.add('show');
                header.classList.add('expanded');
                icon.textContent = '‚ñº';
            }
        }

        // Syntax highlight JSON
        function syntaxHighlightJSON(json) {
            if (typeof json !== 'string') {
                json = JSON.stringify(json, null, 2);
            }

            json = json.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

            return json.replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, function (match) {
                let cls = 'json-number';
                if (/^"/.test(match)) {
                    if (/:$/.test(match)) {
                        cls = 'json-key';
                    } else {
                        cls = 'json-string';
                    }
                } else if (/true|false/.test(match)) {
                    cls = 'json-boolean';
                } else if (/null/.test(match)) {
                    cls = 'json-null';
                }
                return '<span class="' + cls + '">' + match + '</span>';
            });
        }

        // Preview JSON file
        async function previewJSON(traitName, type) {
            const modal = document.getElementById('preview-modal');
            const title = document.getElementById('preview-title');
            const body = document.getElementById('preview-body');

            let url, displayName;
            if (type === 'trait_definition') {
                url = `../experiments/${experimentData.name}/${traitName}/extraction/trait_definition.json`;
                displayName = 'Trait Definition';
            } else if (type === 'activations_metadata') {
                url = `../experiments/${experimentData.name}/${traitName}/extraction/activations/metadata.json`;
                displayName = 'Activations Metadata';
            }

            title.textContent = `${traitName} - ${displayName}`;
            body.innerHTML = '<div class="loading">Loading...</div>';
            modal.classList.add('show');

            try {
                const response = await fetch(url);
                const data = await response.json();
                const highlighted = syntaxHighlightJSON(data);
                body.innerHTML = `<div class="json-viewer"><pre>${highlighted}</pre></div>`;
            } catch (error) {
                body.innerHTML = '<div class="error">Failed to load JSON file</div>';
            }
        }

        // Preview CSV file
        async function previewCSV(traitName, category) {
            const modal = document.getElementById('preview-modal');
            const title = document.getElementById('preview-title');
            const body = document.getElementById('preview-body');

            const url = `../experiments/${experimentData.name}/${traitName}/extraction/responses/${category}.csv`;
            const displayName = category === 'pos' ? 'Positive Examples' : 'Negative Examples';

            title.textContent = `${traitName} - ${displayName}`;
            body.innerHTML = '<div class="loading">Loading first 10 rows...</div>';
            modal.classList.add('show');

            try {
                const response = await fetch(url);
                const text = await response.text();
                const parsed = Papa.parse(text, { header: true });
                const rows = parsed.data.slice(0, 10);

                if (rows.length === 0) {
                    body.innerHTML = '<div class="error">No data found</div>';
                    return;
                }

                let tableHTML = '<table class="csv-table"><thead><tr>';
                const headers = Object.keys(rows[0]);
                headers.forEach(h => {
                    tableHTML += `<th>${h}</th>`;
                });
                tableHTML += '</tr></thead><tbody>';

                rows.forEach(row => {
                    tableHTML += '<tr>';
                    headers.forEach(h => {
                        let value = row[h] || '';
                        // Truncate long values
                        if (value.length > 100) {
                            value = value.substring(0, 100) + '...';
                        }
                        tableHTML += `<td>${value}</td>`;
                    });
                    tableHTML += '</tr>';
                });

                tableHTML += '</tbody></table>';
                tableHTML += `<div style="margin-top: 10px; color: var(--text-secondary); font-size: 12px;">Showing first 10 rows of ${parsed.data.length} total</div>`;

                body.innerHTML = tableHTML;
            } catch (error) {
                body.innerHTML = '<div class="error">Failed to load CSV file</div>';
            }
        }

        // Close preview modal
        function closePreview() {
            const modal = document.getElementById('preview-modal');
            modal.classList.remove('show');
        }

        // Close modal when clicking outside
        document.addEventListener('click', (e) => {
            const modal = document.getElementById('preview-modal');
            if (e.target === modal) {
                closePreview();
            }
        });

        // Render response quality view
        async function renderResponses() {
            const contentArea = document.getElementById('content-area');
            const filteredTraits = getFilteredTraits();

            if (filteredTraits.length === 0) {
                contentArea.innerHTML = `
                    <div class="card">
                        <div class="card-title">Response Quality Analysis</div>
                        <div class="info">No traits selected. Select traits in the sidebar to view them.</div>
                    </div>
                `;
                return;
            }

            // Show loading state
            contentArea.innerHTML = '<div class="loading">Loading response quality overview...</div>';

            // Load all trait separations
            const separations = {};
            const naturalTraits = [];
            for (const trait of filteredTraits) {
                try {
                    const { posData, negData, hasScores } = await loadResponseData(
                        experimentData.name,
                        trait.name,
                        trait.responseFormat
                    );

                    if (!hasScores) {
                        // Natural extraction has no scores - track separately
                        naturalTraits.push(trait.name);
                        continue;
                    }

                    const posScores = posData.map(r => parseFloat(r.trait_score)).filter(s => !isNaN(s));
                    const negScores = negData.map(r => parseFloat(r.trait_score)).filter(s => !isNaN(s));
                    const posAvg = posScores.reduce((a, b) => a + b, 0) / posScores.length;
                    const negAvg = negScores.reduce((a, b) => a + b, 0) / negScores.length;

                    separations[trait.name] = {
                        separation: posAvg - negAvg,
                        posAvg,
                        negAvg,
                        posCount: posData.length,
                        negCount: negData.length
                    };
                } catch (e) {
                    console.error(`Failed to load ${trait.name}:`, e);
                }
            }

            // Render overview
            let html = `
                <div class="explanation">
                    <div class="explanation-summary">LLM judge scores showing trait separation quality (positive vs negative examples)</div>
                    <div class="explanation-details">
                    <p>Measures how well responses exhibit the intended trait using LLM judge scores.</p>

                    <h4>Scoring Process</h4>
                    <p>For each response, an LLM judge (GPT-4) scores trait strength on 0-100 scale:</p>
                    <p>$$s_i = \\text{Judge}(\\text{question}_i, \\text{answer}_i, \\text{trait\\_def})$$</p>

                    <h4>Separation Metric</h4>
                    <p>$$\\text{Separation} = \\frac{1}{n}\\sum_{i=1}^n s_i^{\\text{pos}} - \\frac{1}{m}\\sum_{j=1}^m s_j^{\\text{neg}}$$</p>
                    <ul>
                        <li><strong>Positive examples:</strong> Should exhibit trait (high scores expected)</li>
                        <li><strong>Negative examples:</strong> Should avoid trait (low scores expected)</li>
                        <li><strong>Separation:</strong> Difference in mean scores</li>
                    </ul>

                    <h4>Quality Thresholds</h4>
                    <ul>
                        <li><strong>Excellent (>40):</strong> Clear trait expression difference</li>
                        <li><strong>Good (>20):</strong> Moderate separation</li>
                        <li><strong>Weak (<20):</strong> Poor separation, trait may be unclear</li>
                    </ul>

                    <p><strong>Note:</strong> Only instruction-based extraction has judge scores. Natural extraction has no scores (prompts are naturally contrasting).</p>
                    </div>
                <div class="card">
                    <div class="card-title">Response Quality Overview</div>
                    <table style="width: 100%; border-collapse: collapse; margin-top: 15px;">
                        <thead>
                            <tr style="border-bottom: 2px solid var(--border-color);">
                                <th style="text-align: left; padding: 10px; color: var(--text-secondary); font-weight: 600;">Trait</th>
                                <th style="text-align: right; padding: 10px; color: var(--text-secondary); font-weight: 600;">Separation (Mean)</th>
                                <th style="text-align: right; padding: 10px; color: var(--text-secondary); font-weight: 600;">Pos Mean</th>
                                <th style="text-align: right; padding: 10px; color: var(--text-secondary); font-weight: 600;">Neg Mean</th>
                                <th style="text-align: center; padding: 10px; color: var(--text-secondary); font-weight: 600;">Quality</th>
                            </tr>
                        </thead>
                        <tbody>
            `;

            Object.keys(separations).sort((a, b) => separations[b].separation - separations[a].separation).forEach(traitName => {
                const data = separations[traitName];
                const displayName = getDisplayName(traitName);
                const quality = data.separation > 40 ? 'Excellent' : data.separation > 20 ? 'Good' : 'Weak';
                const qualityColor = data.separation > 40 ? '#28a745' : data.separation > 20 ? '#ffc107' : '#dc3545';

                html += `
                    <tr style="border-bottom: 1px solid var(--border-color); cursor: pointer; transition: background 0.2s;"
                        onclick="loadTraitResponses('${traitName}')"
                        onmouseover="this.style.background='var(--bg-tertiary)'"
                        onmouseout="this.style.background='transparent'">
                        <td style="padding: 10px; color: var(--text-primary);">${displayName}</td>
                        <td style="padding: 10px; text-align: right; font-weight: 600; color: var(--text-primary);">${data.separation.toFixed(1)}</td>
                        <td style="padding: 10px; text-align: right; color: var(--text-secondary);">${data.posAvg.toFixed(1)}</td>
                        <td style="padding: 10px; text-align: right; color: var(--text-secondary);">${data.negAvg.toFixed(1)}</td>
                        <td style="padding: 10px; text-align: center;">
                            <span style="padding: 4px 8px; border-radius: 4px; font-size: 12px; font-weight: 600; background: ${qualityColor}20; color: ${qualityColor};">
                                ${quality}
                            </span>
                        </td>
                    </tr>
                `;
            });

            html += `
                        </tbody>
                    </table>
            `;

            // Add note about natural traits if any were excluded
            if (naturalTraits.length > 0) {
                html += `
                    <div class="info" style="margin-top: 20px; background: var(--bg-secondary); border-left: 4px solid #ffc107;">
                        <strong>Note:</strong> ${naturalTraits.length} natural extraction trait${naturalTraits.length > 1 ? 's' : ''} excluded from this view (no judge scores available):<br>
                        ${naturalTraits.map(t => getDisplayName(t)).join(', ')}
                    </div>
                `;
            }

            html += `
                    <div id="response-details"></div>
                </div>
            `;

            contentArea.innerHTML = html;
            renderMath();
            renderMath();
        }

        // Helper function to load response data in correct format (csv or json)
        async function loadResponseData(experimentName, traitName, responseFormat) {
            const extension = responseFormat || 'csv'; // Default to csv for backwards compatibility
            const [posResponse, negResponse] = await Promise.all([
                fetch(`../experiments/${experimentName}/${traitName}/extraction/responses/pos.${extension}`),
                fetch(`../experiments/${experimentName}/${traitName}/extraction/responses/neg.${extension}`)
            ]);

            if (!posResponse.ok || !negResponse.ok) {
                throw new Error(`Response files not found for ${traitName}`);
            }

            if (extension === 'json') {
                // JSON format (natural extraction)
                // Format: [{question, answer, full_text}, ...]
                // No trait_score available - natural extraction is unsupervised
                const posData = await posResponse.json();
                const negData = await negResponse.json();

                // Convert to format expected by rest of code
                return {
                    posData: posData.map(item => ({
                        prompt: item.question || '',
                        response: item.answer || '',
                        trait_score: null // Natural extraction has no scores
                    })),
                    negData: negData.map(item => ({
                        prompt: item.question || '',
                        response: item.answer || '',
                        trait_score: null // Natural extraction has no scores
                    })),
                    hasScores: false
                };
            } else {
                // CSV format (instruction-based extraction)
                const [posText, negText] = await Promise.all([
                    posResponse.text(),
                    negResponse.text()
                ]);
                return {
                    posData: Papa.parse(posText, { header: true }).data,
                    negData: Papa.parse(negText, { header: true }).data,
                    hasScores: true
                };
            }
        }

        // Load trait responses
        async function loadTraitResponses(traitName) {
            const detailsDiv = document.getElementById('response-details');
            detailsDiv.innerHTML = '<div class="loading">Loading response data...</div>';

            try {
                const trait = experimentData.traits.find(t => t.name === traitName);
                const { posData, negData } = await loadResponseData(
                    experimentData.name,
                    traitName,
                    trait?.responseFormat || 'csv'
                );

                renderResponseAnalysis(traitName, posData, negData);
            } catch (error) {
                console.error('Error loading responses:', error);
                detailsDiv.innerHTML = '<div class="error">Failed to load response data</div>';
            }
        }

        // Render response analysis
        function renderResponseAnalysis(traitName, posData, negData) {
            const detailsDiv = document.getElementById('response-details');
            const displayName = getDisplayName(traitName);

            // Calculate statistics (if scores available)
            const posScores = posData.map(r => parseFloat(r.trait_score)).filter(s => !isNaN(s));
            const negScores = negData.map(r => parseFloat(r.trait_score)).filter(s => !isNaN(s));

            const hasScores = posScores.length > 0 && negScores.length > 0;
            const posAvg = hasScores ? posScores.reduce((a, b) => a + b, 0) / posScores.length : null;
            const negAvg = hasScores ? negScores.reduce((a, b) => a + b, 0) / negScores.length : null;
            const separation = hasScores ? posAvg - negAvg : null;

            // Create histogram
            const histTrace1 = {
                x: posScores,
                type: 'histogram',
                name: 'Positive',
                marker: { color: '#28a745' },
                opacity: 0.7,
                nbinsx: 20
            };

            const histTrace2 = {
                x: negScores,
                type: 'histogram',
                name: 'Negative',
                marker: { color: '#dc3545' },
                opacity: 0.7,
                nbinsx: 20
            };

            let html = `
                <div style="margin-top: 30px;">
                    <div class="card-title">${displayName} - Response Quality</div>
            `;

            if (hasScores) {
                // Show stats and histogram for instruction-based extraction
                html += `
                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-label">Positive Examples</div>
                            <div class="stat-value">${posData.length}</div>
                            <div class="stat-detail">Avg score: ${posAvg.toFixed(1)}</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Negative Examples</div>
                            <div class="stat-value">${negData.length}</div>
                            <div class="stat-detail">Avg score: ${negAvg.toFixed(1)}</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Separation</div>
                            <div class="stat-value">${separation.toFixed(1)}</div>
                            <div class="stat-detail">${separation > 40 ? 'Excellent' : separation > 20 ? 'Good' : 'Weak'}</div>
                        </div>
                    </div>

                    <div id="score-histogram" style="margin-top: 20px;"></div>

                    <div style="margin-top: 20px;">
                        <h3 style="margin-bottom: 10px;">Sample Responses</h3>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                            <div>
                                <strong>High ${displayName} (Positive)</strong>
                                ${posData.slice(0, 3).map(r => `
                                    <div class="response-preview">
                                        <strong>Q:</strong> ${r.question || r.prompt || 'N/A'}<br>
                                        <strong>A:</strong> ${(r.response || 'N/A').substring(0, 150)}...
                                        <span class="score-badge score-high">${parseFloat(r.trait_score).toFixed(1)}</span>
                                    </div>
                                `).join('')}
                            </div>
                            <div>
                                <strong>Low ${displayName} (Negative)</strong>
                                ${negData.slice(0, 3).map(r => `
                                    <div class="response-preview">
                                        <strong>Q:</strong> ${r.question || r.prompt || 'N/A'}<br>
                                        <strong>A:</strong> ${(r.response || 'N/A').substring(0, 150)}...
                                        <span class="score-badge score-low">${parseFloat(r.trait_score).toFixed(1)}</span>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    </div>
                `;
            } else {
                // Natural extraction - no scores, just show examples
                html += `
                    <div class="info" style="margin-bottom: 20px;">
                        <strong>Natural Extraction:</strong> This trait was extracted using natural elicitation (no instructions, no judge scores).
                        Showing ${posData.length} positive and ${negData.length} negative examples.
                    </div>

                    <div style="margin-top: 20px;">
                        <h3 style="margin-bottom: 10px;">Sample Responses</h3>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                            <div>
                                <strong>High ${displayName} Scenarios (Positive)</strong>
                                ${posData.slice(0, 5).map(r => `
                                    <div class="response-preview">
                                        <strong>Q:</strong> ${r.prompt || 'N/A'}<br>
                                        <strong>A:</strong> ${(r.response || 'N/A').substring(0, 200)}...
                                    </div>
                                `).join('')}
                            </div>
                            <div>
                                <strong>Low ${displayName} Scenarios (Negative)</strong>
                                ${negData.slice(0, 5).map(r => `
                                    <div class="response-preview">
                                        <strong>Q:</strong> ${r.prompt || 'N/A'}<br>
                                        <strong>A:</strong> ${(r.response || 'N/A').substring(0, 200)}...
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    </div>
                `;
            }

            html += `
                </div>
            `;

            detailsDiv.innerHTML = html;

            // Render histogram (only if scores available)
            if (hasScores) {
                Plotly.newPlot('score-histogram', [histTrace1, histTrace2], getPlotlyLayout({
                    title: 'Trait Score Distribution',
                    xaxis: { title: 'Trait Score (0-100)' },
                    yaxis: { title: 'Count' },
                    barmode: 'overlay',
                    height: 400
                }), { displayModeBar: false });
            }
        }

        // Render vector analysis view
        async function renderVectors() {
            const contentArea = document.getElementById('content-area');
            const filteredTraits = getFilteredTraits();

            if (filteredTraits.length === 0) {
                contentArea.innerHTML = `
                    <div class="card">
                        <div class="card-title">Vector Analysis</div>
                        <div class="info">No traits selected. Select traits in the sidebar to view them.</div>
                    </div>
                `;
                return;
            }

            // Show loading state
            contentArea.innerHTML = '<div class="loading">Loading vector analysis overview...</div>';

            // Filter to only traits with vector extraction (check if vectors directory exists)
            // We'll do this by attempting to fetch one probe vector and seeing if it succeeds
            const traitsWithVectors = [];
            for (const trait of filteredTraits) {
                try {
                    const testUrl = `../experiments/${experimentData.name}/${trait.name}/extraction/vectors/probe_layer16_metadata.json`;
                    const testResponse = await fetch(testUrl);
                    if (testResponse.ok) {
                        traitsWithVectors.push(trait);
                    } else {
                        console.log(`Skipping ${trait.name} - no vectors directory`);
                    }
                } catch (e) {
                    console.log(`Skipping ${trait.name} - vector fetch failed`);
                }
            }

            if (traitsWithVectors.length === 0) {
                contentArea.innerHTML = `
                    <div class="card">
                        <div class="card-title">No Vector Extractions Found</div>
                        <div class="info">
                            No traits in this experiment have completed vector extraction.
                            Only traits with <code>extraction/vectors/</code> directories are shown here.
                        </div>
                    </div>
                `;
                return;
            }

            console.log(`Found ${traitsWithVectors.length} traits with vectors (out of ${filteredTraits.length} total)`);

            // Detect number of layers from experiment metadata
            const firstTrait = traitsWithVectors[0];
            const nLayers = firstTrait.metadata?.n_layers || 26;  // Default to 26 for Gemma 2B
            console.log(`Detected ${nLayers} layers from metadata`);

            // Load all vector metadata (parallel fetching for speed)
            const vectorMetrics = {};
            const methods = ['mean_diff', 'probe', 'ica', 'gradient'];
            const layers = Array.from({ length: nLayers }, (_, i) => i);

            // Fetch all metadata AND prompt examples in parallel
            const fetchPromises = traitsWithVectors.flatMap(trait => [
                // Vector metadata
                ...methods.flatMap(method =>
                    layers.map(layer => {
                        const url = `../experiments/${experimentData.name}/${trait.name}/extraction/vectors/${method}_layer${layer}_metadata.json`;
                        return fetch(url)
                            .then(r => {
                                if (!r.ok) console.warn(`Failed to fetch: ${url}`);
                                return r.ok ? r.json() : null;
                            })
                            .then(data => ({ type: 'vector', trait: trait.name, method, layer, data }))
                            .catch(e => {
                                console.error(`Error fetching ${url}:`, e);
                                return { type: 'vector', trait: trait.name, method, layer, data: null };
                            });
                    })
                ),
                // Prompt examples (first row of pos.csv and neg.csv)
                fetch(`../experiments/${experimentData.name}/${trait.name}/extraction/responses/pos.csv`)
                    .then(r => r.ok ? r.text() : null)
                    .then(text => {
                        if (!text) return null;
                        const lines = text.split('\n');
                        if (lines.length < 2) return null;
                        const headers = lines[0].split(',');
                        const values = lines[1].split(',');
                        const row = {};
                        headers.forEach((h, i) => row[h] = values[i]);
                        return { type: 'prompt', trait: trait.name, polarity: 'pos', data: row };
                    })
                    .catch(() => ({ type: 'prompt', trait: trait.name, polarity: 'pos', data: null })),
                fetch(`../experiments/${experimentData.name}/${trait.name}/extraction/responses/neg.csv`)
                    .then(r => r.ok ? r.text() : null)
                    .then(text => {
                        if (!text) return null;
                        const lines = text.split('\n');
                        if (lines.length < 2) return null;
                        const headers = lines[0].split(',');
                        const values = lines[1].split(',');
                        const row = {};
                        headers.forEach((h, i) => row[h] = values[i]);
                        return { type: 'prompt', trait: trait.name, polarity: 'neg', data: row };
                    })
                    .catch(() => ({ type: 'prompt', trait: trait.name, polarity: 'neg', data: null }))
            ]);

            const allResults = await Promise.all(fetchPromises);
            console.log(`Loaded ${allResults.length} results`);

            // Count successful loads
            const successfulVectors = allResults.filter(r => r.type === 'vector' && r.data !== null).length;
            console.log(`Successfully loaded ${successfulVectors} vector metadata files`);

            // Organize results by trait
            for (const trait of traitsWithVectors) {
                try {
                    const vectorData = {};
                    for (const method of methods) {
                        vectorData[method] = {};
                    }

                    // Fill in vector data from parallel fetch results
                    allResults
                        .filter(r => r.type === 'vector' && r.trait === trait.name && r.data !== null)
                        .forEach(r => {
                            vectorData[r.method][r.layer] = r.data;
                        });

                    // Extract prompt examples
                    const prompts = {};
                    allResults
                        .filter(r => r.type === 'prompt' && r.trait === trait.name && r.data !== null)
                        .forEach(r => {
                            prompts[r.polarity] = r.data;
                        });

                    // Calculate best layer for each method
                    const best = {};
                    methods.forEach(method => {
                        let bestLayer = -1;
                        let bestValue = -Infinity;
                        layers.forEach(layer => {
                            if (vectorData[method][layer]) {
                                const metadata = vectorData[method][layer];
                                let value;
                                if (method === 'probe') {
                                    // Invert: smaller norm = stronger
                                    value = metadata.vector_norm ? (1.0 / metadata.vector_norm) : 0;
                                } else if (method === 'gradient') {
                                    // Use separation (unit normalized)
                                    value = metadata.final_separation || metadata.vector_norm;
                                } else {
                                    // Use magnitude
                                    value = metadata.vector_norm;
                                }
                                if (!isNaN(value) && value > bestValue) {
                                    bestValue = value;
                                    bestLayer = layer;
                                }
                            }
                        });
                        best[method] = { layer: bestLayer, norm: bestValue };
                    });

                    vectorMetrics[trait.name] = { vectorData, best, prompts };
                } catch (e) {
                    console.error(`Failed to load ${trait.name}:`, e);
                }
            }

            // Render overview with mini heatmaps
            let html = `
                <div class="explanation">
                    <div class="explanation-summary">Compare 4 vector extraction methods (mean_diff, probe, ICA, gradient) across all ${nLayers} layers</div>
                    <div class="explanation-details">
                        <div style="background: var(--bg-secondary); padding: 12px; border-left: 3px solid var(--primary-color); margin-bottom: 15px; border-radius: 4px;">
                            <strong>Layer Architecture Intuition:</strong>
                            <ul style="margin: 8px 0 0 0; padding-left: 20px;">
                                <li><strong>Early layers (0-5):</strong> Syntax, local patterns, token-level features</li>
                                <li><strong>Middle layers (6-15):</strong> Semantic understanding, entity recognition, basic reasoning</li>
                                <li><strong>Late layers (16-24):</strong> Abstract concepts, complex reasoning, behavioral traits (refusal, uncertainty)</li>
                                <li><strong>Final layer (25):</strong> Projection towards output vocabulary (often degrades semantic quality)</li>
                            </ul>
                        </div>
                        <p>Four approaches to extract trait direction vectors from activations \\(\\mathbf{A}_{\\text{pos}} \\in \\mathbb{R}^{n \\times d}\\) and \\(\\mathbf{A}_{\\text{neg}} \\in \\mathbb{R}^{m \\times d}\\):</p>

                        <h4>1. Mean Difference</h4>
                        <p>$$\\mathbf{v}_{\\text{mean}} = \\frac{1}{n}\\sum_{i=1}^n \\mathbf{a}_i^{\\text{pos}} - \\frac{1}{m}\\sum_{j=1}^m \\mathbf{a}_j^{\\text{neg}}$$</p>
                        <ul>
                            <li>Simple cluster center separation</li>
                            <li>Unnormalized (typical norm ‚âà 50-100)</li>
                            <li>Fast, no training required</li>
                        </ul>

                        <h4>2. Probe (Linear Classifier)</h4>
                        <p>$$\\mathbf{v}_{\\text{probe}} = \\arg\\min_{\\mathbf{w}} \\sum_i \\log(1 + e^{-y_i \\mathbf{w}^T \\mathbf{a}_i}) + \\lambda \\|\\mathbf{w}\\|_2^2$$</p>
                        <ul>
                            <li>Logistic regression weights (L2-regularized)</li>
                            <li>Normalized during training (norm ‚âà 1-5)</li>
                            <li>Maximizes linear separability</li>
                        </ul>

                        <h4>3. ICA (Independent Components)</h4>
                        <p>$$\\mathbf{v}_{\\text{ica}} = \\text{FastICA}([\\mathbf{A}_{\\text{pos}}; \\mathbf{A}_{\\text{neg}}])[k]$$</p>
                        <ul>
                            <li>Extracts statistically independent components</li>
                            <li>Disentangles mixed trait signals via negentropy maximization</li>
                            <li>Variable norm depending on component strength</li>
                        </ul>

                        <h4>4. Gradient (Optimization)</h4>
                        <p>$$\\mathbf{v}_{\\text{grad}} = \\arg\\min_{\\mathbf{v}} \\mathcal{L}(\\mathbf{v}) \\text{ where } \\mathcal{L} = \\|\\mathbf{v}^T \\mathbf{A}_{\\text{pos}} - \\alpha\\|^2 + \\|\\mathbf{v}^T \\mathbf{A}_{\\text{neg}}\\|^2$$</p>
                        <ul>
                            <li>Custom objective via gradient descent</li>
                            <li>Unit normalized (norm = 1.0)</li>
                            <li>Can fail (NaN) if gradients vanish</li>
                        </ul>

                        <p><strong>Visualization:</strong> Each method is normalized independently (0-100% of that method's max across layers) to show within-method layer strength. Darker = stronger for that method at that layer.</p>
                        <ul>
                            <li><strong>Probe:</strong> Inverted vector norm (smaller norm = stronger classifier due to L2 regularization)</li>
                            <li><strong>Gradient:</strong> Separation strength (vectors are unit normalized, norm = 1.0)</li>
                            <li><strong>Mean Diff & ICA:</strong> Vector magnitude (direction strength in activation space)</li>
                        </ul>

                        <p><strong>Note:</strong> All vectors extracted from token-averaged activations: \\(\\bar{\\mathbf{a}}_i = \\frac{1}{T} \\sum_{t=1}^T \\mathbf{h}_t^{(i)}\\)</p>
                    </div>
                <div class="card">
                    <div class="card-title">Vector Analysis Overview</div>
                    <div class="info">
                        Vector norms across ${nLayers} layers and 4 extraction methods. Click a row for detailed view.
                    </div>
                    <div style="margin-top: 15px;">
            `;

            traitsWithVectors.forEach(trait => {
                const displayName = getDisplayName(trait.name);
                const metrics = vectorMetrics[trait.name];
                if (!metrics) {
                    console.warn(`No metrics for ${trait.name}`);
                    return;
                }

                const best = metrics.best;

                // Check if we have any valid data
                const hasData = Object.values(best).some(b => b.layer !== -1 && b.norm !== -Infinity);
                if (!hasData) {
                    console.warn(`No valid vector data for ${trait.name}`);
                    return;
                }

                const bestMethod = Object.keys(best).reduce((a, b) =>
                    best[a].norm > best[b].norm ? a : b
                );

                // Build compact prompt examples
                let examplesHtml = '<div style="font-size: 11px; color: var(--text-secondary);">No examples</div>';
                if (metrics.prompts && metrics.prompts.pos && metrics.prompts.neg) {
                    const posInstruction = (metrics.prompts.pos.instruction || '').substring(0, 60);
                    const negInstruction = (metrics.prompts.neg.instruction || '').substring(0, 60);
                    examplesHtml = `
                        <div style="font-size: 11px; color: var(--text-secondary); line-height: 1.4;">
                            <div style="margin-bottom: 3px;"><strong style="color: var(--primary-color);">+</strong> ${posInstruction}...</div>
                            <div><strong style="color: var(--accent-color);">‚àí</strong> ${negInstruction}...</div>
                        </div>
                    `;
                }

                html += `
                    <div style="display: grid; grid-template-columns: 180px 1fr 320px; gap: 15px; padding: 12px; border-bottom: 1px solid var(--border-color); cursor: pointer; transition: background 0.2s;"
                         onclick="loadVectorAnalysis('${trait.name}')"
                         onmouseover="this.style.background='var(--bg-secondary)'"
                         onmouseout="this.style.background='transparent'">

                        <div style="display: flex; flex-direction: column; justify-content: center;">
                            <div style="font-weight: 600; color: var(--text-primary); margin-bottom: 4px;">${displayName}</div>
                            <div style="font-size: 11px; color: var(--text-secondary);">
                                Best: ${bestMethod.replace(/_/g, ' ')} L${best[bestMethod].layer}
                            </div>
                        </div>

                        <div id="mini-heatmap-${trait.name}" style="height: 100px;"></div>

                        <div style="display: flex; align-items: center;">
                            ${examplesHtml}
                        </div>
                    </div>
                `;
            });

            html += `
                    </div>
                    <div id="vector-details"></div>
                </div>
            `;

            contentArea.innerHTML = html;
            renderMath();
            renderMath();

            // Render mini heatmaps (normalized per method)
            traitsWithVectors.forEach(trait => {
                const metrics = vectorMetrics[trait.name];
                if (!metrics) {
                    console.warn(`No metrics for trait: ${trait.name}`);
                    return;
                }

                console.log(`Rendering heatmap for ${trait.name}:`, metrics);
                const methods = Object.keys(metrics.vectorData);
                if (methods.length === 0) {
                    console.warn(`No methods found for trait: ${trait.name}`);
                    return;
                }
                // Use detected number of layers
                const layers = Array.from({ length: nLayers }, (_, i) => i);

                // Normalize each method independently (0-100% of that method's max)
                // Probe: invert norm (smaller = stronger due to L2 regularization)
                // Gradient: use final_separation (unit normalized, so norm is always 1.0)
                // Mean_diff & ICA: use vector_norm
                const normalizedData = layers.map(layer => {
                    return methods.map(method => {
                        const metadata = metrics.vectorData[method][layer];
                        if (!metadata) return null;

                        if (method === 'probe') {
                            // Invert: smaller norm = stronger classifier
                            return metadata.vector_norm ? (1.0 / metadata.vector_norm) : null;
                        } else if (method === 'gradient') {
                            // Use separation (vectors are unit normalized)
                            return metadata.final_separation || metadata.vector_norm;
                        } else {
                            // Use vector magnitude
                            return metadata.vector_norm;
                        }
                    });
                });

                // Find max for each method
                const maxPerMethod = methods.map((method, methodIdx) => {
                    const values = normalizedData.map(row => row[methodIdx]).filter(v => v !== null);
                    return values.length > 0 ? Math.max(...values) : 1;
                });

                // Normalize each column by its max
                const heatmapData = normalizedData.map(row => {
                    return row.map((value, methodIdx) => {
                        if (value === null) return null;
                        return (value / maxPerMethod[methodIdx]) * 100; // Percentage of method's max
                    });
                });

                // Transpose for horizontal layout: methods become rows (y), layers become columns (x)
                const trace = {
                    z: heatmapData[0].map((_, methodIdx) =>
                        heatmapData.map(row => row[methodIdx])
                    ),
                    x: layers,
                    y: methods.map(m => m.replace(/_/g, ' ')),
                    type: 'heatmap',
                    colorscale: 'Viridis',
                    showscale: false,
                    hovertemplate: '%{y}<br>Layer %{x}<br>%{z:.1f}%<extra></extra>',
                    zmin: 0,
                    zmax: 100
                };

                Plotly.newPlot(`mini-heatmap-${trait.name}`, [trace], getPlotlyLayout({
                    margin: { l: 70, r: 5, t: 5, b: 25 },
                    xaxis: {
                        title: '',
                        showticklabels: true,
                        tickmode: 'linear',
                        dtick: 5,  // Show every 5th layer
                        tickfont: { size: 9 }
                    },
                    yaxis: { title: '', side: 'left' },
                    height: 100
                }), { displayModeBar: false });
            });
        }

        // Load vector analysis
        async function loadVectorAnalysis(traitName) {
            const detailsDiv = document.getElementById('vector-details');
            detailsDiv.innerHTML = '<div class="loading">Loading vector metadata...</div>';

            try {
                // Get trait metadata to determine number of layers
                const trait = experimentData.traits.find(t => t.name === traitName);
                const nLayers = trait?.metadata?.n_layers || 26;
                console.log(`Loading vector analysis for ${traitName} (${nLayers} layers)`);

                const methods = ['mean_diff', 'probe', 'ica', 'gradient'];
                const layers = Array.from({ length: nLayers }, (_, i) => i);

                const vectorData = {};

                for (const method of methods) {
                    vectorData[method] = {};
                    for (const layer of layers) {
                        try {
                            const response = await fetch(
                                `../experiments/${experimentData.name}/${traitName}/extraction/vectors/${method}_layer${layer}_metadata.json`
                            );
                            if (response.ok) {
                                vectorData[method][layer] = await response.json();
                            }
                        } catch (e) {
                            // Vector doesn't exist
                        }
                    }
                }

                renderVectorHeatmap(traitName, vectorData);
            } catch (error) {
                console.error('Error loading vectors:', error);
                detailsDiv.innerHTML = '<div class="error">Failed to load vector data</div>';
            }
        }

        // Render vector heatmap (normalized per method)
        function renderVectorHeatmap(traitName, vectorData) {
            const detailsDiv = document.getElementById('vector-details');
            const displayName = getDisplayName(traitName);

            const methods = Object.keys(vectorData);
            // Detect number of layers from actual data
            const nLayers = Object.keys(vectorData[methods[0]] || {}).length;
            const layers = Array.from({ length: nLayers }, (_, i) => i);

            // Collect raw metrics
            // Probe: invert norm (smaller = stronger due to L2 regularization)
            // Gradient: use final_separation (unit normalized, norm always 1.0)
            // Mean_diff & ICA: use vector_norm
            const rawData = layers.map(layer => {
                return methods.map(method => {
                    const metadata = vectorData[method][layer];
                    if (!metadata) return null;

                    if (method === 'probe') {
                        return metadata.vector_norm ? (1.0 / metadata.vector_norm) : null;
                    } else if (method === 'gradient') {
                        return metadata.final_separation || metadata.vector_norm;
                    } else {
                        return metadata.vector_norm;
                    }
                });
            });

            // Find max for each method
            const maxPerMethod = methods.map((method, methodIdx) => {
                const values = rawData.map(row => row[methodIdx]).filter(v => v !== null);
                return values.length > 0 ? Math.max(...values) : 1;
            });

            // Normalize each column by its max (0-100%)
            const normalizedData = rawData.map(row => {
                return row.map((value, methodIdx) => {
                    if (value === null) return null;
                    return (value / maxPerMethod[methodIdx]) * 100;
                });
            });

            // Also store raw values for hover
            const customData = rawData.map((row, layerIdx) => {
                return row.map((value, methodIdx) => {
                    return {
                        raw: value,
                        max: maxPerMethod[methodIdx],
                        layer: layers[layerIdx],
                        method: methods[methodIdx]
                    };
                });
            });

            const trace = {
                z: normalizedData,
                x: methods.map(m => m.replace(/_/g, ' ').toUpperCase()),
                y: layers,
                type: 'heatmap',
                colorscale: 'Viridis',
                hovertemplate: 'Method: %{x}<br>Layer %{y}<br>Strength: %{z:.1f}% of max<br>Raw norm: %{customdata.raw:.2f}<br>Max for method: %{customdata.max:.2f}<extra></extra>',
                customdata: customData,
                zmin: 0,
                zmax: 100,
                colorbar: {
                    title: '% of Max',
                    titleside: 'right'
                }
            };

            let html = `
                <div style="margin-top: 30px;">
                    <div class="card-title">${displayName} - Vector Strength by Method & Layer</div>
                    <div class="info" style="margin-top: 10px; font-size: 13px;">
                        Each method normalized independently (0-100% of that method's max across layers).
                        This shows which layers are strongest for each method, not cross-method comparisons.
                    </div>
                    <div id="vector-heatmap" style="margin-top: 20px;"></div>
                </div>
            `;

            detailsDiv.innerHTML = html;

            Plotly.newPlot('vector-heatmap', [trace], getPlotlyLayout({
                title: 'Normalized Vector Strength (% of Method Max)',
                xaxis: { title: 'Extraction Method' },
                yaxis: { title: 'Layer' },  // Layer 0 at bottom, layer N at top
                height: 600
            }), { displayModeBar: false });
        }

        // Render monitoring view
        async function renderMonitoring() {
            const contentArea = document.getElementById('content-area');
            const filteredTraits = getFilteredTraits();

            if (filteredTraits.length === 0) {
                contentArea.innerHTML = `
                    <div class="card">
                        <div class="card-title">All Layers</div>
                        <div class="info">Select at least one trait to view trajectories</div>
                    </div>
                `;
                return;
            }

            // Try to find Tier 2 data for the first selected trait
            const trait = filteredTraits[0];
            const tier2Dir = `../experiments/${experimentData.name}/${trait.name}/inference/residual_stream_activations/`;

            // Try to load prompt_0.json
            try {
                const fetchPath = `${tier2Dir}prompt_0.json`;
                console.log('Fetching trajectory data from:', fetchPath);
                const response = await fetch(fetchPath);
                console.log('Fetch response status:', response.status, response.statusText);
                if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);

                const data = await response.json();
                console.log('Trajectory data loaded successfully:', data);
                renderTier2Data(trait, data);
            } catch (error) {
                // No data yet - show instructions
                console.error('Failed to load trajectory data:', error);
                renderTier2Instructions(trait);
            }
        }

        function renderTier2Instructions(trait) {
            const contentArea = document.getElementById('content-area');
            // Get layer count from metadata
            const nLayers = trait.metadata?.n_layers || 26;
            const nCheckpoints = nLayers * 3;

            contentArea.innerHTML = `
                <div class="explanation">
                    <div class="explanation-summary">Monitor trait evolution across all ${nLayers} layers during generation (${nCheckpoints} sublayer checkpoints)</div>
                    <div class="explanation-details">

                    <h4>Method</h4>
                    <p>At each token position \\(t\\) and layer \\(\\ell\\), compute trait projection:</p>
                    <p>$$s_t^{(\\ell)} = \\frac{\\mathbf{h}_t^{(\\ell)} \\cdot \\mathbf{v}}{\\|\\mathbf{v}\\|}$$</p>
                    <p>where \\(\\mathbf{h}_t^{(\\ell)} \\in \\mathbb{R}^d\\) is the activation at token \\(t\\), layer \\(\\ell\\).</p>

                    <h4>Sublayer Checkpoints</h4>
                    <p>Captures 3 internal states per layer:</p>
                    <ul>
                        <li><strong>Pre-Attention:</strong> \\(\\mathbf{h}_t^{(\\ell, \\text{pre})}\\) - Before self-attention</li>
                        <li><strong>Post-Attention:</strong> \\(\\mathbf{h}_t^{(\\ell, \\text{attn})} = \\mathbf{h}_t^{(\\ell, \\text{pre})} + \\text{Attn}(\\mathbf{h}_t^{(\\ell, \\text{pre})})\\) - After attention residual</li>
                        <li><strong>Post-MLP:</strong> \\(\\mathbf{h}_t^{(\\ell, \\text{mlp})} = \\mathbf{h}_t^{(\\ell, \\text{attn})} + \\text{MLP}(\\mathbf{h}_t^{(\\ell, \\text{attn})})\\) - After MLP residual</li>
                    </ul>
                    <p>Total: ${nLayers} layers √ó 3 sublayers = ${nCheckpoints} checkpoints per token</p>

                    <h4>Visualization</h4>
                    <ul>
                        <li><strong>Heatmap:</strong> Rows = layers/sublayers, Columns = tokens, Color = \\(s_t^{(\\ell)}\\)</li>
                        <li>Shows trait emergence across layers and evolution during generation</li>
                        <li>Reveals which layers contribute most to trait expression</li>
                    </ul>
                    </div>
                <div class="card">
                    <div class="card-title">All Layers: ${getDisplayName(trait.name)}</div>

                    <div class="info" style="margin-bottom: 20px;">
                        <strong>‚ö†Ô∏è No trajectory data available for ${trait.name}</strong>
                    </div>

                    <div style="background: var(--bg-tertiary); padding: 20px; border-radius: 8px;">
                        <h3 style="color: var(--text-primary); margin-bottom: 15px;">Generate Trajectory Data</h3>
                        <p style="color: var(--text-secondary); margin-bottom: 15px;">
                            Capture per-token projections at all ${nCheckpoints} checkpoints (${nLayers} layers √ó 3 sublayers):
                        </p>
                        <pre style="background: var(--bg-primary); color: var(--text-primary); padding: 15px; border-radius: 4px; margin: 15px 0; overflow-x: auto; border: 1px solid var(--border-color);">python inference/capture_tier2.py \\
  --experiment ${experimentData.name} \\
  --trait ${trait.name} \\
  --prompts "What is the capital of France?" \\
  --save-json</pre>
                        <p style="color: var(--text-secondary); margin-top: 15px;">
                            The <code style="background: var(--bg-primary); padding: 2px 6px; border-radius: 3px;">--save-json</code> flag creates visualization-friendly JSON files alongside the .pt files.
                        </p>
                        <p style="color: var(--text-tertiary); font-size: 13px; margin-top: 10px;">
                            This captures how ${getDisplayName(trait.name)} evolves through ALL layers during both prompt encoding and response generation.
                        </p>
                    </div>
                </div>
            `;
        }

        function renderTier2Data(trait, data) {
            const contentArea = document.getElementById('content-area');

            try {
                const promptProj = data.projections.prompt;  // [n_tokens, n_layers, 3]
                const responseProj = data.projections.response;
                console.log('Prompt projections shape:', promptProj.length, 'tokens x', promptProj[0].length, 'layers x', promptProj[0][0].length, 'sublayers');
                console.log('Response projections shape:', responseProj.length, 'tokens x', responseProj[0].length, 'layers x', responseProj[0][0].length, 'sublayers');

            // Combine prompt and response projections and tokens
            const allTokens = [...data.prompt.tokens, ...data.response.tokens];
            const allProj = [...promptProj, ...responseProj];
            const nPromptTokens = data.prompt.n_tokens;
            const nTotalTokens = allTokens.length;
            const nLayers = promptProj[0].length;  // Detect from data
            const nCheckpoints = nLayers * 3;

            contentArea.innerHTML = `
                <div class="card">
                    <div class="card-title">All Layers: ${getDisplayName(trait.name)}</div>

                    <!-- Conversation context - compact -->
                    <div style="background: var(--bg-tertiary); padding: 8px 12px; border-radius: 6px; margin-bottom: 12px;">
                        <div style="color: var(--text-primary); font-size: 14px; font-weight: 500; margin-bottom: 3px;">${data.prompt.text} ${data.response.text}</div>
                        <div style="color: var(--text-secondary); font-size: 11px;">
                            ${data.prompt.n_tokens} prompt + ${data.response.n_tokens} response = ${nTotalTokens} tokens ‚Ä¢ Vector: ${data.metadata.vector_path.split('/').pop()}
                        </div>
                    </div>

                    <!-- Unified slider control - compact -->
                    <div style="background: var(--bg-tertiary); padding: 10px 12px; border-radius: 6px; margin-bottom: 15px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                            <label style="color: var(--text-secondary); font-size: 12px; font-weight: 500;">
                                Position: <span id="unified-slider-value" style="color: var(--primary-color);">0</span>/${nTotalTokens - 1}
                            </label>
                            <span style="color: var(--text-secondary); font-size: 11px;">
                                "<span id="unified-slider-token" style="font-weight: 600;">${allTokens[0]}</span>"
                                <span id="unified-slider-phase" style="color: var(--text-tertiary); margin-left: 8px;">[Prompt]</span>
                            </span>
                        </div>
                        <input type="range" id="unified-slider" min="0" max="${nTotalTokens - 1}" value="0"
                               style="width: 100%; height: 2px; border-radius: 2px; background: var(--border-color);">
                    </div>

                    <div id="trajectory-heatmap" style="margin-bottom: 20px;"></div>

                    <!-- Logit Lens Visualization - compact -->
                    <div id="logit-lens-container" style="display: none; margin-bottom: 20px; border-top: 1px solid var(--border-color); padding-top: 15px;">
                        <h3 style="color: var(--text-primary); margin-bottom: 5px; font-size: 14px;">
                            Prediction for Token <span id="logit-token-num">1</span>: "<span id="logit-token-text">...</span>"
                        </h3>
                        <p style="color: var(--text-secondary); margin-bottom: 10px; font-size: 11px;">
                            Top-3 predictions across layers (commitment point = final prediction locks in)
                        </p>
                        <div id="logit-lens-plot"></div>
                    </div>

                    <div id="attention-viewer"></div>
                </div>
            `;

            // Render combined trajectory heatmap with separator line
            renderCombinedTrajectoryHeatmap('trajectory-heatmap', allProj, allTokens, nPromptTokens);

            // Render attention viewer if data available
            if (data.attention_weights) {
                renderAttentionViewer('attention-viewer', data, allTokens, nPromptTokens);
            }

            // Setup unified slider control
            setupUnifiedSlider(data, allTokens, nPromptTokens, nTotalTokens);
            } catch (error) {
                console.error('Error rendering trajectory data:', error);
                contentArea.innerHTML = `<div class="card"><div class="card-title">Error</div><div class="info">Failed to render trajectory data: ${error.message}</div></div>`;
            renderMath();
            }
        }

        function renderCombinedTrajectoryHeatmap(divId, projections, tokens, nPromptTokens) {
            // projections: [n_tokens, n_layers, 3_sublayers]
            // We'll show layer-averaged (average over 3 sublayers)

            const nTokens = projections.length;
            const nLayers = projections[0].length;  // Dynamically get number of layers
            console.log(`Rendering combined trajectory heatmap for ${nTokens} tokens x ${nLayers} layers (${nPromptTokens} prompt + ${nTokens - nPromptTokens} response)`);

            // Average over sublayers to get [n_tokens, n_layers]
            // Skip BOS token (index 0) for better visualization dynamic range
            const startIdx = 1;  // Skip <bos>

            const layerAvg = [];
            for (let t = startIdx; t < nTokens; t++) {
                layerAvg[t - startIdx] = [];
                for (let l = 0; l < nLayers; l++) {
                    const avg = (projections[t][l][0] + projections[t][l][1] + projections[t][l][2]) / 3;
                    layerAvg[t - startIdx][l] = avg;
                }
            }

            // Transpose for heatmap: [n_layers, n_tokens-1] (excluding BOS)
            const heatmapData = [];
            const nDisplayTokens = nTokens - startIdx;
            for (let l = 0; l < nLayers; l++) {
                heatmapData[l] = [];
                for (let t = 0; t < nDisplayTokens; t++) {
                    heatmapData[l][t] = layerAvg[t][l];
                }
            }

            // Create shapes array for separator line and current token highlight
            const shapes = [
                // Vertical line separating prompt and response (adjusted for skipped BOS)
                {
                    type: 'line',
                    xref: 'x',
                    yref: 'paper',
                    x0: (nPromptTokens - startIdx) - 0.5,
                    x1: (nPromptTokens - startIdx) - 0.5,
                    y0: 0,
                    y1: 1,
                    line: {
                        color: 'rgba(255, 255, 255, 0.5)',
                        width: 2,
                        dash: 'dash'
                    }
                },
                // Highlight for current token (will be updated by slider)
                {
                    type: 'rect',
                    xref: 'x',
                    yref: 'paper',
                    x0: -0.5,
                    x1: 0.5,
                    y0: 0,
                    y1: 1,
                    fillcolor: 'rgba(74, 158, 255, 0.2)',
                    line: { width: 0 },
                    name: 'token-highlight'  // ID for updating
                }
            ];

            const data = [{
                z: heatmapData,
                x: tokens.slice(startIdx),  // Skip BOS in token labels too
                y: Array.from({length: nLayers}, (_, i) => `L${i}`),
                type: 'heatmap',
                colorscale: 'RdBu',
                zmid: 0,
                hovertemplate: 'Token: %{x}<br>Layer: %{y}<br>Score: %{z:.2f}<extra></extra>'
            }];

            const layout = getPlotlyLayout({
                title: 'Trait Trajectory',
                xaxis: {
                    title: 'Tokens',
                    tickangle: -45
                },
                yaxis: {
                    title: 'Layer'
                },
                shapes: shapes,
                height: 400,
                margin: { t: 40, b: 80, l: 50, r: 20 }
            });

            Plotly.newPlot(divId, data, layout, {displayModeBar: false});
        }

        function renderAttentionViewer(divId, data, allTokens, nPromptTokens) {
            // Get number of layers
            const nLayers = Object.keys(data.attention_weights.prompt).length;

            const html = `
                <div style="border-top: 1px solid var(--border-color); padding-top: 15px; margin-top: 20px;">
                    <h3 style="color: var(--text-primary); margin-bottom: 5px; font-size: 14px;">Attention Patterns</h3>
                    <p style="color: var(--text-secondary); margin-bottom: 10px; font-size: 11px;">
                        Selected token's attention to context (controlled by slider above)
                    </p>
                    <div id="attention-heatmap"></div>
                </div>
            `;

            document.getElementById(divId).innerHTML = html;

            // Function to render attention heatmap for a specific token
            window.updateAttentionHeatmap = function(tokenIdx) {
                // Get attention data for this token
                let attnData;  // [n_layers, n_context]
                let contextTokens;

                if (tokenIdx < nPromptTokens) {
                    // Prompt token - extract from full attention matrix
                    // Data structure: prompt[layer_X] is [n_tokens, n_tokens] matrix
                    attnData = [];
                    for (let layer = 0; layer < nLayers; layer++) {
                        const layerAttnMatrix = data.attention_weights.prompt[`layer_${layer}`];

                        if (!layerAttnMatrix || !layerAttnMatrix[tokenIdx]) {
                            console.warn(`Missing attention data for prompt token ${tokenIdx}, layer ${layer}`);
                            attnData.push(new Array(tokenIdx + 1).fill(0));
                            continue;
                        }

                        // Extract this token's attention row, only up to current position (causal)
                        const tokenAttn = layerAttnMatrix[tokenIdx].slice(0, tokenIdx + 1);
                        attnData.push(tokenAttn);
                    }
                    contextTokens = data.prompt.tokens.slice(0, tokenIdx + 1);
                } else {
                    // Response token - already stored as single attention vector
                    // Data structure: response[token_idx][layer_X] is [context_length] vector
                    const responseIdx = tokenIdx - nPromptTokens;
                    attnData = [];
                    for (let layer = 0; layer < nLayers; layer++) {
                        const stepAttn = data.attention_weights.response[responseIdx];

                        if (!stepAttn || !stepAttn[`layer_${layer}`]) {
                            console.warn(`Missing attention data for response token ${responseIdx}, layer ${layer}`);
                            attnData.push(new Array(tokenIdx + 1).fill(0));
                            continue;
                        }

                        const layerAttn = stepAttn[`layer_${layer}`];
                        attnData.push(layerAttn);
                    }
                    contextTokens = allTokens.slice(0, tokenIdx + 1);
                }

                // Validate data dimensions
                const expectedContextLen = tokenIdx + 1;
                let hasValidData = true;
                for (let i = 0; i < attnData.length; i++) {
                    if (!attnData[i] || attnData[i].length !== expectedContextLen) {
                        console.warn(`Layer ${i} attention length mismatch: expected ${expectedContextLen}, got ${attnData[i]?.length || 0}`);
                        hasValidData = false;
                    }
                }

                if (!hasValidData) {
                    console.error('Attention data validation failed, displaying with available data');
                }

                // Create heatmap
                const trace = {
                    z: attnData,
                    x: contextTokens,
                    y: Array.from({length: nLayers}, (_, i) => `L${i}`),
                    type: 'heatmap',
                    colorscale: 'Viridis',
                    hovertemplate: 'Context Token: %{x}<br>Layer: %{y}<br>Attention: %{z:.4f}<extra></extra>',
                    colorbar: {
                        title: 'Attention Weight'
                    }
                };

                const layout = getPlotlyLayout({
                    title: `"${allTokens[tokenIdx]}" (pos ${tokenIdx})`,
                    xaxis: {
                        title: 'Context',
                        tickangle: -45,
                        side: 'bottom'
                    },
                    yaxis: {
                        title: 'Layer'
                    },
                    height: 350,
                    margin: { t: 40, b: 80, l: 50, r: 20 }
                });

                Plotly.newPlot('attention-heatmap', [trace], layout, { displayModeBar: false });
            }

            // Initialize with first token
            window.updateAttentionHeatmap(0);
        }

        function renderLogitLens(data, tokenIdx, allTokens, nPromptTokens) {
            const container = document.getElementById('logit-lens-container');

            // Check if logit lens data is available
            if (!data.logit_lens || !data.logit_lens.response) {
                container.style.display = 'none';
                return;
            }

            container.style.display = 'block';

            // Determine if this is a prompt or response token
            const isPromptToken = tokenIdx < nPromptTokens;
            const logitData = isPromptToken ? data.logit_lens.prompt : data.logit_lens.response;
            const actualIdx = isPromptToken ? tokenIdx : (tokenIdx - nPromptTokens);

            // Update token info
            const tokenText = allTokens[tokenIdx];
            document.getElementById('logit-token-num').textContent = tokenIdx + 1;
            document.getElementById('logit-token-text').textContent = tokenText;

            // Layer indices from LOGIT_LENS_LAYERS config: [0,1,2,3,6,9,12,15,18,21,24,25]
            const layerKeys = Object.keys(logitData).sort((a, b) => {
                const aNum = parseInt(a.replace('layer_', ''));
                const bNum = parseInt(b.replace('layer_', ''));
                return aNum - bNum;
            });

            const layerIndices = layerKeys.map(k => parseInt(k.replace('layer_', '')));

            // Build traces for top-3 predictions
            const traces = [];
            const colors = ['#4a9eff', '#ff6b6b', '#51cf66'];  // Blue, Red, Green

            for (let k = 0; k < 3; k++) {
                const probs = [];
                const tokens = [];

                for (const layerKey of layerKeys) {
                    const layerData = logitData[layerKey];

                    if (layerData && layerData.tokens[actualIdx]) {
                        probs.push(layerData.probs[actualIdx][k]);
                        if (tokens.length === 0) {
                            tokens.push(layerData.tokens[actualIdx][k]);
                        }
                    } else {
                        // Data not available for this layer/token
                        probs.push(null);
                    }
                }

                traces.push({
                    x: layerIndices,
                    y: probs,
                    name: `"${tokens[0] || '?'}"`,
                    mode: 'lines+markers',
                    line: { width: 3, color: colors[k] },
                    marker: { size: 8, color: colors[k] },
                    connectgaps: false
                });
            }

            // Layout
            const layout = {
                xaxis: {
                    title: 'Layer',
                    tickvals: layerIndices,
                    gridcolor: 'rgba(128, 128, 128, 0.2)',
                    zeroline: false
                },
                yaxis: {
                    title: 'Prob',
                    range: [0, 1],
                    gridcolor: 'rgba(128, 128, 128, 0.2)',
                    zeroline: false
                },
                height: 250,
                margin: { t: 20, b: 50, l: 50, r: 20 },
                paper_bgcolor: 'transparent',
                plot_bgcolor: 'transparent',
                font: {
                    color: getComputedStyle(document.documentElement).getPropertyValue('--text-primary').trim(),
                    size: 11
                },
                showlegend: true,
                legend: {
                    orientation: 'h',
                    yanchor: 'bottom',
                    y: -0.35,
                    xanchor: 'center',
                    x: 0.5,
                    font: { size: 10 }
                }
            };

            Plotly.newPlot('logit-lens-plot', traces, layout, { responsive: true, displayModeBar: false });
        }

        function setupUnifiedSlider(data, allTokens, nPromptTokens, nTotalTokens) {
            const slider = document.getElementById('unified-slider');

            // Function to update all visualizations when slider moves
            function updateAllVisualizations(tokenIdx) {
                // Update slider labels
                document.getElementById('unified-slider-value').textContent = tokenIdx;
                document.getElementById('unified-slider-token').textContent = allTokens[tokenIdx];

                // Update phase indicator (Prompt vs Response)
                const phase = tokenIdx < nPromptTokens ? '[Prompt]' : '[Response]';
                document.getElementById('unified-slider-phase').textContent = phase;

                // Heatmap position (adjusted for skipped BOS token)
                const startIdx = 1;  // BOS is skipped in heatmap
                const heatmapIdx = tokenIdx - startIdx;

                // Update trajectory heatmap highlight
                const shapes = [
                    // Separator line (adjusted for skipped BOS)
                    {
                        type: 'line',
                        xref: 'x',
                        yref: 'paper',
                        x0: (nPromptTokens - startIdx) - 0.5,
                        x1: (nPromptTokens - startIdx) - 0.5,
                        y0: 0,
                        y1: 1,
                        line: {
                            color: 'rgba(255, 255, 255, 0.5)',
                            width: 2,
                            dash: 'dash'
                        }
                    },
                    // Current token highlight (adjusted position for skipped BOS)
                    {
                        type: 'rect',
                        xref: 'x',
                        yref: 'paper',
                        x0: heatmapIdx - 0.5,
                        x1: heatmapIdx + 0.5,
                        y0: 0,
                        y1: 1,
                        fillcolor: 'rgba(74, 158, 255, 0.2)',
                        line: { width: 0 }
                    }
                ];

                Plotly.relayout('trajectory-heatmap', { shapes: shapes });

                // Update logit lens if available
                renderLogitLens(data, tokenIdx, allTokens, nPromptTokens);

                // Update attention heatmap if available
                if (window.updateAttentionHeatmap) {
                    window.updateAttentionHeatmap(tokenIdx);
                }
            }

            // Add slider event listener
            slider.addEventListener('input', (e) => {
                updateAllVisualizations(parseInt(e.target.value));
            });

            // Initialize at position 1 (skip BOS)
            updateAllVisualizations(1);
        }

        // Render Layer Deep Dive view
        async function renderLayerDeepDive() {
            const contentArea = document.getElementById('content-area');
            const filteredTraits = getFilteredTraits();

            if (filteredTraits.length === 0) {
                contentArea.innerHTML = `
                    <div class="card">
                        <div class="card-title">Layer Deep Dive</div>
                        <div class="info">Select at least one trait to view layer internals</div>
                    </div>
                `;
                return;
            }

            // Try to find Tier 3 data for the first selected trait
            const trait = filteredTraits[0];
            const tier3Dir = `../experiments/${experimentData.name}/${trait.name}/inference/layer_internal_states/`;

            // Try to load prompt_0_layer16.json (default layer)
            try {
                const response = await fetch(`${tier3Dir}prompt_0_layer16.json`);
                if (!response.ok) throw new Error('No data found');

                const data = await response.json();
                renderTier3Data(trait, data);
            } catch (error) {
                // No data yet - show instructions
                renderTier3Instructions(trait);
            }
        }

        function renderTier3Instructions(trait) {
            const contentArea = document.getElementById('content-area');
            contentArea.innerHTML = `
                <div class="explanation">
                    <div class="explanation-summary">Identify which neurons and attention heads drive the trait in a specific layer</div>
                    <div class="explanation-details">
                    <p>Deep dive into a single layer's internals to identify which components drive trait expression.</p>

                    <h4>Captured Components</h4>

                    <p><strong>Attention Projections (before multihead split):</strong></p>
                    <p>$$\\mathbf{Q} = \\mathbf{h}\\mathbf{W}_Q, \\quad \\mathbf{K} = \\mathbf{h}\\mathbf{W}_K, \\quad \\mathbf{V} = \\mathbf{h}\\mathbf{W}_V$$</p>
                    <p>Query, Key, Value projections \\(\\in \\mathbb{R}^{T \\times d}\\)</p>

                    <p><strong>Attention Heads (post-split):</strong></p>
                    <p>$$\\text{head}_i = \\text{Attention}(\\mathbf{Q}_i, \\mathbf{K}_i, \\mathbf{V}_i) = \\text{softmax}\\left(\\frac{\\mathbf{Q}_i \\mathbf{K}_i^T}{\\sqrt{d_k}}\\right)\\mathbf{V}_i$$</p>
                    <p>Per-head outputs showing which heads activate for the trait</p>

                    <p><strong>MLP Internals:</strong></p>
                    <p>$$\\mathbf{h}_{\\text{mlp}} = \\mathbf{W}_2 \\cdot \\text{GELU}(\\mathbf{W}_1 \\mathbf{h})$$</p>
                    <ul>
                        <li>Pre-GELU: \\(\\mathbf{W}_1 \\mathbf{h} \\in \\mathbb{R}^{9216}\\) (2304 hidden √ó 4 expansion)</li>
                        <li>Post-GELU: Shows which of 9216 neurons fire for trait</li>
                    </ul>

                    <h4>Use Case</h4>
                    <p>Identifies specific neurons/heads responsible for trait computation, enabling:</p>
                    <ul>
                        <li>Neuron-level interpretation</li>
                        <li>Surgical intervention (ablation studies)</li>
                        <li>Feature visualization</li>
                    </ul>
                </div>
                <div class="card">
                    <div class="card-title">Layer Deep Dive: ${getDisplayName(trait.name)}</div>

                    <div class="info" style="margin-bottom: 20px;">
                        <strong>‚ö†Ô∏è No layer internals data available for ${trait.name}</strong>
                    </div>

                    <div style="background: var(--bg-tertiary); padding: 20px; border-radius: 8px;">
                        <h3 style="color: var(--text-primary); margin-bottom: 15px;">Capture Layer Internals</h3>
                        <p style="color: var(--text-secondary); margin-bottom: 15px;">
                            Capture complete internals (Q/K/V, attention heads, 9216 MLP neurons) for one layer:
                        </p>
                        <pre style="background: var(--bg-primary); color: var(--text-primary); padding: 15px; border-radius: 4px; margin: 15px 0; overflow-x: auto; border: 1px solid var(--border-color);">python inference/capture_tier3.py \\
  --experiment ${experimentData.name} \\
  --trait ${trait.name} \\
  --layer 16 \\
  --prompts "What is the capital of France?" \\
  --save-json</pre>
                        <p style="color: var(--text-secondary); margin-top: 15px;">
                            The <code style="background: var(--bg-primary); padding: 2px 6px; border-radius: 3px;">--save-json</code> flag creates visualization-friendly JSON files (~10-20 MB).
                        </p>
                        <p style="color: var(--text-tertiary); font-size: 13px; margin-top: 10px;">
                            This reveals which specific neurons and attention heads are responsible for ${getDisplayName(trait.name)}.
                        </p>
                    </div>
                </div>
            `;
        }

        function renderTier3Data(trait, data) {
            const contentArea = document.getElementById('content-area');

            // Get prompt GELU activations: [n_tokens, 9216]
            const promptGelu = data.internals.prompt.gelu;
            const promptTokens = data.prompt.tokens;

            contentArea.innerHTML = `
                <div class="explanation">
                    <div class="explanation-summary">Layer ${data.layer} neuron analysis - top 20 trait-driving neurons</div>
                    <div class="explanation-details">
                    <h4>Layer ${data.layer} Internals</h4>
                    <p>Analysis of complete layer internals to identify trait-driving neurons.</p>

                    <h4>Components Analyzed</h4>

                    <p><strong>Attention Projections:</strong></p>
                    <p>$$\\mathbf{Q}, \\mathbf{K}, \\mathbf{V} = \\mathbf{h} \\mathbf{W}_Q, \\mathbf{h} \\mathbf{W}_K, \\mathbf{h} \\mathbf{W}_V \\in \\mathbb{R}^{T \\times d}$$</p>

                    <p><strong>Attention Heads:</strong></p>
                    <p>$$\\text{head}_i = \\text{softmax}\\left(\\frac{\\mathbf{Q}_i \\mathbf{K}_i^T}{\\sqrt{d_k}}\\right)\\mathbf{V}_i$$</p>

                    <p><strong>MLP Neurons (9216 total):</strong></p>
                    <p>$$\\mathbf{z} = \\text{GELU}(\\mathbf{W}_1 \\mathbf{h}) \\in \\mathbb{R}^{9216}$$</p>
                    <p>Top 20 neurons ranked by \\(\\frac{1}{T}\\sum_t |z_t^{(i)}|\\) (average absolute activation)</p>

                    <h4>Interpretation</h4>
                    <p>Neurons with high activation magnitude are most responsible for this layer's contribution to the trait.</p>
                    </div>
                <div class="card">
                    <div class="card-title">Layer Deep Dive: ${getDisplayName(trait.name)} (Layer ${data.layer})</div>

                    <div style="background: var(--bg-tertiary); padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                        <div style="margin-bottom: 10px;">
                            <div style="color: var(--text-secondary); font-size: 13px; margin-bottom: 5px;">Full Conversation</div>
                            <div style="color: var(--text-primary); font-size: 16px; font-weight: 600;">${data.prompt.text} ${data.response.text}</div>
                        </div>
                        <div>
                            <div style="color: var(--text-secondary); font-size: 13px;">Layer</div>
                            <div style="color: var(--text-primary); font-size: 16px; font-weight: 600;">Layer ${data.layer} of 27</div>
                        </div>
                    </div>

                    <div id="sublayer-trajectory" style="margin-bottom: 30px;"></div>
                    <div id="contribution-breakdown" style="margin-bottom: 30px;"></div>
                    <div id="head-contributions" style="margin-bottom: 30px;"></div>
                    <div id="attention-heatmaps" style="margin-bottom: 30px;"></div>
                    <div id="top-neurons-combined"></div>
                </div>
            `;

            // Combine prompt and response tokens and activations
            const responseGelu = data.internals.response.gelu;
            const responseTokens = data.response.tokens;

            const allTokens = [...promptTokens, ...responseTokens];
            const allGelu = [...promptGelu, ...responseGelu];

            // Render new visualizations if trait projections available
            if (data.trait_projections) {
                renderSublayerTrajectory(data, promptTokens.length);
                renderContributionBreakdown(data, promptTokens.length);
                renderHeadContributions(data, promptTokens.length);
            }

            // Store data for slider updates
            window.currentLayerData = { data, promptLength: promptTokens.length };

            // Render attention heatmaps
            if (data.internals.prompt.attn_weights) {
                renderAttentionHeatmaps(data, promptTokens.length, 0);  // Start with token 0
            }

            // Render combined neuron activations
            renderTopNeurons('top-neurons-combined', 'Top Neurons (Full Conversation)', allGelu, allTokens, promptTokens.length);
        }

        // ============================================================================
        // Phase 1 Visualizations
        // ============================================================================

        function renderSublayerTrajectory(data, promptLength) {
            // Combine prompt and response projections
            const promptProj = data.trait_projections.prompt;
            const responseProj = data.trait_projections.response;

            const allTokens = [...data.prompt.tokens, ...data.response.tokens];
            const residualIn = [...promptProj.residual_in, ...responseProj.residual_in];
            const residualAfterAttn = [...promptProj.residual_after_attn, ...responseProj.residual_after_attn];
            const residualOut = [...promptProj.residual_out, ...responseProj.residual_out];

            const trace1 = {
                x: Array.from({length: allTokens.length}, (_, i) => i),
                y: residualIn,
                mode: 'lines+markers',
                name: 'Residual In',
                line: { color: '#888', width: 2 },
                marker: { size: 6 },
                hovertemplate: 'Token %{x}: %{text}<br>Trait Score: %{y:.3f}<extra></extra>',
                text: allTokens
            };

            const trace2 = {
                x: Array.from({length: allTokens.length}, (_, i) => i),
                y: residualAfterAttn,
                mode: 'lines+markers',
                name: 'After Attention',
                line: { color: '#4a9eff', width: 2 },
                marker: { size: 6 },
                hovertemplate: 'Token %{x}: %{text}<br>Trait Score: %{y:.3f}<extra></extra>',
                text: allTokens
            };

            const trace3 = {
                x: Array.from({length: allTokens.length}, (_, i) => i),
                y: residualOut,
                mode: 'lines+markers',
                name: 'After MLP (Output)',
                line: { color: '#4caf50', width: 2 },
                marker: { size: 6 },
                hovertemplate: 'Token %{x}: %{text}<br>Trait Score: %{y:.3f}<extra></extra>',
                text: allTokens
            };

            // Add separator line
            const shapes = [];
            if (promptLength) {
                shapes.push({
                    type: 'line',
                    xref: 'x',
                    yref: 'paper',
                    x0: promptLength - 0.5,
                    x1: promptLength - 0.5,
                    y0: 0,
                    y1: 1,
                    line: {
                        color: 'rgba(255, 255, 255, 0.3)',
                        width: 2,
                        dash: 'dash'
                    }
                });
            }

            const layout = getPlotlyLayout({
                title: '3-Checkpoint Trait Trajectory (Sublayer Evolution)',
                xaxis: { title: 'Token Position' },
                yaxis: { title: 'Trait Score' },
                height: 350,
                shapes: shapes
            });

            Plotly.newPlot('sublayer-trajectory', [trace1, trace2, trace3], layout, { displayModeBar: false });
        }

        function renderContributionBreakdown(data, promptLength) {
            // Combine prompt and response contributions
            const promptProj = data.trait_projections.prompt;
            const responseProj = data.trait_projections.response;

            const allTokens = [...data.prompt.tokens, ...data.response.tokens];
            const attnContrib = [...promptProj.attn_contribution, ...responseProj.attn_contribution];
            const mlpContrib = [...promptProj.mlp_contribution, ...responseProj.mlp_contribution];

            const trace1 = {
                x: Array.from({length: allTokens.length}, (_, i) => i),
                y: attnContrib,
                type: 'bar',
                name: 'Attention Contribution',
                marker: { color: '#4a9eff' },
                hovertemplate: 'Token %{x}: %{text}<br>Attention: %{y:.3f}<extra></extra>',
                text: allTokens
            };

            const trace2 = {
                x: Array.from({length: allTokens.length}, (_, i) => i),
                y: mlpContrib,
                type: 'bar',
                name: 'MLP Contribution',
                marker: { color: '#4caf50' },
                hovertemplate: 'Token %{x}: %{text}<br>MLP: %{y:.3f}<extra></extra>',
                text: allTokens
            };

            // Add separator line
            const shapes = [];
            if (promptLength) {
                shapes.push({
                    type: 'line',
                    xref: 'x',
                    yref: 'paper',
                    x0: promptLength - 0.5,
                    x1: promptLength - 0.5,
                    y0: 0,
                    y1: 1,
                    line: {
                        color: 'rgba(255, 255, 255, 0.3)',
                        width: 2,
                        dash: 'dash'
                    }
                });
            }

            const layout = getPlotlyLayout({
                title: 'Attention vs MLP Contribution (Per Token)',
                xaxis: { title: 'Token Position' },
                yaxis: { title: 'Trait Contribution' },
                barmode: 'group',
                height: 400,
                shapes: shapes
            });

            Plotly.newPlot('contribution-breakdown', [trace1, trace2], layout, { displayModeBar: false });
        }

        function renderHeadContributions(data, promptLength) {
            // Check if per-head contributions are available
            const promptProj = data.trait_projections.prompt;
            const responseProj = data.trait_projections.response;

            if (!promptProj.head_contributions && !responseProj.head_contributions) {
                document.getElementById('head-contributions').style.display = 'none';
                return;
            }

            document.getElementById('head-contributions').style.display = 'block';

            // Combine prompt and response head contributions
            // head_contributions is [n_heads, n_tokens]
            const headContribsPrompt = promptProj.head_contributions || [];
            const headContribsResponse = responseProj.head_contributions || [];

            const allTokens = [...data.prompt.tokens, ...data.response.tokens];
            const nHeads = headContribsPrompt.length || headContribsResponse.length;

            // Create traces for each head
            const traces = [];
            const colors = ['#4a9eff', '#ff6b6b', '#51cf66', '#ffc107', '#9c27b0', '#ff9800', '#00bcd4', '#e91e63'];

            for (let headIdx = 0; headIdx < nHeads; headIdx++) {
                // Combine prompt and response contributions for this head
                const promptContrib = headContribsPrompt[headIdx] || [];
                const responseContrib = headContribsResponse[headIdx] || [];
                const allContrib = [...promptContrib, ...responseContrib];

                traces.push({
                    x: Array.from({length: allContrib.length}, (_, i) => i),
                    y: allContrib,
                    mode: 'lines+markers',
                    name: `Head ${headIdx}`,
                    line: { color: colors[headIdx % colors.length], width: 2 },
                    marker: { size: 4 },
                    hovertemplate: 'Token %{x}: %{text}<br>Head ' + headIdx + ': %{y:.3f}<extra></extra>',
                    text: allTokens
                });
            }

            // Add separator line
            const shapes = [];
            if (promptLength) {
                shapes.push({
                    type: 'line',
                    xref: 'x',
                    yref: 'paper',
                    x0: promptLength - 0.5,
                    x1: promptLength - 0.5,
                    y0: 0,
                    y1: 1,
                    line: {
                        color: 'rgba(255, 255, 255, 0.3)',
                        width: 2,
                        dash: 'dash'
                    }
                });
            }

            const layout = getPlotlyLayout({
                title: 'Per-Head Trait Contributions (Which Heads Drive the Trait)',
                xaxis: { title: 'Token Position' },
                yaxis: { title: 'Head Contribution to Trait' },
                height: 400,
                shapes: shapes,
                showlegend: true,
                legend: {
                    orientation: 'h',
                    yanchor: 'bottom',
                    y: -0.3,
                    xanchor: 'center',
                    x: 0.5
                }
            });

            Plotly.newPlot('head-contributions', traces, layout, { displayModeBar: false });
        }

        function renderAttentionHeatmaps(data, promptLength, tokenIdx = 0) {
            // Show attention patterns for a single query token
            // Display how this token attends to all context tokens across 8 heads

            const allTokens = [...data.prompt.tokens, ...data.response.tokens];
            const isPromptToken = tokenIdx < promptLength;

            let attnWeights;  // [8_heads, seq_len] - just the row for this query token
            let contextTokens;

            if (isPromptToken) {
                // Query is in prompt - extract row from prompt attention
                const promptAttn = data.internals.prompt.attn_weights;  // [8_heads, prompt_len, prompt_len]
                attnWeights = promptAttn.map(head => head[tokenIdx]);  // [8_heads, prompt_len]
                contextTokens = data.prompt.tokens;
            } else {
                // Query is in response - extract row from response attention
                const responseIdx = tokenIdx - promptLength;
                const responseAttn = data.internals.response.attn_weights[responseIdx];  // [8_heads, context_len, context_len]
                const contextLen = promptLength + responseIdx + 1;
                attnWeights = responseAttn.map(head => head[head.length - 1]);  // Last row = this token's attention
                contextTokens = allTokens.slice(0, contextLen);  // All context up to this point
            }

            const html = `
                <div style="margin-bottom: 20px; padding: 15px; background: var(--bg-secondary); border-radius: 8px;">
                    <h3 style="margin: 0 0 15px 0; color: var(--text-primary);">Query Token Attention</h3>

                    <!-- Slider -->
                    <div style="margin-bottom: 10px;">
                        <label style="color: var(--text-secondary); font-size: 13px;">
                            Select Query Token: <span id="attn-slider-value" style="color: var(--text-primary); font-weight: 600;">0</span> -
                            "<span id="attn-slider-token" style="color: var(--text-primary); font-weight: 600;">${allTokens[0]}</span>"
                        </label>
                    </div>
                    <input type="range" id="attn-slider" min="0" max="${allTokens.length - 1}" value="${tokenIdx}"
                           style="width: 100%; height: 3px; border-radius: 2px; background: var(--border-color);">

                    <div style="margin-top: 15px; color: var(--text-secondary); font-size: 13px;">
                        Showing how token <span style="color: var(--text-primary); font-weight: 600;">"${allTokens[tokenIdx]}"</span>
                        (position ${tokenIdx}) attends to ${contextTokens.length} context tokens
                    </div>
                </div>

                <!-- 8 Head Patterns Stacked Vertically -->
                <div style="display: grid; grid-template-columns: 1fr; gap: 15px;">
                    ${Array.from({length: 8}, (_, i) => `<div id="attn-head-${i}"></div>`).join('')}
                </div>
            `;

            document.getElementById('attention-heatmaps').innerHTML = html;

            // Render each head as a 1-row heatmap
            for (let head = 0; head < 8; head++) {
                const headAttn = attnWeights[head];  // [context_len]

                // Create 1-row heatmap with query position highlighted
                const trace = {
                    z: [headAttn],  // Single row
                    x: contextTokens,
                    y: ['Attention'],
                    type: 'heatmap',
                    colorscale: 'Viridis',
                    hovertemplate: 'To: %{x}<br>Weight: %{z:.3f}<extra></extra>',
                    showscale: head === 7  // Only show scale on last plot
                };

                // Highlight the query position
                const shapes = [];
                const queryPosInContext = isPromptToken ? tokenIdx : headAttn.length - 1;
                shapes.push({
                    type: 'rect',
                    xref: 'x',
                    yref: 'paper',
                    x0: queryPosInContext - 0.5,
                    x1: queryPosInContext + 0.5,
                    y0: 0,
                    y1: 1,
                    line: { color: '#ff6b6b', width: 3 },
                    fillcolor: 'rgba(255, 107, 107, 0.1)'
                });

                const layout = getPlotlyLayout({
                    title: `Head ${head}`,
                    xaxis: { title: 'Context Token', tickangle: -45, tickfont: { size: 9 } },
                    yaxis: { title: '', showticklabels: false },
                    height: 100,
                    margin: { l: 30, r: 10, t: 40, b: 80 },
                    shapes: shapes
                });

                Plotly.newPlot(`attn-head-${head}`, [trace], layout, { displayModeBar: false });
            }

            // Add slider event listener
            document.getElementById('attn-slider').addEventListener('input', (e) => {
                const newTokenIdx = parseInt(e.target.value);
                document.getElementById('attn-slider-value').textContent = newTokenIdx;
                document.getElementById('attn-slider-token').textContent = allTokens[newTokenIdx];
                renderAttentionHeatmaps(data, promptLength, newTokenIdx);
            });
        }

        // ============================================================================
        // Neuron Visualization
        // ============================================================================

        function renderTopNeurons(divId, title, geluActivations, tokens, promptLength = null) {
            // Store for access by slider callback
            window.currentLayerData = { data: window.currentLayerData?.data, promptLength };
            // geluActivations: [n_tokens, 9216]
            // Show per-token heatmap with slider
            // promptLength: if provided, adds visual separator between prompt and response

            if (!geluActivations || geluActivations.length === 0) {
                document.getElementById(divId).innerHTML = '<div style="color: var(--text-secondary);">No data</div>';
                return;
            }

            const nTokens = geluActivations.length;
            const nNeurons = geluActivations[0].length;

            // Find top 50 neurons by average activation magnitude
            const neuronAvg = new Array(nNeurons).fill(0);
            for (let t = 0; t < nTokens; t++) {
                for (let n = 0; n < nNeurons; n++) {
                    neuronAvg[n] += Math.abs(geluActivations[t][n]);
                }
            }
            for (let n = 0; n < nNeurons; n++) {
                neuronAvg[n] /= nTokens;
            }

            const neuronIndices = Array.from({length: nNeurons}, (_, i) => i);
            neuronIndices.sort((a, b) => neuronAvg[b] - neuronAvg[a]);
            const topNeurons = neuronIndices.slice(0, 50);

            // Create heatmap data: [50_neurons, n_tokens]
            const heatmapData = topNeurons.map(neuronIdx => {
                return geluActivations.map(tokenActivations => tokenActivations[neuronIdx]);
            });

            // Create unique div IDs
            const heatmapId = `${divId}-heatmap`;
            const sliderId = `${divId}-slider`;
            const sliderValueId = `${divId}-slider-value`;
            const barChartId = `${divId}-bar`;

            const html = `
                <div style="margin-bottom: 30px;">
                    <h3 style="margin-bottom: 15px; color: var(--text-primary);">${title}</h3>

                    <div style="margin-bottom: 20px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <label style="color: var(--text-secondary); font-weight: 600;">
                                Token Position: <span id="${sliderValueId}" style="color: var(--primary-color);">0</span> / ${nTokens - 1}
                            </label>
                            <span style="color: var(--text-secondary); font-size: 12px;">
                                Token: "<span id="${sliderValueId}-token" style="font-weight: 600;">${tokens[0]}</span>"
                            </span>
                        </div>
                        <input type="range" id="${sliderId}" min="0" max="${nTokens - 1}" value="0"
                               style="width: 100%; height: 3px; border-radius: 2px; background: var(--border-color);">
                    </div>

                    <div id="${heatmapId}" style="margin-bottom: 30px;"></div>
                    <div id="${barChartId}"></div>
                </div>
            `;

            document.getElementById(divId).innerHTML = html;

            // Render heatmap (overview of all tokens √ó top neurons)
            const heatmapTrace = {
                z: heatmapData,
                x: tokens,
                y: topNeurons.map(n => `N${n}`),
                type: 'heatmap',
                colorscale: 'RdBu',
                zmid: 0,
                hovertemplate: 'Token: %{x}<br>Neuron: %{y}<br>Activation: %{z:.3f}<extra></extra>',
                colorbar: {
                    title: 'Activation'
                }
            };

            // Build shapes array for heatmap
            const shapes = [{
                type: 'rect',
                xref: 'x',
                yref: 'paper',
                x0: -0.5,
                x1: 0.5,
                y0: 0,
                y1: 1,
                fillcolor: 'rgba(74, 158, 255, 0.15)',
                line: { width: 0 }
            }];

            // Add separator line between prompt and response if provided
            if (promptLength !== null) {
                shapes.push({
                    type: 'line',
                    xref: 'x',
                    yref: 'paper',
                    x0: promptLength - 0.5,
                    x1: promptLength - 0.5,
                    y0: 0,
                    y1: 1,
                    line: {
                        color: 'rgba(255, 255, 255, 0.5)',
                        width: 2,
                        dash: 'dash'
                    }
                });
            }

            // Add annotations for prompt/response regions if applicable
            const annotations = [];
            if (promptLength !== null) {
                annotations.push({
                    x: (promptLength - 1) / 2,
                    y: 1.05,
                    xref: 'x',
                    yref: 'paper',
                    text: 'Prompt',
                    showarrow: false,
                    font: { size: 12, color: 'var(--text-secondary)' },
                    xanchor: 'center'
                });
                annotations.push({
                    x: promptLength + (nTokens - promptLength - 1) / 2,
                    y: 1.05,
                    xref: 'x',
                    yref: 'paper',
                    text: 'Response',
                    showarrow: false,
                    font: { size: 12, color: 'var(--text-secondary)' },
                    xanchor: 'center'
                });
            }

            const heatmapLayout = getPlotlyLayout({
                title: 'Neuron Activations Across All Tokens (Top 50 Neurons)',
                xaxis: { title: 'Token', tickangle: -45 },
                yaxis: { title: 'Neuron', autorange: 'reversed' },
                height: 400,
                shapes: shapes,
                annotations: annotations
            });

            Plotly.newPlot(heatmapId, [heatmapTrace], heatmapLayout, { displayModeBar: false });

            // Function to update bar chart for selected token
            function updateBarChart(tokenIdx) {
                const tokenActivations = geluActivations[tokenIdx];
                const topActivations = topNeurons.map(n => tokenActivations[n]);

                const barTrace = {
                    x: topNeurons.map(n => `N${n}`),
                    y: topActivations,
                    type: 'bar',
                    marker: {
                        color: topActivations.map(a => a > 0 ? '#4caf50' : '#f44336')
                    },
                    hovertemplate: 'Neuron: %{x}<br>Activation: %{y:.3f}<extra></extra>'
                };

                Plotly.newPlot(barChartId, [barTrace], getPlotlyLayout({
                    title: `Neuron Activations for Token "${tokens[tokenIdx]}" (Position ${tokenIdx})`,
                    xaxis: { title: 'Neuron Index', tickangle: -45 },
                    yaxis: { title: 'Activation' },
                    height: 350
                }), { displayModeBar: false });

                // Update heatmap highlight
                const newShapes = [{
                    type: 'rect',
                    xref: 'x',
                    yref: 'paper',
                    x0: tokenIdx - 0.5,
                    x1: tokenIdx + 0.5,
                    y0: 0,
                    y1: 1,
                    fillcolor: 'rgba(74, 158, 255, 0.15)',
                    line: { width: 0 }
                }];

                // Add separator line if provided
                if (promptLength !== null) {
                    newShapes.push({
                        type: 'line',
                        xref: 'x',
                        yref: 'paper',
                        x0: promptLength - 0.5,
                        x1: promptLength - 0.5,
                        y0: 0,
                        y1: 1,
                        line: {
                            color: 'rgba(255, 255, 255, 0.5)',
                            width: 2,
                            dash: 'dash'
                        }
                    });
                }

                // Preserve annotations when updating
                const layoutUpdate = { shapes: newShapes };
                if (annotations.length > 0) {
                    layoutUpdate.annotations = annotations;
                }
                Plotly.relayout(heatmapId, layoutUpdate);

                // Update slider label
                document.getElementById(sliderValueId).textContent = tokenIdx;
                document.getElementById(`${sliderValueId}-token`).textContent = tokens[tokenIdx];
            }

            // Initialize with first token
            updateBarChart(0);

            // Add slider event listener
            document.getElementById(sliderId).addEventListener('input', (e) => {
                updateBarChart(parseInt(e.target.value));
            });
        }

        // Setup event listeners
        function setupEventListeners() {
            // Experiment selection is now handled in loadExperiments()

            // Theme toggle
            document.getElementById('theme-toggle').addEventListener('click', toggleTheme);

            // Info tooltip
            document.getElementById('info-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                toggleInfo();
            });

            // Select all traits button
            document.getElementById('select-all-btn').addEventListener('click', toggleAllTraits);
        }

        // Utility functions
        function showError(message) {
            document.getElementById('content-area').innerHTML = `
                <div class="error">
                    <strong>Error:</strong> ${message}
                    <br><br>
                    Make sure you're running a local server from the trait-interp root directory:
                    <pre style="background: #2d2d2d; color: #f8f8f2; padding: 10px; border-radius: 4px; margin-top: 10px;">cd trait-interp
python -m http.server 8000</pre>
                    Then visit: <a href="http://localhost:8000/visualization/">http://localhost:8000/visualization/</a>
                </div>
            `;
        }

        // Initialize on page load
        init();
    </script>
</body>
</html>
