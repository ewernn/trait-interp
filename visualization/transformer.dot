digraph transformer {
    rankdir=BT;
    splines=ortho;
    nodesep=0.8;
    ranksep=0.6;
    
    // Global node styles
    node [shape=box, style="rounded,filled", fillcolor="white", fontname="Helvetica", fontsize=10, penwidth=1.5];
    edge [fontname="Helvetica", fontsize=8, penwidth=1.2];

    // --- Main Residual Backbone (Group: main) ---
    // We define these first to establish the vertical column
    node [group=main];
    Input [label="Input Token\n'Spread'", shape=note, fillcolor="#fff3e0"];
    AddNorm1 [label="Add & Norm", fillcolor="#e3f2fd"];
    AddNorm2 [label="Add & Norm", fillcolor="#e3f2fd"];
    Output [label="Output Token\n'!'", shape=note, fillcolor="#fff3e0"];

    // Connect the backbone with high weight to keep it straight
    Input -> AddNorm1 [label="Residual Stream", color="#ff9800", penwidth=3, weight=100];
    AddNorm1 -> AddNorm2 [label="Residual Stream", color="#ff9800", penwidth=3, weight=100];
    AddNorm2 -> Output [color="#ff9800", penwidth=3, weight=100];

    // --- Side Branches (Group: side) ---
    // We want these to be to the RIGHT of the main group.
    // We can achieve this by defining rank=same with the backbone nodes and enforcing order.
    
    node [group=side];
    
    // Attention Block Components
    LN1 [label="Layer Norm"];
    Attn [label="Multi-Head Attention\n(GQA)", fillcolor="#e8f5e9"];
    
    // MLP Block Components
    LN2 [label="Layer Norm"];
    MLP [label="Feed Forward\n(MLP)", fillcolor="#f3e5f5"];

    // --- Connections for Side Branches ---
    
    // Branch 1: Attention
    // Input -> LN1 -> Attn -> AddNorm1
    // We use lower weight so they don't disturb the backbone
    Input -> LN1 [weight=1];
    LN1 -> Attn;
    Attn -> AddNorm1;

    // Branch 2: MLP
    // AddNorm1 -> LN2 -> MLP -> AddNorm2
    AddNorm1 -> LN2 [weight=1];
    LN2 -> MLP;
    MLP -> AddNorm2;

    // --- Layout Constraints ---
    // Force side components to be on the same rank as their "start" or "end" points roughly,
    // or just let Graphviz handle the y-position but force x-position to the right.
    // The 'group' attribute helps, but to ensure 'side' is to the right of 'main',
    // we can add invisible edges or use 'rank=same'.
    
    // Force LN1 to be to the right of Input (or slightly above)
    // Actually, standard flow is: Input splits to (Residual) and (LN1).
    // If we want LN1 to the right, we can try an invisible edge with constraint.
    
    // Let's try using 'rank=same' to force horizontal alignment of the split points if possible,
    // but since it's a flow, they are at different Y levels.
    
    // Trick: Use invisible nodes to force spacing if needed, but first let's try
    // just defining the edges in an order that might encourage right-branching.
    // Graphviz usually places the first edge to the left? Or right?
    // Let's try adding invisible edges to steer it.
    
    // Force LN1 and Attn to be on the right side
    // We can do this by adding an invisible edge from Input -> LN1 that has a label or something?
    // No.
    
    // Let's try to use a subgraph for the whole row?
    // No, the vertical flow is complex.
    
    // Let's just rely on the fact that we defined the backbone FIRST and with high weight.
    // Usually side branches will alternate. To force them to the same side,
    // we can add invisible edges between the side components?
    // e.g. Attn -> MLP [style=invis, weight=0] ? No.
    
    // Let's try to use dummy nodes to force width? No.
    
    // Let's try simply adding:
    // { rank=same; Input; LN1 } -> This would flatten the start.
    // But Input -> LN1 is a flow.
    
    // Let's try to just let it be, but maybe the issue was the previous 'subgraph cluster'
    // forcing them apart. I removed the clusters in this version to see if it flows better.
    // I will also add a 'rank=same' check for the "center" of the blocks?
    
    // Actually, let's try to force the "right" side by adding invisible nodes to the LEFT of the backbone?
    // No, that's hacky.
    
    // Let's try:
    // Input -> LN1 [headport=s, tailport=e];
    // This hints that LN1 is to the East (right).
    
    Input -> LN1 [tailport=e, headport=s, weight=1];
    AddNorm1 -> LN2 [tailport=e, headport=s, weight=1];
}
