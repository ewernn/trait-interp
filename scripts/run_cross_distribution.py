#!/usr/bin/env python3
"""
Generic Cross-Distribution Analysis Script

Runs 4×4 cross-distribution sweep for any trait with both instruction and natural data.
Tests all 4 extraction methods (mean_diff, probe, ICA, gradient) across all 26 layers.

Usage:
    python scripts/run_cross_distribution.py --trait uncertainty_calibration
    python scripts/run_cross_distribution.py --trait refusal
"""
import sys
import torch
import json
import argparse
from pathlib import Path
from tqdm import tqdm

# Add parent directory to path
sys.path.append(str(Path(__file__).parent.parent))


def load_instruction_activations(experiment, trait_path, layer):
    """Load instruction-based activations for a specific layer

    Args:
        experiment: Experiment name (e.g., gemma_2b_cognitive_nov20)
        trait_path: Full trait path including category (e.g., behavioral/refusal)
        layer: Layer number (0-25)
    """
    base = Path(f'experiments/{experiment}/extraction/{trait_path}/extraction/activations')

    if not base.exists():
        raise FileNotFoundError(
            f"Activations directory not found: {base}\n"
            f"Expected: experiments/{experiment}/extraction/{{category}}/{{trait}}/extraction/activations/"
        )

    # Use separate pos/neg files
    pos_file = base / f'pos_layer{layer}.pt'
    neg_file = base / f'neg_layer{layer}.pt'

    if not (pos_file.exists() and neg_file.exists()):
        raise FileNotFoundError(f"Activation files not found for {trait_path} at layer {layer}")

    pos_acts = torch.load(pos_file)
    neg_acts = torch.load(neg_file)
    return pos_acts, neg_acts


def load_natural_activations(experiment, trait_path_base, layer):
    """Load natural elicitation activations

    Args:
        experiment: Experiment name (e.g., gemma_2b_cognitive_nov20)
        trait_path_base: Base trait path (e.g., behavioral/refusal)
        layer: Layer number (0-25)
    """
    # Natural variants are named {trait}_natural, not {category}/{trait}_natural
    category, trait_name = trait_path_base.split('/')
    trait_natural_path = f"{category}/{trait_name}_natural"

    base = Path(f'experiments/{experiment}/extraction/{trait_natural_path}/extraction/activations')

    pos_file = base / f'pos_layer{layer}.pt'
    neg_file = base / f'neg_layer{layer}.pt'

    if not pos_file.exists() or not neg_file.exists():
        raise FileNotFoundError(f"Natural activations not found for {trait_natural_path}")

    pos_acts = torch.load(pos_file)
    neg_acts = torch.load(neg_file)
    return pos_acts, neg_acts


def load_vector(experiment, trait_path, method, layer, source='instruction'):
    """Load extracted vector

    Args:
        experiment: Experiment name (e.g., gemma_2b_cognitive_nov20)
        trait_path: Base trait path (e.g., behavioral/refusal)
        method: Extraction method (mean_diff, probe, ica, gradient)
        layer: Layer number (0-25)
        source: 'instruction' or 'natural'
    """
    if source == 'natural':
        category, trait_name = trait_path.split('/')
        trait_path = f"{category}/{trait_name}_natural"

    vectors_dir = Path(f'experiments/{experiment}/extraction/{trait_path}/extraction/vectors')
    vector_file = vectors_dir / f'{method}_layer{layer}.pt'

    if not vector_file.exists():
        return None

    return torch.load(vector_file)


def test_vector(vector, pos_acts, neg_acts):
    """
    Test vector on activations.
    Returns: (accuracy, separation, pos_mean, neg_mean, pos_std, neg_std)
    """
    if vector is None:
        return None

    # Convert to float32 if needed
    vector = vector.to(torch.float32)
    pos_acts = pos_acts.to(torch.float32)
    neg_acts = neg_acts.to(torch.float32)

    # Project
    pos_proj = pos_acts @ vector
    neg_proj = neg_acts @ vector

    # Check polarity (positive examples should have higher projection)
    correct_polarity = (pos_proj.mean() > neg_proj.mean())

    if correct_polarity:
        correct = (pos_proj > 0).sum() + (neg_proj < 0).sum()
        pos_mean = pos_proj.mean().item()
        neg_mean = neg_proj.mean().item()
    else:
        # Flip sign if polarity is wrong
        correct = (pos_proj < 0).sum() + (neg_proj > 0).sum()
        pos_mean = -pos_proj.mean().item()
        neg_mean = -neg_proj.mean().item()

    total = len(pos_acts) + len(neg_acts)
    accuracy = correct.item() / total
    separation = abs(pos_mean - neg_mean)

    pos_std = pos_proj.std().item()
    neg_std = neg_proj.std().item()

    return {
        'accuracy': accuracy,
        'separation': separation,
        'pos_mean': pos_mean,
        'neg_mean': neg_mean,
        'pos_std': pos_std,
        'neg_std': neg_std
    }


def run_quadrant(experiment, trait_path, quadrant_name, vector_source, test_source):
    """Run one quadrant (train source → test source)

    Args:
        experiment: Experiment name
        trait_path: Full trait path (category/trait_name)
        quadrant_name: Name of quadrant (inst_inst, inst_nat, nat_inst, nat_nat)
        vector_source: 'instruction' or 'natural'
        test_source: 'instruction' or 'natural'
    """
    methods = ['mean_diff', 'probe', 'ica', 'gradient']
    n_layers = 26

    category, trait_name = trait_path.split('/')
    vector_source_path = f"{category}/{trait_name}_natural" if vector_source == 'natural' else trait_path

    results = {
        'description': f"{vector_source.title()} → {test_source.title()}",
        'vector_source': vector_source_path,
        'test_source': test_source,
        'methods': {}
    }

    for method in methods:
        method_results = {
            'all_layers': []
        }

        for layer in tqdm(range(n_layers), desc=f"{quadrant_name} - {method}", leave=False):
            try:
                # Load vector
                vector = load_vector(experiment, trait_path, method, layer, source=vector_source)
                if vector is None:
                    continue

                # Load test activations
                if test_source == 'instruction':
                    pos_acts, neg_acts = load_instruction_activations(experiment, trait_path, layer)
                else:  # natural
                    pos_acts, neg_acts = load_natural_activations(experiment, trait_path, layer)

                # Test
                metrics = test_vector(vector, pos_acts, neg_acts)
                if metrics:
                    metrics['layer'] = layer
                    method_results['all_layers'].append(metrics)

            except Exception as e:
                print(f"Warning: Failed at {method} layer {layer}: {e}")
                continue

        # Find best layer
        if method_results['all_layers']:
            best = max(method_results['all_layers'], key=lambda x: x['accuracy'])
            method_results['best_layer'] = best['layer']
            method_results['best_accuracy'] = best['accuracy']
            method_results['best_separation'] = best['separation']
            method_results['avg_accuracy'] = sum(x['accuracy'] for x in method_results['all_layers']) / len(method_results['all_layers'])

        results['methods'][method] = method_results

    return results


def run_full_4x4(experiment, trait_path):
    """Run complete 4×4 cross-distribution analysis

    Args:
        experiment: Experiment name (e.g., gemma_2b_cognitive_nov20)
        trait_path: Full trait path including category (e.g., behavioral/refusal)
    """
    print(f"\n{'='*60}")
    print(f"Cross-Distribution Analysis: {trait_path}")
    print(f"Experiment: {experiment}")
    print(f"{'='*60}\n")

    # Verify structure
    exp_dir = Path(f'experiments/{experiment}/extraction/{trait_path}')
    if not exp_dir.exists():
        raise FileNotFoundError(
            f"Trait directory not found: {exp_dir}\n"
            f"Expected: experiments/{experiment}/extraction/{{category}}/{{trait}}/"
        )

    # Define quadrants
    quadrants = {
        'inst_inst': {
            'vector_source': 'instruction',
            'test_source': 'instruction'
        },
        'inst_nat': {
            'vector_source': 'instruction',
            'test_source': 'natural'
        },
        'nat_inst': {
            'vector_source': 'natural',
            'test_source': 'instruction'
        },
        'nat_nat': {
            'vector_source': 'natural',
            'test_source': 'natural'
        }
    }

    # Extract trait name without category for output filename
    trait_name = trait_path.split('/')[-1]

    results = {
        'experiment': experiment,
        'trait': trait_path,
        'n_layers': 26,
        'methods': ['mean_diff', 'probe', 'ica', 'gradient'],
        'quadrants': {}
    }

    for quadrant_name, config in quadrants.items():
        print(f"\n{quadrant_name}: {config['vector_source']} → {config['test_source']}")
        try:
            quadrant_results = run_quadrant(
                experiment,
                trait_path,
                quadrant_name,
                config['vector_source'],
                config['test_source']
            )
            results['quadrants'][quadrant_name] = quadrant_results
        except Exception as e:
            print(f"ERROR in {quadrant_name}: {e}")
            continue

    # Save results to experiment's validation directory
    output_dir = Path(f'experiments/{experiment}/validation')
    output_dir.mkdir(parents=True, exist_ok=True)
    output_file = output_dir / f'{trait_name}_full_4x4_results.json'

    with open(output_file, 'w') as f:
        json.dump(results, f, indent=2)

    print(f"\n{'='*60}")
    print(f"Results saved to: {output_file}")
    print(f"{'='*60}\n")

    # Print summary
    print("Summary:")
    for quadrant_name, quadrant_data in results['quadrants'].items():
        print(f"\n{quadrant_name}:")
        for method, method_data in quadrant_data['methods'].items():
            if 'best_accuracy' in method_data:
                print(f"  {method:12s}: {method_data['best_accuracy']*100:5.1f}% @ layer {method_data['best_layer']}")


def main():
    parser = argparse.ArgumentParser(
        description='Run cross-distribution analysis',
        epilog='Example: python scripts/run_cross_distribution.py --trait behavioral/refusal'
    )
    parser.add_argument('--experiment', type=str, default='gemma_2b_cognitive_nov20',
                       help='Experiment name (default: gemma_2b_cognitive_nov20)')
    parser.add_argument('--trait', type=str, required=True,
                       help='Trait path: category/trait_name (e.g., behavioral/refusal, cognitive/uncertainty_calibration)')
    args = parser.parse_args()

    # Validate trait format
    if '/' not in args.trait:
        raise ValueError(
            f"Trait must include category: got '{args.trait}'\n"
            f"Expected format: category/trait_name (e.g., behavioral/refusal)"
        )

    run_full_4x4(args.experiment, args.trait)


if __name__ == '__main__':
    main()
